[{"id":"6645f9f08a0f439574acbc46882dc4e0","title":"VIM 编辑器与用户管理","content":"VIM 编辑器与用户管理VIM编辑器1、Vim简介与模式Vim是一个高效文本编辑器，核心在于模式切换： \n普通模式（Normal Mode）：移动光标、执行命令（启动时默认模式）。 \n插入模式（Insert Mode）：输入&#x2F;编辑文本。 \n命令行模式（Command-line Mode）：保存、退出、搜索等操作。\n2、启动与退出启动Vim：终端输入 vim 文件名（文件不存在则新建）。 \n退出Vim： 普通模式下按 : 进入命令行模式。 \n​\t\t:q 退出（未修改时）。 \n​\t\t:q! 强制退出（不保存修改）。 \n​\t\t:wq 保存并退出。\n3、模式切换普通模式 → 插入模式： \n​\t\ti：光标前插入。 \n​\t\ta：光标后插入。 \n​\t\to：下一行插入。 \n插入模式 → 普通模式： \n​\t\t按 Esc 或 Ctrl+[ 。\n4、 基础移动（普通模式）方向键：h（左）、j（下）、k（上）、l（右）。 \n单词移动： \n​\t\tw：跳到下一个单词开头。 \n​\t\tb：跳到上一个单词开头。 \n行内移动： \n​\t\t0：行首，^：第一个非空字符。 \n​\t\t$：行尾。 \n全文移动： \n​\t\tgg：文件开头。 \n​\t\tG：文件末尾。 \n​\t\t50G：跳转到第50行。\n5、编辑文本删除： \n​\t\tx：删除光标处字符。 \n​\t\tdw：删除一个单词。 \n​\t\tdd：删除整行。 \n撤销与重做： \n​\t\tu：撤销操作。 \n​\t\tCtrl + r：重做撤销的操作。 \n复制与粘贴： \n​\t\tyy：复制当前行。 \n​\t\tp：粘贴到光标后。\n​\t\tP：粘贴到光标前。\n6、查找与替换查找： \n​\t\t普通模式下按 &#x2F;，输入关键词后回车（如 &#x2F;hello）。 \n​\t\tn 跳转到下一个匹配，N 上一个。 \n替换： \n​\t\t替换当前行第一个匹配：:s&#x2F;old&#x2F;new \n​\t\t替换当前行所有匹配：:s&#x2F;old&#x2F;new&#x2F;g \n​\t\t全文替换：:%s&#x2F;old&#x2F;new&#x2F;g（加 c 确认每次替换，如 :%s&#x2F;old&#x2F;new&#x2F;gc）。\n7、可视模式（Visual Mode）v：进入字符选择模式（按字符选择）。 \nV：进入行选择模式（按行选择）。 \nCtrl + v：进入块选择模式（垂直选择）。 \n操作：选中后按 y 复制，d 删除，p 粘贴。\n8、 配置Vim（.vimrc）创建配置文件：\n1vim ~/.vimrc\n\n常用配置示例：\n1234set number        # 显示行号syntax on         # 语法高亮set tabstop=4     # Tab缩进4空格set expandtab     # 用空格代替Tab\n\n9、VIM基础操作练习初始文件准备1vim file.txt  # 创建并打开文件\n\n文件初始内容（手动输入）12345applebananaorangegrapepear\n\n分步练习任务（1）打开文件并进入插入模式，在末尾添加一行 pineapple1234vim file.txtG               # 跳转到文件末尾i               # 进入插入模式（输入pineapple后按ESC）\n\n（2）复制第2行（banana）并粘贴到第4行下方12342G               # 跳转到第2行yy               # 复制当前行4G               # 跳转到第4行p                # 粘贴\n\n（3）删除第3行（orange）123G                # 跳转到第3行dd                # 删除当前行\n\n（4）显示行号并跳转到第5行（原pear行）12:set nu           # 显示行号5G                # 跳转到第5行\n\n（5）将光标移动到行首，插入 watermelon1230      # 跳转到行首i      # 进入插入模式（输入watermelon后按ESC）\n\n（6）查找所有 apple 并替换为 mango （仅替换前2行）1:1,2s/apple/mango/g  # 直接指定行号范围替换\n\n（7）撤销最后一次替换操作1u      # 撤销操作\n\n（8）强制退出不保存（模拟误操作）1:q!    # 强制退出\n\n（9）重新打开文件并另存为 backup.txt12vim file.txt  # 重新打开:w backup.txt # 另存为备份\n\n（10）保存并退出1:wq    # 保存退出\n\n","slug":"VIM-编辑器与用户管理","date":"2025-07-30T11:03:12.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"7e1e754a6541fda39aaf072fd6373097","title":"Linux文件管理与查询","content":"Linux文件管理与查询一、grep命令基础语法1grep [选项] &quot;搜索模式&quot; 文件或目录\n\n常用选项\n\n正则表达式\n\n\n实验练习准备：\n创建practice.txt文件，在桌面上打开终端\n1vim practice.txt\n\n在vim编辑器里将下面内容复制进去，保存后退出，在桌面上得到一个practice.txt文件\n\n实验 1.1：查找错误日志1grep &quot;ERROR&quot; practice.txt                #输出所有包含 &quot;ERROR&quot; 的行\n\n\n实验 1.2：忽略大小写匹配12grep -i &quot;error&quot; practice.txt             #匹配 &quot;error&quot;（不区分大小写）grep -i &quot;warning&quot; practice.txt           #匹配 &quot;WARNING&quot;（不区分大小写）\n\n\n实验 1.3：反向排除调试信息1grep -v &quot;WARNING&quot; practice.txt            #排除包含 &quot;WARNING&quot; 的行\n\n\n实验 2.1：显示匹配行号1grep -n &quot;ERROR&quot; practice.txt              #输出行号，如 `2:...[ERROR]...`\n\n\n实验 2.2：统计错误次数1grep -c &quot;ERROR&quot; practice.txt              #输出错误行数（示例结果：3）\n\n\n实验 3.1：查看错误上下文12grep -C 1 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 1 行grep -C 2 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 2 行\n\n\n\n实验 4.1：匹配时间范围12grep &quot;2023-10-01 08:1.&quot; practice.txt          #匹配 08:10 以后的行grep &quot;^2023-10-01 08:1&quot; practice.txt          #匹配行首为2023-10-01 08:1 的行\n\n\n\n实验 4.2：提取 IP 地址1grep -Eo &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt    #输出所有 IP 地址，如 192.168.1.100\n\n\n1grep -E &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt     #输出含有 IP 地址的行，如 192.168.1.100\n\n\n实验 4.3：精确匹配警告1grep -w &quot;WARNING&quot; practice.txt             #精确匹配&quot;WARNING&quot;\n\n\n实验 5.1：提取邮箱地址12grep -Eio &quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt     #输出邮箱地址grep -Eio &quot;\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt\n\n\n实验 5.2：查找金额记录1grep &#x27;\\$&#x27; practice.txt\n\n\n实验 6.1：扩展练习（目录递归）1234# 创建目录结构mkdir -p /tmp/practice/logs/cp practice.txt /tmp/practice/logs/echo &quot;ERROR: File not found&quot; &gt; /tmp/practice/error.log\n\n\n12# 递归搜索所有 &quot;ERROR&quot;grep -r &quot;ERROR&quot; /tmp/practice/\n\n\n12# 排除 .log 文件grep -r --exclude=&quot;*.log&quot; &quot;INFO&quot; /tmp/practice/\n\n\n二、find命令基础语法1find [搜索路径] [匹配条件] [执行动作]\n\n常用匹配条件\n按名称或路径匹配\n\n按文件类型匹配\n\n按文件大小匹配\n\n 按时间戳匹配\n\n按权限匹配\n\n逻辑操作符\n\n执行动作\n\n实验练习准备\n创建练习目录结构\n12345mkdir -p ~/find-practice/&#123;logs,data,backup&#125;touch ~/find-practice/logs/&#123;app.log,error.log&#125;touch ~/find-practice/data/&#123;file1.txt,file2.csv,image.jpg&#125;mkdir ~/find-practice/backup/oldtouch ~/find-practice/backup/old/archive.tar.gz\n\n实验 1.1：按名称搜索文件1find ~/find-practice/ -name &quot;*.log&quot;            #输出所有 .log 文件的路径\n\n\n实验 1.2：按类型搜索目录1find ~/find-practice -type d                   #列出所有子目录\n\n\n实验 1.3：组合条件（名称与大小）1find ~/find-practice -name &quot;*.jpg&quot; -size -10k  #查找小于 10KB 的 .jpg 文件\n\n\n实验 2.1：查找最近修改的文件1find ~/find-practice -mtime -1          # 列出 1 天内修改过的文件\n\n\n实验 2.2：排除特定权限文件1find ~/find-practice ! -perm 644     # 查找权限不是 644 的文件\n\n\n\n\n\n需求\n权限\n字母表示\n\n\n\n私有文件\n600\n-rw-------\n\n\n标准共享\n644\n-rw-r--r--\n\n\n组内共享\n664\n-rw-rw-r--\n\n\n可执行文件\n755\n-rwxr-xr-x\n\n\n共享目录\n775\ndrwxrwxr-x\n\n\n实验 3.1：删除空文件1find ~/find-practice -size 0 -delete     # 删除所有空文件\n\n\n实验 3.2：批量修改权限1find ~/find-practice -name &quot;*.sh&quot; -exec &#123;&#125; chmod &#123;&#125; 755 \\;             # 将所有 .sh 文件设为可执行\n\n实验 3.3：搜索并压缩文件12touch ~/find-practice/logs/&#123;app.log,error.log&#125;find ~/find-practice -name &quot;*.log&quot; -exec tar -cvsf logs.tar.gz &#123;&#125; +   # 将 .log 文件打包为 logs.tar.gz\n\n\ntar命令\n\n\n\n选项\n作用\n常见用法\n\n\n\n-c\n创建新归档文件\n必选（创建模式）\n\n\n-v\n显示详细过程（verbose）\n可选（显示打包文件列表）\n\n\n-s\n已废弃 原始排序（obsolete sort）\n现代 tar 已忽略此选项\n\n\n-f\n指定归档文件名\n必选（后接文件名）\n\n\n实验 4.1：忽略特定目录1find ~/find-practice -path &quot;*/backup&quot; -prune -o -name &quot;*.txt&quot; -print  # 查找所有 .txt 文件，但跳过 backup 目录\n\n提前创建了一个111.txt\n\n实验 4.2：结合  xargs 处理文件xargs 是 Linux&#x2F;Unix 系统中一个极其强大的命令行工具，用于构建和执行命令行参数。它弥补了管道(|)只能传递标准输出的不足，将输入数据转换为命令参数。\n1[命令产生输入] | xargs [选项] [目标命令]\n\n\n\n\n选项\n作用\n示例\n\n\n\n-I &#123;&#125;\n自定义占位符\n&#96;ls\n\n\n-n N\n每组N个参数\n&#96;seq 10\n\n\n-P N\n并发进程数\n&#96;find .\n\n\n-t\n打印执行命令\n&#96;echo “f”\n\n\n-p\n交互式确认\n&#96;ls\n\n\n-0\n处理特殊字符\n&#96;find -print0\n\n\n-d\n自定义分隔符\n&#96;echo “a,b,c”\n\n\n1find ~/find-practice -name &quot;*.csv&quot; | xargs -I &#123;&#125; mv &#123;&#125; ~/find-practice/data    #移动所有 .csv 文件到 data 目录\n\n常用场景\n案例学习1、找出系统中名为 passwd的文件1find / -name passwd -type f\n\n\n2、找出&#x2F;tmp目录中文件名带nz的文件，然后删除由于&#x2F;tmp目录下没有带nz的文件，所以先创建几个文件\n\n1find /tmp -name &quot;*nz*&quot; -type f -exec rm -fr &#x27;&#123;&#125;&#x27; \\;\n\n\n","slug":"Linux文件管理与查询","date":"2025-07-30T02:11:06.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"144f0b4d9b9f80ea377106e9c6a54a45","title":"Linux基础","content":"Linux基础内容一、计算机基础1、信息表示\n比特： 信息的基本单位（0 或 1）。\n二进制系统： 计算机内部所有信息（数字、文本、图像、声音、视频、指令）都用二进制数（0 和 1 的组合）表示。\n编码： 信息转换为二进制的过程（如 ASCII, Unicode 编码字符， JPEG 编码图像， MP3 编码声音）。\n\n2、冯·诺依曼体系结构（现代计算机的基石）\n核心思想： 存储程序概念。\n五大部件：\n输入设备： 接收外部数据&#x2F;指令（键盘、鼠标、麦克风、摄像头、传感器）。\n输出设备： 向外界呈现结果（显示器、打印机、扬声器）。\n运算器： 执行算术运算和逻辑运算。\n控制器： 协调指挥各部件的运作，取指令、解码指令、执行指令。\n存储器：\n内存： 速度快、容量较小、易失性（断电数据丢失）。存放当前运行的程序和数据（RAM：Random Access Memory）。\n外存： 速度慢、容量大、非易失性（断电数据保留）。长期存储程序和数据（硬盘、固态硬盘SSD、U盘、光盘）。\n\n\n\n\n\n3、硬件：计算机的物理组成部分。\n中央处理器： 计算机的“大脑”，包含运算器和控制器。核心指标：主频、核心数、缓存大小。\n内存： 供 CPU 直接访问的高速工作区 (RAM)。\n主板： 连接所有部件的“骨架”，包含各种接口、芯片组、总线等。\n存储设备： 硬盘驱动器、固态硬盘、U 盘等。\n输入设备： 如上述。\n输出设备： 如上述。\n扩展卡： 显卡、声卡、网卡等。\n电源： 提供稳定电力。\n\n4、软件：计算机运行的指令&#x2F;程序集合。硬件是躯体，软件是灵魂。\n系统软件：\n操作系统： 管理硬件资源、提供用户&#x2F;应用程序接口、是软硬件沟通的桥梁（如：Windows, macOS, Linux, Android, iOS）。核心功能：进程管理、内存管理、文件管理、设备管理、用户界面。\n驱动程序： 使操作系统能与特定硬件设备通信的软件。\n实用工具： 辅助管理计算机的工具（如：磁盘清理、杀毒软件）。\n\n\n应用软件： 为用户完成特定任务的程序（如：浏览器、办公软件、游戏、媒体播放器、图像处理软件）。\n\n5、数据与程序\n数据： 计算机处理的原始材料（未经处理的信息）。\n程序： 一系列指令的集合，告诉计算机如何处理数据。\n指令： 计算机执行的最小操作单位（如：加、减、移动数据）。\n\n6、CPU的架构​\t\t前面说过的，CPU其实内部已经含有一些微指令，我们所使用的软件都要经过CPU内部 的微指令集来达成才行。 那这些指令集的设计主要又被分为两种设计理念，这就是目前世界 上常见到的两种主要CPU架 构，分别是：精简指令集（RISC）与复杂指令集（CISC）系统。\n\n\n\n特征\n精简指令集 (RISC)\n复杂指令集 (CISC)\n\n\n\n设计目标\n简化指令以提高单周期执行效率\n减少程序代码量，贴近高级语言操作\n\n\n指令复杂度\n简单：指令长度固定，功能单一（如LOAD/STORE）\n复杂：支持多功能指令（如单条指令实现字符串处理）\n\n\n指令长度\n固定（通常32位）\n可变（1至15字节不等）\n\n\n寄存器数量\n多（数十至数百个），减少内存访问\n较少，依赖内存操作\n\n\n执行方式\n单周期指令为主，流水线深度优化\n复杂指令需多周期执行（微程序控制）\n\n\n代码密度\n较低（相同功能需更多指令）\n较高（单条指令完成复杂任务）\n\n\n典型架构\nARM（手机&#x2F;嵌入式）、RISC-V、MIPS、PowerPC\nx86（Intel&#x2F;AMD桌面&#x2F;服务器）、z&#x2F;Architecture（IBM大型机）\n\n\n编译器作用\n关键：负责指令调度和效率优化\n简化编译（复杂指令直接映射高级操作）\n\n\n\n选择精简指令集（RISC）的场景：追求高能效比（手机&#x2F;物联网）、定制化需求（RISC-V开源生态）。\n选择复杂指令集 (CISC)的场景：兼容历史代码（x86生态）、高代码密度（存储成本敏感型系统）。\n未来方向：两者在设计上持续趋同，效率、功耗、灵活性的平衡成为关键。\n\n7、操作系统定义：操作系统是管理计算机硬件与软件资源的系统软件，扮演中介者角色：直接控制CPU、内存、磁盘、网络等硬件；为应用程序（如浏览器、游戏）提供运行环境和服务。​本质​：​资源的超级管家​（硬件资源 + 软件协调）。\n（1）进程管理（Process Management）\n进程：运行中的程序实例（需CPU、内存等资源）。\n核心任务：\n创建&#x2F;销毁进程\n进程调度：分配CPU时间片（算法如：先来先服务FCFS、轮转调度RR、优先级调度）\n进程同步：解决并发冲突（如信号量、互斥锁）\n进程通信：进程间数据交换（IPC机制）\n\n\n\n（2）内存管理（Memory Management）\n核心任务：\n分配&#x2F;回收内存：为进程动态分配空间（如堆、栈）。\n虚拟内存：将硬盘空间虚拟为内存，解决物理内存不足（通过分页&#x2F;分段技术）。\n内存保护：防止进程越权访问内存（如MMU硬件支持）。\n\n\n\n（3）文件系统管理（File System Management）\n文件：存储在磁盘上的数据逻辑单元（文本、图片等）。\n核心任务：\n组织文件：目录树结构（如Windows的C:\\、Linux的&#x2F;）。\n读写控制：提供open&#x2F;read&#x2F;write等API。\n磁盘空间管理：分配块、碎片整理（如NTFS、EXT4文件系统）。\n\n\n\n（4）设备管理（I&#x2F;O Device Management）**\n核心任务：\n设备驱动：为打印机、键盘等硬件提供统一接口。\n缓冲区管理：优化慢速设备与CPU的速率差异（如磁盘缓存）。\n即插即用：动态识别设备（如USB热插拔）。\n\n\n\n（5）安全与权限管理（Security &amp; Protection）**\n用户认证：登录密码、生物识别。\n访问控制：文件权限（如Linux的rwx权限位）。\n防火墙与加密：防止外部攻击（如Windows Defender）。\n\n\n\n\n模块\n作用\n\n\n\n内核（Kernel）\n核心代码，直接操作硬件（进程调度、中断处理、内存映射）。\n\n\n系统调用接口\n应用程序访问内核服务的接口（如Linux的syscall、Windows的API）。\n\n\n用户界面\n用户与系统交互的入口（GUI图形界面如Windows桌面 &#x2F; CLI命令行如Linux终端）。\n\n\n系统工具\n内置实用程序（任务管理器、磁盘清理、网络配置工具）。\n\n\n驱动程序\n硬件厂商提供的设备控制软件（如NVIDIA显卡驱动）。\n\n\n8、内核Kernel内核（Kernel） 是操作系统的最核心组件，直接运行在硬件之上，负责管理系统最底层的资源和关键功能。它如同计算机的“中枢神经系统”，是所有软硬件交互的必经之路。\n内核的核心职责\n硬件抽象与管理\n直接操作 CPU、内存、磁盘、网络设备 等物理硬件。\n为上层软件提供统一的资源访问接口（如内存分配、磁盘读写），隐藏硬件差异。\n\n\n进程调度\n决定哪个进程使用 CPU、何时使用、使用多久。\n通过调度算法（如 CFS（Linux完全公平调度器））平衡效率与公平性。\n\n\n内存管理\n分配&#x2F;回收物理内存和虚拟内存空间。\n实现 虚拟内存机制（通过分页&#x2F;分段技术将硬盘空间扩展为“虚拟RAM”）。\n\n\n中断与异常处理\n响应硬件中断（如键盘按下、网络数据到达）和软件异常（如除零错误）。\n每秒处理数万次中断（如系统时钟中断频率通常为 100–1000 Hz）。\n\n\n系统调用接口（Syscall）\n提供应用程序访问内核功能的唯一通道（如文件操作 open()、进程创建 fork()）。\n用户程序无法直接操作硬件，必须通过内核“代办”。\n\n\n设备驱动管理\n集成设备驱动程序（如显卡、声卡驱动），协调硬件与软件的通信。\n\n\n\n内核工作流程示例：启动程序\n用户双击应用图标 → Shell调用 exec() 系统调用。\n内核切换到内核态：\n分配内存空间 → 装载程序代码 → 创建新进程 → 调度CPU执行。\n\n\n程序运行时调用 printf() → 触发 write() 系统调用 → 内核将数据发送到终端。\n程序结束 → 内核回收内存，更新进程状态。\n\n例如：想要在电脑上播放音乐：\n1、内核让播放器占用CPU\n2、声卡驱动让数字信号变成电信号\n9、文件系统文件系统（File System） 是操作系统用来组织、存储和管理数据的核心机制。它定义了数据如何被命名、存储、检索及更新，将硬盘的原始存储空间转化为用户和程序可理解的逻辑结构（文件与目录）。\n核心功能\n命名与组织\n文件：存储数据的逻辑单元（文本、图片等），通过文件名（如 report.txt）标识。\n目录（文件夹）：分层结构（如 /home/user/docs/），实现文件分类管理。\n路径：定位文件的唯一标识（如 Linux 的 /etc/config，Windows 的 C:\\Program Files）。\n\n\n数据存储与寻址\n块（Block）：物理存储的最小单位（通常 4KB）。\n文件分割：大文件被拆分为多个块，分散存储在磁盘不同位置。\n元数据（Metadata）：记录文件属性（名称、大小、创建时间、权限、存储位置等）。\n例如：Linux 的 inode 存储元数据，但不包含文件名（文件名在目录中记录）。\n\n\n\n\n空间管理\n分配策略：标记已用&#x2F;空闲块（位图法、链表法）。\n碎片处理：\n外部碎片：空闲块分散 → 碎片整理（Defragmentation）合并连续空间。\n内部碎片：块未充分利用（如 1KB 文件占用 4KB 块）。\n\n\n\n\n数据可靠性与恢复\n日志（Journaling）：记录操作意图（如 ext4 的日志），崩溃后恢复一致性。\n冗余备份：RAID、副本机制（如 ZFS 的 Copy-on-Write）。\n\n\n\n主流文件系统对比\n\n\nFAT32\nU盘、老式设备\n跨平台（Win&#x2F;macOS&#x2F;Linux通用）\n单文件≤4GB，无日志、易碎片化\n\n\n\nNTFS\nWindows 主磁盘\n支持大文件（16EB）、ACL权限控制\nmacOS&#x2F;Linux 写入需额外驱动\n\n\nexFAT\n闪存设备（SD卡）\n轻量级、大文件支持（64ZB）\n无日志、数据恢复能力弱\n\n\next4\nLinux 主系统\n日志可靠、支持64位存储（1EB）\nWindows 不原生支持\n\n\nAPFS\nmacOS&#x2F;iOS\n针对SSD优化（写时复制）、加密强\n不兼容传统机械硬盘\n\n\nZFS\n企业级存储\n自愈校验、实时压缩、快照克隆\n内存占用高、复杂度大\n\n\n例如：在保存一个文件时：\n1、文件系统决定把它存放在哪 \n2、下次打开的时候，能够快速找到\n10、用户界面UI用户界面（User Interface, UI） 是人与计算机系统之间进行信息交换的媒介，是用户感知并操作数字世界的“窗口”。其核心目标是通过直观的交互方式降低技术使用门槛，让用户高效、无痛地达成目标。\nUI的核心作用​\t1、信息展示\n\n将计算机处理的数据转化为人类可理解的视觉&#x2F;听觉&#x2F;触觉反馈（如文字、图标、声音提示）。\n\n​\t2、操作入口\n\n提供用户向系统发送指令的途径（点击按钮、语音命令、手势等）。\n\n​\t3、降低认知负荷\n\n通过符合直觉的设计减少用户学习成本（如回收站图标表示删除文件恢复）。\n\nUI的三大类型1.命令行界面（CLI - Command Line Interface）\n\n形式：用户输入文本指令（如 rm -rf file.txt）。\n场景：服务器运维、开发者调试（Linux终端、Windows CMD）。\n优点：高灵活性、可脚本化批量操作。\n缺点：需记忆命令语法，对新手极不友好。示例：黑客电影中快速滚动的黑色终端窗口即CLI。\n\n2.图形用户界面（GUI - Graphical User Interface）\n\n形式：视觉化元素（窗口、图标、菜单、按钮）。\n交互方式：鼠标点击、键盘快捷键、触控手势。\n场景：桌面操作系统（Windows&#x2F;macOS）、手机APP、网页。\n关键组件：\nWIMP范式：窗口（Window）、图标（Icon）、菜单（Menu）、指针（Pointer）。\n控件库：按钮、输入框、滑块、复选框等。\n\n\n优点：直观易学，适合大众用户。示例：Windows桌面就是GUI的典型，拖动文件&#x3D;用户向系统发出移动数据指令。\n\n3. 自然用户界面（NUI - Natural User Interface）\n\n形式：模仿人类自然行为（语音、手势、眼神）。\n技术依赖：\n语音识别：Siri&#x2F;小爱同学唤醒智能家居\n计算机视觉：手势控制（如微软Kinect）、面部解锁\n触觉反馈：AR&#x2F;VR设备震动模拟触感\n\n\n场景：智能汽车控制、AR游戏（如Pokémon GO）、无障碍交互。\n演进方向：脑机接口（Neuralink）、全息交互（Meta元宇宙）。\n\n11、网络基础\n定义： 多台计算机或设备通过通信链路（有线或无线）连接起来，实现资源共享和信息交换。\n互联网： 全球最大的计算机网络。\n主要概念：\n协议： 设备通信的规则（如：TCP&#x2F;IP - 互联网的基础协议）。\nIP地址： 网络中设备的唯一标识符。\n域名系统： 将便于记忆的域名翻译成 IP 地址。\n万维网： 建立在互联网上的信息服务系统（网页、超链接等）。\n网络类型： 局域网、城域网、广域网。\n关键设备： 路由器、交换机、调制解调器。\n\n\n\n12、工作原理\n用户通过输入设备输入指令或数据。\n数据&#x2F;指令被送入内存。\nCPU 的控制单元从内存中取出指令进行解码。\nCPU 的运算器根据指令要求，从内存中取出数据进行运算。\n运算结果送回内存暂存或送到输出设备。\n结果通过输出设备呈现给用户或存储到外存设备。\n\n场景：在电脑上通过浏览器看视频，操作系统如何工作？\n1、打开浏览器 UI告诉内核，用户要打开浏览器\n2、内核分配内存以及CPU\n3、访问网络 网络驱动控制网卡下载视频\n4、观看视频 内核会同时处理视频解码、声音\n5、关闭浏览器，释放内存\n13、计算机科学与信息技术\n计算机科学： 侧重于计算理论、算法、编程语言、计算机体系结构、操作系统、人工智能等基础研究。\n信息技术： 侧重于应用计算机系统和网络解决实际问题，如系统管理、网络管理、数据库管理、软件开发（偏应用）、技术支持等。\n\n14、计算机的应用领域\n科学研究、工程设计与制造、通信与媒体、教育与学习、医疗保健、金融交易与服务、企业管理（ERP&#x2F;CRM）、人工智能（智能助手、自动驾驶）、娱乐（游戏、影视）、政府公共服务等。\n\n二、Linux是什么？Linux 是一种自由、开源、类 Unix 的操作系统内核，同时也是基于该内核构建的一整套操作系统和软件生态系统的统称。简单来说，Linux 是一个强大、稳定且高度可定制的计算机系统基础。\n1、核心是 Linux 内核：\n由芬兰程序员林纳斯·托瓦兹在 1991 年作为个人项目开始开发。\n它是最核心的部分，负责管理计算机的硬件资源（CPU、内存、磁盘、网络、外设等），并为软件（应用程序）提供运行的基础服务和接口。\n内核是操作系统的心脏，调度任务，管理文件系统，处理输入输出等。\n\n2、完整的操作系统 - Linux 发行版：\n单独的内核本身对普通用户来说无法直接使用。一个完整的、用户友好的操作系统需要包含：\n内核\n系统工具（如命令行 Shell bash）\n软件包管理系统（用于安装、更新和卸载软件）\n基本的库\n用户界面（图形用户界面 GUI 或命令行界面 CLI）\n各种应用程序（浏览器、办公软件、媒体播放器等）\n\n\n这就是 Linux 发行版的概念。不同的组织、公司或社区会将 Linux 内核、各种自由&#x2F;开源软件以及他们自己开发的管理工具打包在一起，形成可直接安装使用的操作系统，称为 发行版。\n常见的著名发行版：\nUbuntu： 用户友好，非常适合桌面用户和个人开发者入门。\nDebian： 非常稳定，Ubuntu 等许多发行版的基础。\nFedora： 由 Red Hat 支持，通常采用较新的技术。\nCentOS Stream &#x2F; Rocky Linux &#x2F; AlmaLinux： 企业级稳定性和长期支持的典范（尤其面向服务器）。\nopenSUSE： 以强大的配置工具和稳定性著称。\nArch Linux： 轻量、高度可定制，适合经验丰富的用户。\nLinux Mint： 基于 Ubuntu，对桌面用户极其友好，尤其是从 Windows 转过来的用户。\nKali Linux： 专注于网络安全测试和渗透测试。\n\n\n\n3、核心特性：\n开源与自由：\n开源： Linux 内核和构成发行版的大部分软件的源代码都是完全公开、可自由查看、修改的。这带来了巨大的透明度、安全性和协作创新的可能。\n自由： 用户拥有自由运行、学习、修改和重新分发软件（包括修改后的版本）的权利。这得益于其采用的许可证，主要是 GNU GPL。\n\n\n类 Unix： Linux 在设计哲学和接口上借鉴了成熟的 Unix 操作系统（如 POSIX 标准），使其具有强大的命令行工具、稳定性、多用户&#x2F;多任务能力以及高度可组合性（小工具组合完成复杂任务）。\n稳定性与可靠性： Linux 以其在服务器和高负载环境下的稳定性著称，通常可以持续运行数月甚至数年而无需重启。\n安全性： 得益于开源特性（漏洞更容易被发现和修复）、强大的权限系统设计以及活跃的社区响应，Linux 通常被认为比某些专有操作系统更安全。\n高可定制性： 用户可以从轻量级的纯命令行系统到功能丰富的桌面环境进行选择。几乎每个组件都可以被替换或调整以满足特定需求。\n免费： 绝大多数 Linux 发行版可以免费下载、安装和使用。商业支持通常面向企业级服务。\n广泛的硬件支持： 内核内置支持大量硬件，尤其是在服务器、嵌入式设备和超级计算机上。主流桌面硬件（尤其是较新的）支持也非常好。\n强大的社区支持： 拥有全球范围内庞大而活跃的用户和开发者社区，提供丰富的文档、教程、论坛和互助渠道。\n\n4、GPLv2Linux 内核采用 GNU General Public License version 2 (GPLv2) 作为其开源许可协议。理解 GPL 对理解 Linux 的核心运作理念至关重要：\nGPL 的核心宗旨（Copyleft 原则）1.保证自由：GPL 的根本目标是确保软件及其衍生作品始终保持自由。它授予用户四项核心自由：\n\n自由 0： 运行程序的自由，无论任何目的。\n自由 1： 学习和修改程序源代码的自由（获取源码是前提）。\n自由 2： 重新分发软件的自由，帮助他人。\n自由 3： 将修改后的版本分发给其他人的自由（这要求同时提供修改后的源代码，让社区受益）。\n\n2.“传感染”特性 (Copyleft)： 这是 GPL 最显著的特点。\n\n如果你分发基于 GPL 许可软件（如 Linux 内核）的修改版本或包含它的程序，整个分发也必须遵循 GPLv2。\n你必须向程序的接收者提供完整的、可修改的源代码。\n不能在分发时添加额外的限制（例如，不能禁止用户对软件进行反向工程、不能再许可、不能要求付费购买许可密钥等）。\n这种特性确保自由不会在后续分发中“流失”，自由软件网络会持续扩大。\n\nLinux 内核与 GPLv2 的具体关系1.版本选择：Linux 内核严格采用 GPLv2，不是较新的 GPLv3。林纳斯·托瓦兹 (Linus Torvalds) 和其他核心开发者对此选择有明确立场，主要涉及对 GPLv3 中某些条款（如对硬件限制如 Tivoization 的约束）的顾虑。\n2.动态加载模块： 这是一个复杂的法律边界问题。\n\n观点一（严格派）： 内核是 GPLv2 代码，任何动态链接到内核的模块（如驱动程序）都被认为与内核形成了一个整体作品，因此必须也是 GPLv2（或兼容）许可的。专有（闭源）内核模块违反了 GPL。\n观点二（宽松派 &#x2F; Linus 观点）： 如果内核模块只使用了内核公开的、稳定的、设计用于模块交互的 API（而不是直接访问内部函数或数据结构），并且是“非衍生的独立作品”，可能可以不是 GPL（虽然 LKML 社区强烈不鼓励闭源模块）。\n现实状况： 许多硬件厂商提供闭源驱动（二进制 blob），但这在法律上存在风险，也被开源社区认为违背了 GPL 的精神。社区和项目（如 FSF）持续努力用开源驱动替代闭源驱动。内核本身也提供了一些机制（如 EXPORT_SYMBOL_GPL）来标记只允许 GPL 模块调用的函数。\n\n3.用户空间程序不受此限：GPLv2 仅约束与 Linux 内核直接链接（形成组合作品）的程序，主要是内核模块。在 Linux 上运行的用户空间应用程序（如 Firefox, LibreOffice）不受内核 GPLv2 的限制。它们可以使用任何许可（GPL、LGPL、MIT、BSD、Apache 甚至是专有许可）。这是 GNU&#x2F;Linux 系统中“GNU”部分存在的原因之一——GNU 项目提供了在自由许可下的完整用户空间工具链。\nGPL 对 Linux 生态系统的意义1.成功的基石： GPL 是 Linux 成功的最关键因素之一。它确保了：\n\n源代码的开放性和可审计性： 任何人都可以检查、学习、改进代码，提高了安全性、可靠性和创新速度。\n广泛的协作开发： 企业（如 Red Hat, IBM, Intel, Google）和个人开发者都可以放心贡献，知道他们的贡献永远不会成为某家公司的私有财产。\n自由的保障： 用户可以确信自己拥有运行、修改和分发自由的权利，不会被供应商锁定。\n\n2.商业支持可行：GPL 允许公司基于 Linux 提供服务（技术支持、定制开发、云服务等）和分发商业发行版（如 RHEL, SUSE），只要它们遵守提供源码的义务（主要针对内核本身的修改）。红帽模式（提供开源代码，销售服务订阅）是成功的典范。\n3.巨大的社区和碎片化：GPL 催生了庞大的开发者社区和数量众多的发行版（Debian, Ubuntu, Fedora, Arch 等）。虽然碎片化可能是个挑战，但也提供了巨大的选择和灵活性。\n与其他开源许可的主要区别\n宽松许可 (MIT, BSD, Apache)： 允许修改版以专有闭源形式再发布（只要求保留版权声明）。用户自由在后续分发中可能丢失。例子：FreeBSD, Android ASOP。\n弱 Copyleft (LGPL)： 主要设计用于库，允许专有代码链接到 LGPL 库而不“感染”整个程序（只要遵守 LGPL 对库本身的条款）。例子：Glibc, GTK。\nGPL (Strong Copyleft)： 要求组合作品或衍生作品整体都必须保持 GPL（提供源码）。如 Linux 内核。例子：Linux kernel, GIMP, GCC。\nAGPL： 针对网络服务，如果修改后通过网络提供软件服务，也必须提供对应的源代码。例子：MongoDB (曾用过)， Nextcloud。\n\n5、Linux与UnixLinux 与 Unix 的关系非常密切，但又有本质区别。可以说 Linux 是 Unix 思想的继承者和发展者，但不是 Unix 代码的直系后代。它们共同构成了“Unix-like”操作系统家族的核心。理解它们的关系需要从历史、技术、许可和生态几个维度来看：\n1. Unix：开创者与标准\n起源 (1969)： 诞生于 AT&amp;T 的贝尔实验室（Ken Thompson, Dennis Ritchie 等人）。用 C 语言重写后（1973 年左右），其可移植性为普及奠定了基础。\n**关键特征：**引入了许多奠基性的概念：\n“一切皆文件”： 统一的文件、设备和进程间通信抽象。\n小型、单一目的工具： grep, sed, awk, ls, cat 等，可通过管道 | 组合 (command1 | command2)，遵循“组合优于继承”原则。\n层次化文件系统： root (/) 下的树状结构。\n多用户、多任务： 同时支持多个用户运行多个程序。\n内置强大 Shell： 作为用户和系统交互的主要界面。\n\n\n许可与分裂：\n早期： AT&amp;T 开始向学术界和商业机构提供源代码许可。\n**衍生分支：**不同机构在 AT&amp;T Unix 源码基础上发展出众多变体：\nBSD (Berkeley Software Distribution): 加州大学伯克利分校开发，产生了 FreeBSD、NetBSD、OpenBSD 等。\n商业 Unix: Sun Solaris (SunOS)、IBM AIX、HP-UX、SCO UnixWare、ATT System V 等。\n\n\n“Unix 战争”： 各个商业版本在标准化上竞争激烈，存在互不兼容问题。\n\n\n标准： 为解决兼容性问题，诞生了 POSIX (Portable Operating System Interface) 标准（由 IEEE 指定）。它定义了操作系统为兼容 Unix 风格所需提供的最小 API 接口标准（如系统调用、shell 行为等）。\n\n2. Linux：开源的新兴力量\n**起源 (1991)：**由芬兰大学生 Linus Torvalds开发，初衷是创建一个 免费、开源的类 Unix 内核。\n关键背景：GNU 计划 (1983年启动，Richard Stallman)：目标是创建一个完全自由的操作系统 GNU，在1991年时几乎完成了所有用户空间工具 (GCC, glibc, bash, coreutils 等)，但唯独缺少一个成熟可用的内核（GNU Hurd 进展缓慢）。\n\n\n核心特点：\n只是内核 (Kernel)： Linux 本身不是完整的操作系统，只是系统的核心（管理硬件、进程、内存等）。用户空间工具主要来自 GNU。\n开源自由： 采用 GPLv2 许可证，保证了其自由传播、修改和使用的权利。\n设计理念： 严格遵循 Unix 哲学，但 不包含任何原始的 AT&amp;T Unix 源代码（是干净的重新实现，避免了法律纠纷）。\n高度模块化： 支持动态加载内核模块。\n可移植性强： 支持极其广泛的硬件架构（从超级计算机到嵌入式设备）。\n\n\nLinux 发行版 (Linux Distribution)： 一个 完整的操作系统通常 &#x3D; Linux 内核 + GNU 工具链&#x2F;库 + 其他软件（桌面环境、包管理器、应用等）  + 集成安装&#x2F;配置工具。常见的发行版包括：\n商业支持： Red Hat Enterprise Linux (RHEL)、SUSE Linux Enterprise Server (SLES)、Ubuntu Pro (Canonical)。\n社区驱动： Debian、Ubuntu (社区版本)、Fedora (RHEL 上游)、openSUSE (SLES 上游)、Arch Linux、Gentoo 等。\n\n\n\n3. Linux 与 Unix 的关键关系与区别\n\n\n特征\nUnix (传统的，如 System V, BSD, AIX, Solaris)\nLinux\n\n\n\n血统\n直接或间接来源于 AT&amp;T 贝尔实验室的原始 Unix 源代码。\n独立开发，不包含任何 AT&amp;T Unix 源码。是一个全新的实现，遵循 Unix 设计理念。\n\n\n内核\n单一内核（Monolithic Kernel）或混合内核设计。不同分支内核名称各异（如 Solaris Kernel）。\nLinux 内核（也是单一内核设计）。\n\n\n许可\n历史上多为专有许可：商业 Unix 要求高昂的许可费。BSD 系统采用宽松的开源协议（如 BSD License，允许闭源再分发）。\n内核采用 GPLv2（强 Copyleft）。用户空间工具多为 GPL 或 LGPL。核心原则是自由和开源。\n\n\n所有权\n历史上由 AT&amp;T 所有，后分裂为多个商业实体所有（IBM, Oracle, HPE 等）。BSD 由社区维护。\n不属于任何单一实体。由社区（个人和公司）共同开发维护。Linux 商标归 Linus Torvalds 所有。\n\n\n标准化\nPOSIX 标准的最初目标对象。各大商业版本曾试图主导自己的标准。\n完全兼容 POSIX 标准（遵循其 API 和 shell 行为规范）。\n\n\n开发模型\n历史上是闭源专有开发。BSD 系列采用开源社区协作模式。\n大规模的开源协作模式。任何人都可以参与贡献代码（通过邮件列表、Git）。版本控制明确（Git）。\n\n\n变体&#x2F;碎片化\n形成了多个不兼容的商业分支（Solaris, AIX, HP-UX）。BSD 分支（FreeBSD, OpenBSD, NetBSD）相对独立但更兼容。\n存在大量发行版（数百个），它们在 软件包管理、默认配置、打包策略、桌面环境、支持周期 上差异很大。但都使用同一个 Linux 内核（不同版本），应用层兼容性较好（POSIX + 发行版差异）。\n\n\n硬件支持\n传统商业 Unix 通常紧密绑定厂商特定的硬件（RISC 架构，如 SPARC, Power）。\n支持极其广泛的硬件架构：x86&#x2F;x86_64, ARM, RISC-V, POWER, MIPS, 等等。硬件驱动生态系统庞大（开源社区驱动 + 厂商贡献）。\n\n\n用户 &amp; 用途\n传统上用于高端服务器、工作站和大企业关键任务系统。成本高昂。\n无处不在：超级计算机、服务器集群、云计算、数据中心、嵌入式系统、路由器、智能手机(Android 基于 Linux 内核)、桌面&#x2F;笔记本电脑。\n\n\n6、主要应用领域：\n服务器： Linux 是互联网的基石。绝大部分的 Web 服务器、云服务器、数据库服务器等都运行 Linux。\n超级计算机： 全球性能最强的超级计算机几乎都运行基于 Linux 的系统。\n嵌入式设备： 智能手机（Android 基于 Linux 内核）、路由器、智能电视、物联网设备、车载娱乐系统等。\n开发者工作站： 命令行工具、软件包管理和开发环境使其成为开发者的首选，尤其在 Web 开发、云计算、数据科学、人工智能等领域。\n桌面电脑： 越来越多的用户将 Ubuntu、Fedora、Mint 等作为日常使用的操作系统，替代 Windows 或 macOS。\n基础设施： 路由器、防火墙、NAS 存储等网络设备大量使用 Linux。\n\n三、Linux目录结构1/            #根目录\n\n起始点，系统上所有的文件都存在这里\n1/root /home  #家目录\n\n1/root        #存放root的配置文件\n\n1/home        #存放用户的普通文件\n\n12345678910111213141516171819202122/etc                                    #系统配置目录/etc/sysconfig/network-scripts          #网卡配置文件/etc/yum.repos.d/CentOS-Base.repo       #操作系统软件包/etc/yum.repos.d/CentOS-AppStream.repo  #应用流软件包/etc/yum.repos.d/CentOS-Extras.repo     #额外软件补充包mirrorlist                              #两种指定仓库位置的配置方式，他的工作方式：直接指定仓库                                        #工作流程：直接访问指定的URL，下载仓库数据                                        #如果地址不可达，会报错baseurl                                 #先访问mirrorlist url的获取镜像地址列表                                               #下载出列表，并开始测试响应速度                                        #选择出最优的镜像进行连接，下载仓库数据                                       SElinux                                 #美国国家安全局提出的概念：强制访问控制安全机制，用于增强linux的安全性                                            #自主访问控制安全机制 rw                                        #三种模式：                                        #enforcing：强制模式（默认）：严格执行安全策略的，违规操作会被阻止                                        #permissive：标准模式/宽容模式：会允许并记录                                        #disable：禁用，完全关闭并记录                                                         #SElinuxTYPE：targeted：仅保护安全进程；mls：多级安全策略，用于军事领域\n\n123/dev               #设备文件目录                   #存放的是所有硬件设备                   #权限：仅仅只有root或disk用户组有操作权限\n\n12/bin               #系统命令目录/sbin              #管理员级系统命令，专供超级管理员（root用户）使用\n\n为什么linux要把所有命令存放在目录？单用户模式（救援模式、维护模式）下依然可以使用，多为系统运行必需的命令。\n123456789101112131415/var                #存储动态变化的数据目录，会随着系统运行不断增长/var/log            #系统和服务日志（如syslog、nginx/access.log）。在能够写入日志的情况下，写入木马，获取shell/var/lib            #应用程序数据（如 MySQL 数据库/var/lib/mysql）。mysql数据库、docker容器/var/spool          #队列数据（如邮件队列 /var/spool/mail）。/var/log/secure     #安全认证日志（如 SSH 登录记录）。/var/log/messages   #核心系统日志（替代通用 syslog）/tmp                #存放临时文件，全局可读写的，重启会清空/usr                #存储的是静态的用户进程、用户命令、库文件、共享数据\n\n数据性质：&#x2F;var 动态变化；&#x2F;tmp 临时数据；&#x2F;usr 静态只读\n是否可以删除？:&#x2F;var 是部分可删；&#x2F;tmp 可删；&#x2F;usr不可删\n是否需要备份？：&#x2F;var部分需要备份（数据库）；&#x2F;tmp不需要备份；&#x2F;user不需要备份\n文件大小？&#x2F;var  10G 以上，日志可能会膨胀；&#x2F;tmp  1G 以内；&#x2F;usr   5G - 20G 左右 Linux 基础系统\n分区情况：&#x2F;var 建议单独分区；&#x2F;tmp 通常会挂载为tmpfs；&#x2F;usr 通常和&#x2F;合并\n123/boot                #是启动linux系统所需的核心文件                     #内核kernel就i是存放在这里面                     #临时根文件系统\n\n1/lib\t             #核心共享库和内核模块\n\n1/proc\t             #内核与进程虚拟文件系统（实时系统状态）\n\n1/sys                 #硬件设备虚拟文件系统（配置内核参数）\n\n1/opt                 #第三方软件（大型独立应用）\n\n1/mnt                 #临时挂载点（手动挂载设备）\n\n1/media               #可移动设备自动挂载点\n\n\n\n四、Linux：一切皆文件123456789101112131415161718192021222324252627282930touch filename                   #创建文件touch file1 file2                #批量创建文件mkdir dir1                       #创建目录mkdir -p dir1/dir2               #创建嵌套目录结构mkdir -m 750 dir1                #创建权限为 drwxr-x--- 的目录cp 1.txt dir1                    #复制文件到目录cp -r dir1 dir2                  #复制目录mv 1.txt 2.txt                   #重命名mv 1.txt dir1                    #移动文件到目录rm -r dir1                       #删除目录rm -f dir1                       #强制删除rm -rf dir1                      #强制删除目录及内容#慎用！多用mv 少用rmvim 1.txt                        #打开 Vim 文本编辑器来创建或编辑名为 1.txt 的文件cat 1.txt                        #查看文件内容less                             #分页查看文件cat filename | less tail                             #查看文件末尾  tail -n 20 filename              #查看文件末尾20行tail -f app.log | grep &quot;ERROR&quot;   #实时跟踪日志文件并过滤出包含&quot;ERROR&quot;的行\n\n","slug":"Linux基础","date":"2025-07-29T02:38:02.000Z","categories_index":"","tags_index":"Linux学习","author_index":"wyf"},{"id":"1991d92d523634790e777614ebed22a2","title":"CentOS 8 环境搭建及配置","content":"CentOS 8 虚拟机搭建及配置一、下载安装Vmware Workstation在网上找教程，这里使用Vmware Workstation Pro 17\n二、下载CentOS 8 虚拟机镜像源在网上找下载地址，这里不做提供\n一、创建CentOS 8 虚拟机1、打开Vmware Workstation创建虚拟机点击右上角文件，新建虚拟机\n\n选择自定义，点击下一步\n\n硬件兼容性，这里选择Workstation 17.x，在新版本创建的虚拟机如果想在老版本使用可能会出错，点击下一步\n\n点击稍后安装操作系统，点击下一步\n\n客户机操作系统选择Linux，版本选择CentOS 8 64位，点击下一步\n\n修改虚拟机名称（建议修改，这样可以知道自己在什么时间创建了这个虚拟机，后续要用是能知道是干什么的），修改位置（建议不要放在C盘），点击下一步\n\n选择处理器数量，用来学习，1个就行，每个处理器的内核数量设置为2，点击下一步\n\n修改虚拟机内存4GB，点击下一步\n\n网络连接设置为NAT，点击下一步\n\n点击下一步\n\n点击下一步\n\n磁盘设置为创建新虚拟磁盘，点击下一步\n\n磁盘大小20GB，点击将虚拟磁盘存储为单个文件，点击下一步\n\n点击下一步\n\n点击自定义硬件，这里需要修改虚拟机硬件\n\n点击下方添加按钮，点击网络适配器，点击完成\n\n可以看到多了一个网络适配器2，点击关闭\n\n最后点击完成\n\n找到刚刚创建好的新虚拟机，点击编辑虚拟机设置，找到CD&#x2F;DVD，点击使用ISO映像文件，找到下载的CentOS 8 的iso文件，点击确定\n\n这样新建虚拟机就完成了。\n2、打开创建好的虚拟机开启此虚拟机，选择Install CentOS Linux 8，回车\n\n选择中文，简体中文，点击继续\n\n点击进入软件选择，找到传统UNIX兼容性、开发工具，勾上，点击完成\n\n点击安装目标位置，选择磁盘，点击完成\n\n点击网络和主机名，修改主机名，点击应用，选择以太网（ens160），打开，点击完成\n\n点击时间和日期，修改地址为上海，点击完成\n\n基本设置完成后点击开始安装\n\n设置root密码，点击完成\n\n创建一个用户，设置密码，点击完成\n\n都完成后等待安装\n\n安装完成后点击重启\n\n授权许可后登录root用户，在未列出里输入root，密码，即可登录\n\n现在这个界面右键选项里没有控制台，需要更改以下设置，点击右上角注销root用户，重新登录root用户时在登录左边的按钮选择经典，然后点击登录\n\n现在右键即可打开控制台\n\n现在在此界面拍摄一次快照，名称改为初始安装，便于日后使用\n\n3、对虚拟机进行配置关闭防火墙首先输入命令查看防火墙\n1systemctl status firewalld.service\n\n\n需要先临时关闭防火墙，再禁用防火墙\n12systemctl stop firewalld.servicesystemctl disable firewalld.service\n\n\n设置SELinux1vim /etc/selinux/config\n\n\n将SELINUX&#x3D;enforcing修改为SELINUX&#x3D;permissive\n\n关闭虚拟网卡查看虚拟网卡状态\n1systemctl status libvirtd.service\n\n\n关闭虚拟网卡\n1systemctl disable libvirtd.service\n\n\n换源1vim /etc/yum.repos.d/CentOS-AppStream.repo\n\n\n注释mirrorlist，取消注释beaseurl，将他的值更换成\n1https://mirrors.aliyun.com/centos-vault/8.5.2111/extras/$basearch/os/\n\n\n同样的方法修改\n12vim /etc/yum.repos.d/CentOS-Base.repovim /etc/yum.repos.d/CentOS-Extras.repo \n\n\n\n清除旧缓存，加载新源数据\n12yum clean all  #删除所有缓存的软件包数据（包括旧的软件包头文件、元数据、下载的软件包等）yum makecache  #从配置的软件仓库（Repository）下载最新的软件包列表、依赖关系等元数据，并存储在本地\n\n\n最后保存快照\n\n","slug":"CentOS-8-环境搭建及配置","date":"2025-07-28T13:51:19.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"},{"id":"d69852fb48fa32246d1e3f9497c9ab8f","title":"Hexo个人博客搭建教程","content":"Hexo个人博客搭建教程一、准备工具1、Typora软件简介Typora 是一款轻便简洁的 Markdown 编辑器，将写作与预览窗口相结合，采用所见即所得的编辑模式，具有实时预览、语法扩展等诸多特色功能。在接下来的个人博客搭建过程中会使用到Markdown文件，建议安装使用Typora。\n安装过程下载地址：https://www.typoraio.cn/\n\n得到下载文件后双击安装，一直Next下一步，选择安装地址，安装完成后打开使用。\n2、Nodejs软件简介Node.js 是一个强大的、基于 JavaScript 和 V8 引擎的运行时环境，利用事件驱动、非阻塞 I&#x2F;O 模型实现了高性能，尤其擅长构建可扩展的网络应用和实时服务，并拥有npm这一巨大的开源生态系统作为后盾。它是现代全栈 JavaScript 开发的基础。\n安装过程下载地址：https://nodejs.org/zh-cn/download\n\n修改安装路径，一直Next下一步即可，建议保留Add to PATH，这样后续就不用在环境变量中配置，可以直接在全局使用Node命令，在控制台命令行输入可以验证安装\n1node -v\n\n1npm -v\n\n\n3、Git软件简介Git 是一个分布式版本控制系统（DVCS），由 Linus Torvalds（Linux 内核创始人）于 2005 年开发。其核心功能是：\n\n追踪文件变更：记录代码、文档的每一次修改\n多人协作：支持多人并行开发同一项目\n灾难恢复：可回溯到任意历史版本\n\n安装过程下载地址：https://git-scm.com/downloads/win\n\n选择合适的版本进行下载，Git官网提供两种类型：\n\nStandalone Installer（独立安装程序）：常规的安装包，会在系统中进行完整安装，写入系统注册表等，将 Git 集成到系统环境，安装后可在命令行等环境直接调用，是最常用的安装方式，比如 “Git for Windows&#x2F;x64 Setup” 这类，适合长期在固定电脑使用 Git 的场景 。\nPortable (“thumbdrive edition”，便携版 &#x2F; 拇指驱动器版)：无需安装，解压或拷贝后即可使用，不写入系统注册表，可放在 U 盘等移动存储设备，在不同电脑即插即用，像 “Git for Windows&#x2F;x64 Portable” ，方便在多台电脑临时使用 Git 且不想在每台电脑都安装的情况 。\n\n下载完成后双击打开文件，选择安装路径，一直Next下一步即可，安装完成会打开一个Git的介绍网页。\n4、Hexo软件简介Hexo 是一个基于 Node.js 的开源静态博客生成器，通过解析 Markdown 文件和模板，生成纯 HTML&#x2F;CSS&#x2F;JS 网站。核心定位：为开发者、写作者提供高效内容发布和极简技术栈维护的解决方案。\n安装过程使用管理员身份打开打开Windows控制台，下载命令：\n1npm install hexo-cli -g     #全局安装\n\n\n安装完成后输入命令去验证：\n1hexo -v\n\n\n二、本地博客部署需要从 GitHub 克隆 Hexo 官方模板仓库，在E盘空白处右键，点击Open Git Bash here（安装完Git就会出现）\n\n弹出如下界面\n\n输入命令\n1hexo init blog\n\n\n会提示 Please run ‘npm install’ in “E:\\blog” folder.\n用管理员身份打开cmd，进入E:\\bolg目录下\n1cd /d E:\\blog\n\n输入命令\n1npm install\n\n安装完成后显示如下界面\n\n\n如果在npm install这一步没有使用管理员打开cmd，而是进入blog文件里面，通过git bash输入npm install，可能会报错\n\n这里错误代码时4048，通过查阅发现可能就是权限不够的问题，因此通过管理员打开控制台再输入npm install就可以。这里只提供笔者遇到的一种错误解决方法，也是在查阅资料后找到的解决方法。\n至此本地博客已经搭建完成。\n1hexo g\n\nhexo g 是 Hexo 静态博客生成器的核心命令，将源代码（Markdown 文章&#x2F;主题&#x2F;配置等）编译成静态网页文件。\n\n1hexo s\n\nhexo s 是 Hexo 静态博客生成器的核心命令，全称为 hexo server。它的主要作用是启动本地服务器用于实时预览博客效果\n\n此时在浏览器输入http://localhost:4000/，可以看到一个简易的个人博客\n\n三、本地博客部署到云服务器在本地博客部署到云服务器之前，需要有一个本地搭建完的博客，一台云服务器，本地安装一个SSH连接工具（或者bash终端）\n1、搭建仓库搭建GitHub存储静态页面的仓库，首先注册&#x2F;登录Github，点击Create repository进入新建仓库页面\n\n仓库名输入：\n1用户名.github.io\n\n勾选 Public ，勾选 Add a README file ，拉到下面点击create创建\n2、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here，输入\n1ssh-keygen -t rsa -C &quot;邮件地址&quot;\n\n\n进入C:\\Users\\用户名，在里面进入.ssh文件，用记事本打开里面的id_rsa.pub,全选复制里面的代码\n\n然后打开 Github ，进入用户设置，找到 SSH keys 新建SSH keys，名称随意，在下面粘贴代码， 然后创建\n\n测试是否成功，在 Git bash 中输入\n1ssh -T git@github.com\n\n笔者在这一步时遇到了错误\n\n这里表示SSH的22端口可能被防火墙或者网络限制了，笔者给出一种方案，输入命令\n1ssh -T -p 443 git@github.com\n\n\n启用通过HTTPS的SSH连接，笔者在这里能够成功连接，在 SSH 配置文件中设置此设置，请在 ~/.ssh/config 编辑该文件（没有可以直接创建一个config文件，无后缀），并添加以下部分\n1234Host github.comHostname ssh.github.comPort 443User git\n\n最后可以通过再次连接到 GitHub.com 测试此项是否有效\n1ssh -T git@github.com\n\n\n笔者在这里就能够成功连接。\n3、上线博客进入之前的blog文件夹，用记事本打开_config.yml 拉到最下面将deploy后面的全删掉，复制粘贴这段\n123type: gitrepository: branch: main\n\n注意冒号后面有一个空格，每行前面有两个空格。\n进入Github之前生成的仓库页面，点击Code，将下方出现的https链接复制下来，粘贴到repositort: 后面，然后保存并退出。\n回到blog文件夹，打开Git bash，安装自动部署发布工具\n1npm install hexo-deployer-git --save\n\n\n\n\n接下来依次输入\n12hexo g（生成静态文件）hexo d（将静态文件上传到github）\n\n\n\n\n\n接下来我们就成功把本地内容上传到Github了，上传成功以后，我们就算搭建好了！上自己的网址看看吧，网址是我们之前设的仓库名：用户名.github.io\n4、发布文章1hexo new “文章名”\n\n 找到文章路径，修改标题、日期、标签（标签前要加一个空格，否则会报错！）\n12hexo ghexo d\n\n四、PicGo的Github配置1、配置Github新建公开仓库\n\n创建私人令牌token\n\n\n\n然后记下token值\n2、下载PicGo下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n图床设置\n\n具体图床参数配置\n\n","slug":"Hexo个人博客搭建教程","date":"2025-07-28T13:41:52.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"}]