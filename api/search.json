[{"id":"bcdac3d434efc7f27225ef4360e8f77f","title":"用户权限","content":"用户权限一、基本权限UGO1.UGO的含义​\tU (User)：文件或目录的所有者（创建者或通过 chown 指定的用户）-属主 \n​\tG (Group)：文件或目录的所属组（通过  chgrp 或  chown 指定的用户组）-属组 \n​\tO (Other)：既不是所有者，也不在所属组中的其他所有用户\n2.权限类型每个角色（U&#x2F;G&#x2F;O）可分配以下三种权限： \n​\tr (read)：读取文件内容，或列出目录中的文件。 \n​\tw (write)：修改文件内容，或在目录中创建&#x2F;删除文件。 \n​\tx (execute)：执行文件（如脚本），或进入目录。\n3. 查看权限使用 ls -l 命令查看文件或目录的权限：\n1ls -l /root\n\n1-rw-r--r-- 1 alice developers 1024 Jan 1 12:34 example.txt\n\n-rw-r–r–：\n​\t第1位：- 表示文件，d 表示目录。 \n​\t第2-4位：User 的权限（ rw- ：可读可写，不可执行）。 \n​\t第5-7位：Group 的权限（ r– ：仅可读）。 \n​\t第8-10位：Other 的权限（ r– ：仅可读）。\n4. 权限的两种表示方式符号表示法（rwx）直接使用 r、w、x 表示权限。\n1rwxr-x---\n\n​\tUser： rwx （读、写、执行） \n​\tGroup： r-x （读、执行） \n​\tOther：— （无权限）\n数字表示法将rwx转换为数字相加：   \n​\tr &#x3D; 4（2²） \n​\tw &#x3D; 2（2¹） \n​\tx &#x3D; 1（2⁰）\n1rwxr-x---          #750\n\n​\tUser： 4+2+1&#x3D;7 \n​\tGroup： 4+0+1&#x3D;5 \n​\tOther： 0+0+0&#x3D;0\n5. 修改权限（ chmod 命令）语法12使用符号：u用户 g组  o其他  r读   w写  x执行语法： chmod   对象(u/g/o/a)赋值符(+/-/=)权限类型(r/w/x) 文件/目录   \n\n符号模式12#给 User 添加执行权限，Group 移除写权限，Other 设置只读chmod u+x,g-w,o=r example.txt\n\n数字模式12# 设置权限为 rw-r-----（User可读可写，Group可读，Other无权限）chmod 640 example.txt\n\n实验1：查看当前目录的权限12345678910111213141516[root@wyf 桌面]# ll /tmp            #无法看到/tmp 目录的权限总用量 16-rw-r--r--. 1 root root 2066 7月  28 19:41 anaconda.log-rw-r--r--. 1 root root 2604 7月  28 19:40 dbus.logdrwxr-xr-x. 2 root root   18 7月  28 19:35 hsperfdata_root-rw-r--r--. 1 root root    0 7月  28 19:40 ifcfg.log-rwx------. 1 root root 1379 7月  28 19:39 ks-script-wk_ixipf-rw-r--r--. 1 root root    0 7月  28 19:40 packaging.logdrwxr-xr-x. 3 root root   35 7月  30 10:59 practice-rw-r--r--. 1 root root  131 7月  28 19:40 program.log-rw-r--r--. 1 root root    0 7月  28 19:40 sensitive-info.logdrwx------. 2 root root   24 8月   1 10:58 ssh-EaDVMIIat0qo-rw-r--r--. 1 root root    0 7月  28 19:40 storage.log[root@wyf 桌面]# ll -d /tmp         #-d 命令查看当前目录drwxrwxrwt. 22 root root 4096 8月   1 10:59 /tmp\n\n实验2：可执行文件1.在&#x2F;tmp目录中创建file.txt，编辑文件写入以下内容123echo &quot;hello zhouwu&quot;read -p &quot;please your name?&quot; nameecho &quot;$name good&quot; \n\n2.为用户添加file.txt的执行权限1chmod u+x /tmp/file.txt\n\n3.观察文件类型\n4.执行文件内容，观察程序运行123456[root@wyf 桌面]# cd /tmp[root@wyf tmp]# ./file.txthello zhouwuplease your name?wyfwyf good[root@wyf tmp]# \n\n5.去除权限，运行失败1234[root@wyf tmp]# chmod u-x /tmp/file.txt[root@wyf tmp]# ./file.txtbash: ./file.txt: 权限不够[root@wyf tmp]# \n\n实验3：为所有用户添加执行权限1chmod +x script.sh  # 所有角色添加执行权限（不推荐）\n\n实验4：目录场景允许其他人查看目录内容，但禁止修改：\n1chmod 755 mydir/  # rwxr-xr-x\n\n​\tUser：可读、写、进入目录。 \n​\tGroup&#x2F;Other：可读、进入目录，但不能创建&#x2F;删除文件。\n实验5：-R选项1.在tmp中创建递归目录dir1，观察新建文件夹的默认权限是多少（755）123[root@wyf tmp]# mkdir dir1[root@wyf tmp]# ll -d dir1/drwxr-xr-x. 2 root root 6 8月   1 11:12 dir1/\n\n2.在dir1目录中创建3个文件111、222、333，观察文件默认权限是多少（644）12345678[root@wyf dir1]# touch 111 222 333[root@wyf dir1]# cd ..[root@wyf tmp]# ll dir1总用量 0-rw-r--r--. 1 root root 0 8月   1 11:13 111-rw-r--r--. 1 root root 0 8月   1 11:13 222-rw-r--r--. 1 root root 0 8月   1 11:13 333[root@wyf tmp]# \n\n3.修改dir1权限为777，观察文件是否变化12345678[root@wyf tmp]# chmod 777 dir1/[root@wyf tmp]# ll -d dir1/drwxrwxrwx. 2 root root 39 8月   1 11:13 dir1/[root@wyf tmp]# ll dir1/总用量 0-rw-r--r--. 1 root root 0 8月   1 11:13 111-rw-r--r--. 1 root root 0 8月   1 11:13 222-rw-r--r--. 1 root root 0 8月   1 11:13 333\n\n4.通过-R递归修改dir1中所有文件权限为70012345678[root@wyf tmp]# chmod -R 700 dir1/[root@wyf tmp]# ll -d dir1/drwx------. 2 root root 39 8月   1 11:13 dir1/[root@wyf tmp]# ll dir1/总用量 0-rwx------. 1 root root 0 8月   1 11:13 111-rwx------. 1 root root 0 8月   1 11:13 222-rwx------. 1 root root 0 8月   1 11:13 333\n\n6.更改属主&#x2F;组改变权限（ chown命令）语法 change owner12chown： 设置一个文件属于谁，属主 语法： chown  用户名.组名  文件\n\n实验1：改属主、属组1.更改file1权限为60012345[root@wyf tmp]# ll file1.txt-rw-r--r--. 1 root root 72 8月   1 11:03 file1.txt[root@wyf tmp]# chmod 600 file1.txt[root@wyf tmp]# ll file1.txt-rw-------. 1 root root 72 8月   1 11:03 file1.txt\n\n2. 切换其他用户尝试访问123[root@wyf tmp]# su - abc[abc@wyf ~]$ cat /tmp/file1.txt cat: /tmp/file1.txt: 权限不够\n\n3. 返回root用户，更改文件属主&#x2F;组12345[abc@wyf ~]$ exit注销[root@wyf tmp]# chown abc.hr file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 abc hr 72 8月   1 11:03 file1.txt\n\n4. 切换abc用户再次尝试访问12345[root@wyf tmp]# su - abc [abc@wyf ~]$ cat /tmp/file1.txt  echo &quot;hello zhouwu&quot; read -p &quot;please your name?&quot; name echo &quot;$name good&quot;\n\n实验2：只改属主12345[root@wyf tmp]# ll file1.txt -rw-------. 1 abc hr 72 8月   1 11:03 file1.txt[root@wyf tmp]# chown user999 file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt\n\n实验3：只改属组12345[root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt[root@wyf tmp]# chown .dev file1.txt [root@wyf tmp]# ll file1.txt -rw-------. 1 user999 dev 72 8月   1 11:03 file1.txt\n\n7. 关键注意事项​\t1.目录的执行权限（x）： \n​\t\t无 x 权限时，即使有 r 权限，也无法 cd 进入目录或读取其中文件列表。 \n​\t2.权限优先级： \n​\t\t系统按 User → Group → Other 的顺序匹配权限，首次匹配成功则生效。 \n​\t3.安全风险： \n​\t\t避免给文件设置  777 （所有用户可读可写可执行），尤其是敏感文件（如  &#x2F;etc&#x2F;passwd ）。\n8. 修改所属组（chgrp）1234# 修改所属组[root@wyf tmp]# chgrp hr file1.txt[root@wyf tmp]# ll file1.txt -rw-------. 1 user999 hr 72 8月   1 11:03 file1.txt\n\n9.综合练习需求：​\t文件file10.txt \n​\t属主是user100，读写执行-7（可以看内容，可以改内容，可以执行） \n​\t属组是jishuzu（user200），读取    -4（只能看，不能改，不能执行） \n​\t其他人         没有权限-0（既不能看，又不能改和执行）\n测试：​\t1.使用user100，访问文件。写入文件，执行文件 \n​\t2.使用jishuzu成员，访问文件，不可写和执行 \n​\t3.使用其他用户user300，访问文件失败。写入失败，执行失败。\n操作：1.创建文件123[root@wyf tmp]# touch file10.txt[root@wyf tmp]# ll file10.txt-rw-r--r--. 1 root root 0 8月   1 20:24 file10.txt\n\n2.创建用户123456789101112131415161718[root@wyf tmp]# useradd user100[root@wyf tmp]# useradd user200[root@wyf tmp]# useradd user300[root@wyf tmp]# passwd user100更改用户 user100 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf tmp]# passwd user200更改用户 user200 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf tmp]# passwd user300更改用户 user300 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。\n\n3.创建组12[root@wyf tmp]# groupadd jishuzu[root@wyf tmp]# usermod -aG jishuzu user200\n\n4.授予文件属主&#x2F;组，以及其他人的权限12345678[root@wyf tmp]# chmod 740 file10.txt[root@wyf tmp]# ll file10.txt -rwxr-----. 1 root root 0 8月   1 20:24 file10.txt[root@wyf tmp]# chown user100.jishuzu file10.txt[root@wyf tmp]# ll file10.txt -rwxr-----. 1 user100 jishuzu 0 8月   1 20:24 file10.txt[root@wyf tmp]# id user200uid=1002(user200) gid=1002(user200) 组=1002(user200),1004(jishuzu)\n\n5.测试user100,是否拥有rwx权限12345678910[user100@wyf tmp]$ cat file10.txtecho 123456[user100@wyf tmp]$ vim file10.txt[user100@wyf tmp]$ cat file10.txtecho 123456echo 456789[user100@wyf tmp]$ ./file10.txt 123456456789[user100@wyf tmp]$ \n\n6.测试user20012345678910[user100@wyf tmp]$ su - user200密码：[user200@wyf ~]$ cd /tmp[user200@wyf tmp]$ cat file10.txtecho 123456echo 456789[user200@wyf tmp]$ vim file10.txt[user200@wyf tmp]$ ./file10.txt-bash: ./file10.txt: 权限不够[user200@wyf tmp]$ \n\n\n7.测试user30012345678[user200@wyf tmp]$ su - user300密码：[user300@wyf ~]$ cd /tmp[user300@wyf tmp]$ cat file10.txtcat: file10.txt: 权限不够[user300@wyf tmp]$ vim file10.txt[user300@wyf tmp]$ ./file10.txt-bash: ./file10.txt: 权限不够\n\n\n二、基本权限ACL1、ACL 与 UGO 的区别1. UGO 权限的局限性​\t仅支持三个对象：用户（User）、组（Group）、其他人（Other）。 \n​\t无法精细化控制：无法为同一文件设置多个独立用户的差异化权限。\n2. ACL 的优势​\t多对象支持：可为同一文件设置多个用户&#x2F;组的独立权限。 \n​\t精细化控制：支持 r（读）、w（写）、x（执行）的灵活组合。\n2、ACL 核心命令语法1. 设置权限： setfacl1setfacl -m &lt;用户/组&gt;:&lt;名称&gt;:&lt;权限&gt; &lt;文件/目录&gt;\n\n参数解析：\n​\t-m ：修改权限（-x 删除，-b 清空所有 ACL）。 \n​\t&lt;用户&#x2F;组&gt;：u（用户）、g（组）、o（其他人）。 \n​\t&lt;名称&gt;：用户名或组名（留空表示默认属主&#x2F;组）。 \n​\t&lt;权限&gt;：r&#x2F;w&#x2F;x（可组合，如 rw ）。\n123456# 为用户 alice 设置读写权限  setfacl -m u:alice:rw /home/test.txt  # 为组 hr 设置只读权限  setfacl -m g:hr:r /home/test.txt  # 禁止用户 jack 访问  setfacl -m u:jack:- /home/test.txt\n\n3、ACL 权限设置与验证1. 创建测试文件123[root@wyf ~]# touch /home/test.txt[root@wyf ~]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n2. 设置 ACL 权限设置用户user01拥有读写权限，设置hr组只读权限\n12[root@wyf ~]# setfacl -m u:user01:rw /home/test.txt[root@wyf ~]# setfacl -m g:hr:r /home/test.txt \n\n3. 查看 ACL 权限： getfacl1234567891011[root@wyf ~]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwuser:user01:rwgroup::r--group:hr:r--mask::rwother::r--\n\n字段解析： \n​\tuser::rw- ：属主权限。 \n​\tuser:user01:rw- ：用户 user01的 ACL 权限。 \n​\tmask::rw- ：实际生效权限（与用户权限取交集）\n4、权限删除与恢复1. 删除单条 ACL123456789101112# 删除组 hr 的 ACL 权限  [root@wyf tmp]# setfacl -x g:hr /home/test.txt [root@wyf tmp]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwuser:user01:rwgroup::r--mask::rwother::r--\n\n2. 清空所有 ACL12345678910[root@wyf tmp]# setfacl -b /home/test.txt [root@wyf tmp]# getfacl /home/test.txt getfacl: Removing leading &#x27;/&#x27; from absolute path names# file: home/test.txt# owner: root# group: rootuser::rwgroup::r--other::r--[root@wyf tmp]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n3. 恢复默认权限123# 重置为 UGO 权限（需提前备份）  [root@wyf tmp]# chmod 644 /home/test.txt[root@wyf tmp]# ll /home/test.txt -rw-r--r--. 1 root root 0 8月   1 20:59 /home/test.txt\n\n5、高级特性与注意事项1. 递归设置目录权限12# 递归设置目录及子文件  setfacl -R -m u:alice:rwx /data/  \n\n2. 注意事项​\t权限优先级：ACL &gt; UGO（若冲突，以 ACL 为准）。 \n​\t备份与恢复：\n1234# 备份  getfacl -R /path &gt; acl_backup.txt  # 恢复  setfacl --restore=acl_backup.txt \n\n总结​\tACL 核心价值：解决 UGO 无法多用户精细化授权的问题，适用于团队协作场景。 \n​\t最佳实践：优先使用 UGO 满足基础需求，复杂场景再通过 ACL 补充。 \n​\t命令速查： \n​\t\t设置权限： setfacl -m \n​\t\t查看权限： getfacl \n​\t\t删除权限： setfacl -x 或 -b\n三、特殊权限1、特殊权限位1.SUID（safe uid）作用：suid针对文件&#x2F;程序时，具备临时获得属主的权限。 \n通过实验理解特殊权限位\n实验1：通过SUID临时提权实验目的：让普通用户通过SUID临时获得root权限，查看受保护文件  \n前置条件：\n​\t使用root账号创建测试文件 &#x2F;root&#x2F;file1.txt \n​\t创建普通用户  alice \n​\t编辑 file1.txt \n123456[root@wyf ~]# touch /root/file1.txt[root@wyf ~]# useradd alice[root@wyf ~]# vim /root/file1.txt[root@wyf ~]# cat /root/file1.txt echo 1111111111[root@wyf ~]# ll /root/file1.txt -rw-r--r--. 1 root root 0 8月   1 21:18 /root/file1.txt\n\n​\t切换用户 alice ,尝试访问&#x2F;root&#x2F;file1.txt\n123[root@wyf ~]# su - alice[alice@wyf ~]$ cat /root/file1.txtcat: /root/file1.txt: 权限不够\n\n​\t改变文件属主，再次尝试访问，依旧不行\n1234[root@wyf ~]# chown alice /root/file1.txt[root@wyf ~]# su - alice[alice@wyf ~]$ cat /root/file1.txtcat: /root/file1.txt: 权限不够\n\n实验步骤： \n步骤1：查看默认权限\n12[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat\n\n步骤2：为 cat 命令添加SUID权限\n123456[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat[root@wyf tmp]# chmod u+s /usr/bin/cat[root@wyf tmp]# ll /usr/bin/cat-rwsr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/cat# 权限位出现&#x27;s&#x27;表示SUID生效\n\n步骤3：普通用户尝试访问受保护文件\n123[root@wyf tmp]# su - user01[user01@wyf ~]$ cat /root/file1.txtdddd\n\n步骤4：移除SUID权限（实验后必做！）\n12345[user01@wyf ~]$ exit注销[root@wyf tmp]# chmod u-s /usr/bin/cat[root@wyf tmp]# ll /usr/bin/cat-rwxr-xr-x. 1 root root 51856 5月  12 2019 /usr/bin/ca\n\n思考：\n​\t为什么设置SUID后普通用户能读取root文件？  \n​\t答案：SUID使程序运行时继承属主（root）权限，而非用户自身权限。 \n​\t观察命令passwd的权限，为什么不一样 \n​\t答案：因为所有用户都有要修改自己密码的权力 \n​\t观察文件 &#x2F;etc&#x2F;shadow的权限，为什么不一样 \n​\t答案：因为密码不允许任何人随意修改\n2、文件属性chattr作用：常用于锁定某个文件，拒绝修改。\n\n\n\n属性\n作用\n典型场景\n风险提示\n\n\n\n+i\n不可修改&#x2F;删除(Immutable)\n保护系统关键文件（如：/etc/passwd, /sbin/init）\n误启用导致系统更新失败\n\n\n+a\n仅追加(Append-Only)\n日志文件防篡改（如：/var/log/secure）\n需配合syslog权限控制\n\n\n+A\n禁用atime更新\n减少磁盘I&#x2F;O（SSD优化场景）\n影响文件访问跟踪\n\n\n+e\nExtents格式(ext4专属)\n优化大文件存储效率\n不可逆操作\n\n\n+C\n禁用Copy-on-Write(CoW)\n容器镜像层优化（OverlayFS环境）\n影响数据一致性\n\n\n+s\n安全删除(Secure Erase)\nGDPR合规数据销毁\n磁盘性能下降30%+\n\n\n+m\n压缩加密(2025新增)\nZstd透明压缩\n需内核6.3+支持\n\n\n实验2：通过chattr锁定文件 \n​\t实验目的：使用 chattr 防止文件被修改&#x2F;删除  \n实验步骤： \n​\t步骤1：创建测试文件并查看默认属性\n123[root@wyf tmp]# touch file100[root@wyf tmp]# lsattr file100-------------------- file100\n\n​\t步骤2：添加不可删除属性i\n123[root@wyf tmp]# chattr +i file100[root@wyf tmp]# lsattr file100----i--------------- file100\n\n​\t步骤3：尝试删除文件（失败）\n12[root@wyf tmp]# rm -rf file100rm: 无法删除&#x27;file100&#x27;: 不允许的操作\n\n​\t步骤4：恢复文件属性\n1234[root@wyf tmp]# chattr -i file100[root@wyf tmp]# lsattr file100-------------------- file100# 验证&#x27;i&#x27;属性移除\n\n​\t扩展属性： \n​\t\ta 属性：允许追加内容但禁止修改（适用于日志文件）\n1[root@localhost ~]# chattr +a file200  # 追加内容可用`echo &quot;text&quot; &gt;&gt; file200`\n\n3、进程掩码umask实验3：修改umask控制默认权限 \n实验目的：理解umask如何影响新建文件&#x2F;目录的默认权限  \n实验步骤： \n​\t步骤1：查看当前umask值\n12[root@localhost ~]# umask0022  # 默认掩码为0022\n\n​\t步骤2：创建文件&#x2F;目录观察默认权限\n12345[root@wyf ~]# touch file800[root@wyf ~]# mkdir dir800[root@wyf ~]# ll file800 dir800 -ddrwxr-xr-x. 2 root root 6 8月   1 21:36 dir800          # 文件权限644（666-022）-rw-r--r--. 1 root root 0 8月   1 21:36 file800         # 目录权限755（777-022）\n\n​\t步骤3：临时修改umask为000（开放全部权限）\n123456[root@localhost ~]# umask 000[root@localhost ~]# touch file900[root@localhost ~]# mkdir dir900[root@localhost ~]# ll file900 dir900 -d-rw-rw-rw-. 1 root root 0 8月   1 21:38 file900          # 文件权限666drwxrwxrwx. 2 root root 6 8月   1 21:38 dir900        # 目录权限777\n\n​\t步骤4：恢复umask为默认值\n1[root@localhost ~]# umask 0022\n\n计算公式： \n​\t文件默认权限 &#x3D;  666 - umask \n​\t目录默认权限 &#x3D;  777 - umask\n4、安全注意事项​\t1.SUID风险：滥用SUID可能导致权限提升漏洞，生产环境慎用！ \n​\t2.chattr优先级：i&#x2F;a属性对root同样有效，需通过移除属性恢复操作。\n​\t3.umask持久化：临时修改仅对当前会话有效，永久修改需编辑&#x2F;etc&#x2F;profile 或用户shell配置文件。\n四、课后练习​\t1.为 &#x2F;usr&#x2F;bin&#x2F;vim 设置SUID，观察普通用户能否编辑\n12chmod u+s /usr/bin/vimchmod u-s /usr/bin/vim\n\n​\t2.使用 &#x2F;etc&#x2F;shadow 。 chattr +a保护日志文件，测试追加与覆盖写入的区别。 \n12touch /var/log/test.logchattr +a /var/log/test.log  # 启用只追加模式\n\n​\t3.计算umask为 007 时，新建文件和目录的默认权限。\n\n\n\n类型\n基础权限\numask 007\n结果权限\n解释\n\n\n\n文件\n666\n007\n660\nrw-rw----（属主和属组可读写）\n\n\n目录\n777\n007\n770\nrwxrwx---（属主和属组可读写执行）\n\n\n","slug":"用户权限","date":"2025-08-01T02:10:46.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"8253069df3e619a90109a077baa63a85","title":"提权","content":"提权永久提权：Switching users with su1、基础语法su （Switch User）是 Linux&#x2F;Unix 系统中用于切换用户身份的核心命令，常用于临时获取目标用户的权 限（尤其是  root 用户）。\n1su [选项] [用户名]   \n\n常用选项：\n\n或 -l：模拟完整登录（加载目标用户的环境变量）。\n-c “命令”：以目标用户身份执行单条命令后退出。\n-s ：指定 Shell（如 -s &#x2F;bin&#x2F;bash ）。\n\n2、示例123su - root        # 完整登录，加载 root 环境变量（推荐）su root          # 仅切换用户身份，环境变量不变su -             # 等效于 su - root\n\n12su - alice       # 切换到 alice 用户（需 alice 的密码）su alice         # 仅切换身份，不加载环境变量\n\n1su - user01 -c &quot;whoami&quot;   #执行单条命令退出\n\n\n3、安全注意事项​\t密码暴露风险： \n​\t\troot 的 home 目录 su 需要输入目标用户的密码，若多人共用 root 密码，难以审计操作来源。  \n​\t\t推荐替代方案：使用  sudo 实现权限最小化和操作审计。 \n​\t禁用 root 登录：  在安全要求高的场景，可通过以下方式禁用 root 的  su 切换：\n123# 编辑 /etc/pam.d/suauth required pam_wheel.so use_uid# 仅允许 wheel 组成员使用 su\n\n4、实际应用场景12#系统维护su - root -c &quot;apt upgrade &amp;&amp; apt autoremove&quot;  # 以 root 身份更新系统\n\n12#多用户协作su - alice   # 切换到开发人员 alice 的账户调试环境\n\n12345#脚本中临时提权#!/bin/bash# 以 root 身份创建目录su - root -c &quot;mkdir /opt/custom_app&quot;chown user:user /opt/custom_app\n\n5、总结\n临时提权：Running commands as root with sudo1、基础语法sudo （Super User Do）是 Linux&#x2F;Unix 系统中用于临时以特权身份（如  root ）执行命令的核心工 具，相比 su 更安全且支持细粒度权限控制。以下是其核心概念、配置及实际应用指南。\n无需共享密码：验证当前用户密码，而非目标用户（如  root ）密码。\n最小权限原则：可限制用户仅能执行特定命令。 \n操作审计：所有  sudo 操作记录在  &#x2F;var&#x2F;log&#x2F;auth.log 或  &#x2F;var&#x2F;log&#x2F;secure 。 \n超时机制：默认 15 分钟内无需重复输入密码（可配置）。\n1sudo [选项] 命令\n\n常用选项：\n​\t-u 用户：以指定用户身份执行（默认 root ）\t\n​\t-i ：模拟完整登录（加载目标用户环境变量）。\n​\t-s ：启动目标用户的 Shell。\n​\t-l ：列出当前用户允许执行的命令。\n2、工作流程1.权限检查： 系统读取  &#x2F;etc&#x2F;sudoers 文件，验证用户是否有权执行该命令。 \n2.密码验证： 输入当前用户密码（若未配置  NOPASSWD ）。 \n3.命令执行： 以目标用户身份执行命令，完成后权限自动回收。\n3、配置文件  &#x2F;etc&#x2F;sudoers1visudo  # 安全编辑方式\n\n1用户/组  主机=(可切换身份)  可执行的命令 [参数]\n\n字段说明： \n​\t用户&#x2F;组：% 开头表示组（如  %admin ）。 \n​\t主机：ALL 表示所有主机。 \n​\t可切换身份：ALL 表示任意用户，可指定为(root) 。\n​\t命令：需使用绝对路径（如 &#x2F;usr&#x2F;bin&#x2F;apt ）。\n123456# 允许 wheel 组成员以 root 身份执行所有命令%wheel  ALL=(ALL)  ALL# 允许用户 alice 无需密码重启 Apachealice   ALL=(root)  NOPASSWD: /usr/bin/systemctl restart httpd# 允许用户 bob 在特定主机上管理用户bob     host01=(root) /usr/sbin/useradd, /usr/sbin/userdel\n\n4、 实际应用场景1.普通用户执行特权命令1234# 更新软件包列表sudo apt update# 查看系统日志（需 root 权限）sudo tail -f /var/log/syslog\n\n2. 以其他用户身份执行命令1\n\n3.进入特权 Shell 环境1\n\n\n\n4.查看用户权限1\n\n\n\n5、安全最佳实践1.最小权限原则：避免赋予 ALL 权限，按需授权特定命令。 \n示例：仅允许用户管理服务： \n12user1  ALL=(root) /usr/bin/systemctl restart nginx, /usr/bin/systemctl  status nginx \n\n2.禁用密码（谨慎使用）：12#允许用户无需密码执行命令 user2  ALL=(root)  NOPASSWD: /usr/bin/apt update\n\n3.日志监控：检查  &#x2F;var&#x2F;log&#x2F;auth.log 或   &#x2F;var&#x2F;log&#x2F;secure，追踪可疑操作。\n4.超时配置： 修改默认超时时间（单位：分钟）： \n1Defaults timestamp_timeout=5  # 5 分钟后需重新输入密码\n\n5.禁用 root 登录：结合sudo 使用，增强安全性：  \n12# 禁用 root SSH 登录（/etc/ssh/sshd_config） PermitRootLogin no\n\n6、高级用法限制命令参数12# 允许 user5 仅能添加用户（禁止删除），防止命令注入攻击user5  ALL=(root)  /usr/sbin/useradd [A-Za-z]*\n\n12345678rm -rf /             #删库跑路wget / curl          #下载并执行恶意脚本nc 1.2.3.4 4444      #反向shellfind / -exec rm -rf  #结合 -exec执行恶意操作   echo                 #覆盖系统环境变量tar                  #压缩覆盖系统文件chmodcat\n\n7、实验练习使一个新用户user777具有删除test用户的权限方法一：将新用户加入wheel组\n12useradd user777      #创建用户 usermod -aG wheel user777   #将user777放入wheel组中\n\n方法二：编辑&#x2F;etc&#x2F;sudoers  添加特权\n12visudouser777 ALL=(ALL:ALL) ALL\n\n","slug":"提权","date":"2025-07-31T12:58:59.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"a2f5984a703b9b38689c64c1a82d51c5","title":"VIM-编辑器与用户管理","content":"VIM-编辑器与用户管理VIM编辑器1、Vim简介与模式Vim是一个高效文本编辑器，核心在于模式切换： \n普通模式（Normal Mode）：移动光标、执行命令（启动时默认模式）。 \n插入模式（Insert Mode）：输入&#x2F;编辑文本。 \n命令行模式（Command-line Mode）：保存、退出、搜索等操作。\n2、启动与退出启动Vim：终端输入 vim 文件名（文件不存在则新建）。 \n退出Vim： 普通模式下按 : 进入命令行模式。 \n​\t\t:q 退出（未修改时）。 \n​\t\t:q! 强制退出（不保存修改）。 \n​\t\t:wq 保存并退出。\n3、模式切换普通模式 → 插入模式： \n​\t\ti：光标前插入。 \n​\t\ta：光标后插入。 \n​\t\to：下一行插入。 \n插入模式 → 普通模式： \n​\t\t按 Esc 或 Ctrl+[ 。\n4、 基础移动（普通模式）方向键：h（左）、j（下）、k（上）、l（右）。 \n单词移动： \n​\t\tw：跳到下一个单词开头。 \n​\t\tb：跳到上一个单词开头。 \n行内移动： \n​\t\t0：行首，^：第一个非空字符。 \n​\t\t$：行尾。 \n全文移动： \n​\t\tgg：文件开头。 \n​\t\tG：文件末尾。 \n​\t\t50G：跳转到第50行。\n5、编辑文本删除： \n​\t\tx：删除光标处字符。 \n​\t\tdw：删除一个单词。 \n​\t\tdd：删除整行。 \n撤销与重做： \n​\t\tu：撤销操作。 \n​\t\tCtrl + r：重做撤销的操作。 \n复制与粘贴： \n​\t\tyy：复制当前行。 \n​\t\tp：粘贴到光标后。\n​\t\tP：粘贴到光标前。\n6、查找与替换查找： \n​\t\t普通模式下按 &#x2F;，输入关键词后回车（如 &#x2F;hello）。 \n​\t\tn 跳转到下一个匹配，N 上一个。 \n替换： \n​\t\t替换当前行第一个匹配：:s&#x2F;old&#x2F;new \n​\t\t替换当前行所有匹配：:s&#x2F;old&#x2F;new&#x2F;g \n​\t\t全文替换：:%s&#x2F;old&#x2F;new&#x2F;g（加 c 确认每次替换，如 :%s&#x2F;old&#x2F;new&#x2F;gc）。\n7、可视模式（Visual Mode）v：进入字符选择模式（按字符选择）。 \nV：进入行选择模式（按行选择）。 \nCtrl + v：进入块选择模式（垂直选择）。 \n操作：选中后按 y 复制，d 删除，p 粘贴。\n8、 配置Vim（.vimrc）创建配置文件：\n1vim ~/.vimrc\n\n常用配置示例：\n1234set number        # 显示行号syntax on         # 语法高亮set tabstop=4     # Tab缩进4空格set expandtab     # 用空格代替Tab\n\n9、VIM基础操作练习初始文件准备1vim file.txt  # 创建并打开文件\n\n文件初始内容（手动输入）12345applebananaorangegrapepear\n\n分步练习任务（1）打开文件并进入插入模式，在末尾添加一行 pineapple1234vim file.txtG               # 跳转到文件末尾i               # 进入插入模式（输入pineapple后按ESC）\n\n（2）复制第2行（banana）并粘贴到第4行下方12342G               # 跳转到第2行yy               # 复制当前行4G               # 跳转到第4行p                # 粘贴\n\n（3）删除第3行（orange）123G                # 跳转到第3行dd                # 删除当前行\n\n（4）显示行号并跳转到第5行（原pear行）12:set nu           # 显示行号5G                # 跳转到第5行\n\n（5）将光标移动到行首，插入 watermelon1230      # 跳转到行首i      # 进入插入模式（输入watermelon后按ESC）\n\n（6）查找所有 apple 并替换为 mango （仅替换前2行）1:1,2s/apple/mango/g  # 直接指定行号范围替换\n\n（7）撤销最后一次替换操作1u      # 撤销操作\n\n（8）强制退出不保存（模拟误操作）1:q!    # 强制退出\n\n（9）重新打开文件并另存为 backup.txt12vim file.txt  # 重新打开:w backup.txt # 另存为备份\n\n（10）保存并退出1:wq    # 保存退出\n\n文件类型1、核心命令： ls -l1ls -l [文件名/目录名]\n\n输出示例：\n\n2、详细拆解：\n总用量 12表示当前目录所有文件占用的磁盘块总数​（单位为1K块）。12表示这些文件共占用约12KB磁盘空间。\n文件权限信息-rw-r--r--. 分为四个部分：\n-：文件类型（-&#x3D;普通文件，d&#x3D;目录）\nrw-：所有者权限（可读写，不可执行）\nr--：所属组权限（只读）\nr--：其他用户权限（只读）\n.：SELinux安全上下文标记\n\n\n链接数和归属1 root root 表示：\n1：硬链接计数（此文件只有一个文件名指向它）\nroot：文件所有者\nroot：文件所属用户组\n\n\n文件大小\n31：backup.txt 和 file.txt 都是 31字节\n772：practice.txt 是 772字节\n\n\n修改时间7月 30 20:21 表示最后修改时间：\nbackup.txt 和 file.txt：7月30日晚上8点21分\npractice.txt：7月30日上午10点17分\n\n\n文件名\nbackup.txt\nfile.txt\npractice.txt\n\n\n\n3、文件类型符号说明（第一列第一个字符）\n4、操作演示1. 查看普通文件类型1ls -l /etc/passwd     # 输出示例：-rw-r--r--. 1 root root 2504 7月  28 19:38 /etc/passwd\n\n\n2. 查看目录文件类型1ls -ld /var/log       # 注意加-d参数查看目录本身 # 输出示例：drwxr-xr-x. 16 root root 4096 7月  31 11:15 /var/log\n\n\n3. 查看设备文件类型1ls -l /dev/sda        # 输出示例：brw-rw---- 1 root disk 8, 0 Aug 1 08:00 sda\n\n5、综合练习练习1：类型判断123ls -l /bin/ls ls -l /home ls -l /dev/tty\n\n1.指出每个文件的类型符号\n2.说明对应的文件类型 \n3.验证文件实际类型是否符号显示\n\n- 表示的文件类型是：常规文件 (Regular file)，这种类型包含：普通文本文件，可执行二进制文件（如此处的 /bin/ls），图片、视频等媒体文件，压缩包、文档等数据文件。\n\n输出显示 ELF 格式，表明是 Linux 平台的二进制可执行文件。\n\nd 表示的文件类型是：目录 (Directory)​，这是Linux中存储其他文件&#x2F;子目录的容器。常见于用户主目录、系统配置目录等（如此处的 wyf 用户目录）。\n\n明确显示为目录类型。\n\nc 表示的文件类型是：​字符设备文件 (Character device file)​​，提供无缓冲的、面向字符的I&#x2F;O操作（逐字节处理），通常用于流式设备，如终端、串口等，与块设备（如硬盘）的主要区别是数据访问方式。\n\nfile 命令输出确认其为字符特殊文件（character special）。\n用户管理1、用户&#x2F;组的基本概念用户的基本概念\n本质：访问系统资源的独立身份标识\n作用：\n登录系统\n运行进程（每个进程都有属主）\n控制文件&#x2F;目录的读写权限\n\n\n\n组的基本概念\n本质：用户的集合，用于批量管理权限\n作用：\n简化权限分配（如允许某组共同编辑文件）\n控制资源共享（如打印机、目录）\n\n\n\n2、用户的作用查看当前登录的用户\n12[root@wyf 桌面]# iduid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n\nunconfined_u：用户域未受限用户 \nunconfined_r：未受限角色 \nunconfined_t：未受限类型 \ns0-s0:c0.c1023：安全级别，最高到最低\n查看文件的owner\n123[root@wyf 桌面]# ls -l /home总用量 0drwx------. 3 wyf wyf 78 7月  28 19:38 wyf\n\n 3：硬链接个数\ncd . \tcd .. \n基础概念：\n​\t每个目录至少包含 2个硬链接： \n​\t\t目录自身的链接（通过名称访问，如 wyf） \n​\t\t子目录中的 . 条目（指向自身） \n​\t每增加一个直接子目录，计数+1（因为子目录的 .. 会指向它）\n查看运行进程的username：\n12345678910111213[root@wyf 桌面]# ps auxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot          1  0.0  0.3 179188 13792 ?        Ss   10:50   0:02 /usr/lib/systemroot          2  0.0  0.0      0     0 ?        S    10:50   0:00 [kthreadd]root          3  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [rcu_gp]root          4  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [rcu_par_gp]root          6  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [kworker/0:0H-kroot          8  0.0  0.0      0     0 ?        I&lt;   10:50   0:00 [mm_percpu_wq]root          9  0.0  0.0      0     0 ?        S    10:50   0:00 [ksoftirqd/0]root         10  0.0  0.0      0     0 ?        I    10:50   0:00 [rcu_sched]root         11  0.0  0.0      0     0 ?        S    10:50   0:00 [migration/0]root         12  0.0  0.0      0     0 ?        S    10:50   0:00 [watchdog/0]root         13  0.0  0.0      0     0 ?        S    10:50   0:00 [cpuhp/0]\n\nPID：进程id \n%CPU：CPU使用率 \n%MEM：内存使用百分比 \nVSZ：虚拟内存 \nRSS：常驻内存 \nTTY：关联的终端设备 \nSTAT：进程状态码 \nSTART：进程的启动时间 \nTIME：累计cpu使用时间 \nCOMMAND：进程对应的命令\n3、用户组存储的信息用户基本信息文件 &#x2F;etc&#x2F;passwd12345678[root@wyf 桌面]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n\n\n\n\n字段位置\n字段值\n含义解析\n\n\n\n1\nroot\n用户名 - 超级管理员账户的登录名\n\n\n2\nx\n密码标记 - 表示加密密码存储在 /etc/shadow 文件（增强安全性）\n\n\n3\n0\n用户ID（UID） - 0 表示超级用户权限（最高权限账户）\n\n\n4\n0\n组ID（GID） - 0 表示主组是 root 组（系统管理员组）\n\n\n5\nroot\n用户描述 - 账户的说明信息（可以是全名、备注等）\n\n\n6\n/root\n家目录 - 用户专属目录，存放个人文件和配置（root用户家目录在&#x2F;root）\n\n\n7\n/bin/bash\n登录Shell - 用户登录后默认的命令行解释器（Bash Shell）\n\n\n1.用户名 \n​\t登录系统的名字（如 root ）。\n2.密码占位符：\n​\t实际密码存储在  &#x2F;etc&#x2F;shadow ，此处为 x。 \n3.UID（用户身份证号）\n​\t系统约定（RHEL7）： \n​\t\t0 ：特权用户（root） \n​\t\t1~999 ：系统用户 \n​\t\t1000+ ：普通用户 \n​\tRoot 用户特性： \n​\t\tuid 为 0，拥有最高权限。 \n​\t\t可覆盖文件系统权限、管理软件和系统文件。 \n​\t\t控制大多数硬件设备。 \n4.GID（组号）  \n​\t默认规则： \n​\t\t每创建一个用户，系统会自动创建同名组。 \n5.描述\n​\t用户描述信息（如职位、部门），默认与用户名一致。 \n6.家目录（HOME） \n​\t用户登录后的默认目录（如  &#x2F;root ）。 \n7.登录 Shell  \n​\t用户的命令解释器（如  &#x2F;bin&#x2F;bash ）。 \n​\t若设置为  &#x2F;sbin&#x2F;nologin ，用户无法登录系统。\n用户密码信息文件  &#x2F;etc&#x2F;shadow12[root@wyf 桌面]# cat /etc/shadowroot:$6$.BrPz6ym6rOpU8t/$WQt1myKX0d.y2nvKSO.q8NBbZUR6Y6BrRRC5.MVSNm10G.pjSs.oMVdbKw2UznmJ115j/nJ.o3/289jx1UZBm/::0:99999:7:::\n\n\n\n\n字段位置\n字段值示例\n含义解析\n\n\n\n1\nroot\n用户名 - 账户标识\n\n\n2\n$6$...ZBm/\n加密密码 - 存储密码的哈希值（详解见下）\n\n\n3\n空\n最后修改密码日期 - 空值表示需要首次登录设置密码\n\n\n4\n0\n最小密码年龄 - 0 表示随时可修改\n\n\n5\n99999\n最大密码年龄 - 密码有效期 99999 天≈273年（永不过期)\n\n\n6\n7\n过期前警告期 - 密码到期前 7 天提醒\n\n\n7\n空\n密码宽限期 - 过期后立即失效（无宽限）\n\n\n8\n空\n账户过期时间 - 空值表示账户永不过期\n\n\n9\n空\n保留字段 - 未使用\n\n\n\n用户名 (root)账户的登录名。\n\n加密密码 ($6$...)\n\n格式：$id$salt$encrypted\n\n分解：\n\n$6$：表示使用 SHA-512加密算法（Linux最安全的默认算法）\n\n\n\n符号\n算法\n\n\n\n$1$\nMD5（已淘汰）\n\n\n$5$\nSHA-256\n\n\n$6$\nSHA-512\n\n\n\n$.BrPz6ym6rOpU8t/：盐值（Salt），用于增加密码破解难度\n\n$WQt1myKX0d...：加密后的密码哈希值\n\n\n\n\n\n上次更改密码日期\n\n空字段：通常表示密码按特殊规则管理（如通过passwd -d root清除密码后，此处为空）\n正常情况为数字：表示从1970年1月1日（UNIX纪元）到更改日的天数（如 19122）\n\n\n最小使用天数 (0)\n\n密码更改后必须经过该天数才允许再次更改\n0 → 允许立即更改密码（默认安全配置）\n\n\n最大使用天数 (99999)\n\n密码过期前的最大使用天数\n99999 ≈ 273年 → 表示密码永不过期（生产环境建议设为90或180天）\n\n\n警告天数 (7)\n\n密码到期前 7 天开始向用户发送警告（登录时提示）\n\n\n密码宽限期\n\n空 → 密码过期后立即锁定账户\n若设为数字（如 5）→ 过期后仍允许使用5天\n\n\n账户过期日期\n\n空 → 账户永不过期\n若设为数字 → 表示从1970年1月1日起的账户过期天数\n\n\n保留字段留作未来扩展使用。\n\n\n注意事项：\n​\t密码字段为空：用户无需密码即可登录（高风险，不推荐）。 \n​\t锁定账号：在密码字段前添加 * 或 !!。 \n​\t时间计算基准：不同系统可能以不同时间为起点（如 SCOLinux 使用 1970年1月1日）。\n组信息文件  &#x2F;etc&#x2F;group123456[root@wyf 桌面]# cat /etc/grouproot:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:\n\n\n\n\n字段位置\n字段值\n含义解析\n\n\n\n1\nroot\n组名 - 系统管理员组\n\n\n2\nx\n密码占位符 - 表示密码存储在 /etc/gshadow 文件\n\n\n3\n0\n组ID (GID) - 0 表示管理员组（系统最高权限组）\n\n\n4\n空\n组成员列表 - 没有直接列出成员\n\n\n4、用户管理1.用户创建1.1 默认创建（自动生成同名基本组）123[root@wyf 桌面]# useradd user01[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)\n\n说明： \n​\t用户编号（UID）：唯一用户标识（如  1001 ）。 \n​\t组编号（GID）：同名基本组的标识（如  1001 ）。 \n​\t规则：未指定选项时，系统自动创建同名组作为用户的主组（Primary Group）。\n1.2 指定选项创建12[root@localhost ~]# useradd user02 -u 1503                          # 指定 UID[root@localhost ~]# useradd user03 -d /user03 /home/user03          # 指定家目录\n\n2.用户删除1[root@localhost ~]# userdel -r user02  # 彻底删除用户及家目录\n\n注意事项：\n​\t-r 选项会删除用户家目录和邮箱文件（ &#x2F;var&#x2F;spool&#x2F;mail ）。 \n​\t未加 -r 会导致残留文件，可能影响后续创建同名用户。\n​\t有进程在使用需要先结束进程\n12kill -9 uid               #结束进程pkill -9 -u user01\n\n删除用户时没有加 -r 的补救方式\n123456789101、pkill -9 -u user01            #强制关闭进程2、sudo rm -rf /home/user01      # 删除家目录sudo rm -f /var/mail/user01     # 删除邮件池（如果有）3、#列出所有属于user01的文件，并删除，需要2&gt;/dev/null用于忽略权限错误find / -user user01 -exec rm -rf &#123;&#125; \\; 2&gt;/dev/null4、#删除配置文件信息vipw    \t#/etc/passwdvigr    \t#/etc/groupvipw -s\t\t#/etc/shadowvisudo  \t# 安全编辑方式\n\n3.用户密码管理1[root@localhost ~]# passwd alice  # 输入两次新密码\n\n1[wyf@localhost ~]# passwd  # 需输入原密码\n\n4.用户属性修改1[root@localhost ~]# usermod -s /sbin/nologin user02  # 禁用用户登录\n\n5.组成员管理将用户追加到附加组\n1234567# 语法usermod -aG 组名 用户名# 示例[root@localhost ~]# usermod -aG hr user02# 验证[root@localhost ~]# id user02uid=1002(user02) gid=1002(user02) 组=1002(user02),1005(hr)\n\n从组中移除用户\n1234# 语法gpasswd -d 用户名 组名# 示例[root@localhost ~]# gpasswd -d user02 hr\n\n5、用户组管理1.组基础操作创建组\n1234567# 默认创建[root@localhost ~]# groupadd hr# 指定 GID[root@localhost ~]# groupadd net01 -g 1007# 验证[root@localhost ~]# grep &#x27;net01&#x27; /etc/groupnet01:x:1007:\n\n删除组\n1[root@localhost ~]# groupdel net01\n\n2.组分类1.基本组​\t\t随用户自动创建的同名组（如  user01 组）。 用户文件默认属组为基本组。 \n2.附加组​\t\t用户手动加入的其他组（如 hr 组）。 用于扩展权限管理。\n3.组成员管理示例1.创建共享目录123mkdir /sharedchgrp hr /shared  # 设置属组为hrchmod 770 /shared  # 赋予组读写执行权限\n\n2. 验证权限12su - user02touch /shared/test.txt  # 成功则权限生效\n\n注意事项1.修改 UID&#x2F;GID 前备份：1bash find / -user 旧UID -exec chown 新UID &#123;&#125; \\;  # 修复文件属主 \n\n2.组权限生效条件：用户需重新登录或使用  newgrp 命令。 \n3.删除用户必用 -r：避免残留文件导致后续操作失败。\n6、实验练习实验目标1.掌握用户和组的创建、删除及属性修改。 \n2.理解用户配置文件（ &#x2F;etc&#x2F;passwd 、 &#x2F;etc&#x2F;shadow 、 &#x2F;etc&#x2F;group ）的结构。\n3.学会设置用户密码、组成员权限及共享目录访问控制。\n1、创建用户与验证基本信息1.默认创建用户user01：12345[root@wyf 桌面]# useradd user01[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)[root@wyf 桌面]# tail -n 1 /etc/passwduser01:x:1001:1001::/home/user01:/bin/bash\n\n2.指定选项创建用户：创建用户 user02 ，指定 UID 为  bash 1503 ：\n123[root@wyf 桌面]# useradd user02 -u 1503[root@wyf 桌面]# id user02uid=1503(user02) gid=1503(user02) 组=1503(user02)\n\n创建用户  user03 ，指定家目录为  &#x2F;user03 ：\n123[root@wyf 桌面]# useradd user03 -d /user03[root@wyf 桌面]# ls -ld /user03drwx------. 3 user03 user03 78 7月  31 20:38 /user03\n\n2、用户密码管理1.Root 为用户  user01 设置密码：12345678[root@wyf 桌面]# passwd user01更改用户 user01 的密码 。新的 密码：无效的密码： 密码少于 8 个字符重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@wyf 桌面]# grep user01 /etc/shadowuser01:$6$o/lquzz3Zgu/OMKF$Qm2qNpEVDi25hQ45x73nw1ewXWVOTZPo.h88HzPkWPMHNrOWLbTpRKG.nnT9OdsTQH0Y4gcVSe8eiMnp9NtX3.:20300:0:99999:7:::\n\n2.用户  user01 自行修改密码：123456789[user01@wyf ~]# passwd更改用户 user01 的密码 。Current password: 新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[user01@wyf ~]# exit注销[root@wyf 桌面]# \n\n3、修改用户属性1. 禁用用户  user02 的登录 Shell：1234[root@wyf 桌面]# usermod -s /sbin/nologin user02[root@wyf 桌面]# grep user02 /etc/passwduser02:x:1503:1503::/home/user02:/sbin/nologin[root@wyf 桌面]# \n\n2.尝试登录  user02 （应失败）：123[root@wyf 桌面]# su - user02This account is currently not available.[root@wyf 桌面]# \n\n4、用户组管理1.创建组  hr 和 dev：123456[root@wyf 桌面]# groupadd hr[root@wyf 桌面]# groupadd dev -g 2000[root@wyf 桌面]# tail -n 2 /etc/grouphr:x:1505:dev:x:2000:[root@wyf 桌面]# \n\n2.将用户加入附加组：123456[root@wyf 桌面]# usermod -aG hr user01[root@wyf 桌面]# usermod -aG dev user02[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01),1505(hr)[root@wyf 桌面]# id user02uid=1503(user02) gid=1503(user02) 组=1503(user02),2000(dev)\n\n3.从组中移除用户：1234[root@wyf 桌面]# gpasswd -d user01 hr正在将用户“user01”从“hr”组中删除[root@wyf 桌面]# id user01uid=1001(user01) gid=1001(user01) 组=1001(user01)\n\n5、共享目录权限验证1. 创建共享目录并设置权限：12345[root@wyf 桌面]# mkdir /shared[root@wyf 桌面]# chgrp dev /shared[root@wyf 桌面]# chmod 770 /shared[root@wyf 桌面]# ls -ld /shareddrwxrwx---. 2 root dev 6 7月  31 20:51 /shared\n\n2.验证组成员权限：用户 user02 （属于 dev 组）：\n12345[root@wyf 桌面]# su - user02[user02@wyf ~]# touch /shared/test.txt[user02@wyf ~]# exit注销[root@wyf 桌面]# \n\n用户 user01 （不在  dev 组）：\n123456[root@wyf 桌面]# su - user01[user01@wyf ~]# touch /shared/test.txttouch: 无法创建 &#x27;/shared/test.txt&#x27;: 权限不够[user01@wyf ~]# exit注销[root@wyf 桌面]# \n\n6、清理实验环境1.删除用户及其家目录123userdel -r user01userdel -r user02userdel -r user03\n\n2.删除组12groupdel hrgroupdel dev\n\n3.删除共享目录1rm -rf /shared\n\n7、实验总结核心知识点  \n1.用户管理：​\tuseradd 、 usermod 、 userdel 命令的使用。 \n​\t用户密码策略通过  &#x2F;etc&#x2F;shadow 控制。 \n​\t禁用登录 Shell 可限制用户访问。 \n2.组管理：​\tgroupadd 、 groupdel 、 gpasswd 命令的使用。 \n​\t基本组（自动创建）与附加组（手动加入）的区别。 \n​\t通过组权限实现共享目录的访问控制。 \n3.权限验证：​\t使用 id 查看用户组关系。 \n​\t通过 ch grp 和  chmod 设置目录权限。\n","slug":"VIM-编辑器与用户管理","date":"2025-07-30T11:03:12.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"7e1e754a6541fda39aaf072fd6373097","title":"Linux文件管理与查询","content":"Linux文件管理与查询一、grep命令基础语法1grep [选项] &quot;搜索模式&quot; 文件或目录\n\n常用选项\n正则表达式1. 基础语法\n. (点)：匹配任意单个字符\n1grep &quot;a.c&quot; file.txt  # 匹配 &quot;abc&quot;, &quot;aac&quot;, &quot;a1c&quot; 等\n\n*：匹配前一个字符0次或多次\n1grep &quot;ab*c&quot; file.txt  # 匹配 &quot;ac&quot;, &quot;abc&quot;, &quot;abbc&quot; 等\n\n[]：匹配括号内的任意字符\n12grep &quot;[aeiou]&quot; file.txt   # 匹配任意元音字母grep &quot;[0-9]&quot; file.txt     # 匹配任意数字\n\n[^]：匹配不属于括号内指定字符集的单个字符\n1grep &quot;[^0-9]&quot; file.txt     # 匹配非数字字符\n\n2. 位置锚定\n^：匹配行首\n1grep &quot;^start&quot; file.txt  # 匹配以 &quot;start&quot; 开头的行\n\n$：匹配行尾\n1grep &quot;end$&quot; file.txt  # 匹配以 &quot;end&quot; 结尾的行\n\n3. 扩展正则表达式（需 -E）使用 grep -E 或 egrep 启用高级语法：\n\n+：匹配前一个字符至少1次\n1grep -E &quot;a+&quot; file.txt  # 匹配 &quot;a&quot;, &quot;aa&quot;（等价于 aa*）\n\n?：匹配前一个字符0或1次\n1grep -E &quot;colou?r&quot; file.txt  # 匹配 &quot;color&quot; 或 &quot;colour&quot;\n\n|：或匹配\n1grep -E &quot;cat|dog&quot; file.txt  # 匹配 &quot;cat&quot; 或 &quot;dog&quot;\n\n()：分组\n1grep -E &quot;(abc)&#123;2&#125;&quot; file.txt  # 匹配 &quot;abcabc&quot;\n\n&#123;&#125;：用于 精确控制前一个字符&#x2F;模式的重复次数\n\n&#123;n&#125;：精确重复 n 次\n&#123;n,&#125;：重复至少 n 次\n&#123;n,m&#125;：重复 n 到 m 次\n\n1grep -E &quot;go&#123;3,5&#125;gle&quot; file.txt  # 匹配 &quot;gooogle&quot; 和 &quot;goooogle&quot;，但不匹配 &quot;google&quot;\n\n使用 grep 时，可以通过 正则表达式（Regular Expressions） 实现高效文本匹配。以下是常见用法和示例：\n4. 字符类\n\\w：字母、数字、下划线（等价于 [a-zA-Z0-9_]）\n\\d：数字（等价于 [0-9]）\n\\s：空白字符（空格、制表符等）\n\n实验练习准备：创建practice.txt文件，在桌面上打开终端\n1vim practice.txt\n\n在vim编辑器里将下面内容复制进去，保存后退出，在桌面上得到一个practice.txt文件\n\n实验练习：实验 1.1：查找错误日志1grep &quot;ERROR&quot; practice.txt                #输出所有包含 &quot;ERROR&quot; 的行\n\n\n实验 1.2：忽略大小写匹配12grep -i &quot;error&quot; practice.txt             #匹配 &quot;error&quot;（不区分大小写）grep -i &quot;warning&quot; practice.txt           #匹配 &quot;WARNING&quot;（不区分大小写）\n\n\n实验 1.3：反向排除调试信息1grep -v &quot;WARNING&quot; practice.txt            #排除包含 &quot;WARNING&quot; 的行\n\n\n实验 2.1：显示匹配行号1grep -n &quot;ERROR&quot; practice.txt              #输出行号，如 `2:...[ERROR]...`\n\n\n实验 2.2：统计错误次数1grep -c &quot;ERROR&quot; practice.txt              #输出错误行数（示例结果：3）\n\n\n实验 3.1：查看错误上下文12grep -C 1 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 1 行grep -C 2 &quot;ERROR&quot; practice.txt            #显示每个 &quot;ERROR&quot; 行及其前后各 2 行\n\n\n\n实验 4.1：匹配时间范围12grep &quot;2023-10-01 08:1.&quot; practice.txt          #匹配 08:10 以后的行grep &quot;^2023-10-01 08:1&quot; practice.txt          #匹配行首为2023-10-01 08:1 的行\n\n\n\n实验 4.2：提取 IP 地址1grep -Eo &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt    #输出所有 IP 地址，如 192.168.1.100\n\n\n1grep -E &quot;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; practice.txt     #输出含有 IP 地址的行，如 192.168.1.100\n\n\n实验 4.3：精确匹配警告1grep -w &quot;WARNING&quot; practice.txt             #精确匹配&quot;WARNING&quot;\n\n\n实验 5.1：提取邮箱地址12grep -Eio &quot;\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt     #输出邮箱地址grep -Eio &quot;\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]&#123;2,&#125;\\b&quot; practice.txt\n\n\n实验 5.2：查找金额记录1grep &#x27;\\$&#x27; practice.txt\n\n\n实验 6.1：扩展练习（目录递归）1234# 创建目录结构mkdir -p /tmp/practice/logs/cp practice.txt /tmp/practice/logs/echo &quot;ERROR: File not found&quot; &gt; /tmp/practice/error.log\n\n\n12# 递归搜索所有 &quot;ERROR&quot;grep -r &quot;ERROR&quot; /tmp/practice/\n\n\n12# 排除 .log 文件 --exclude=&quot;*.log&quot; 排除所有 .log grep -r --exclude=&quot;*.log&quot; &quot;INFO&quot; /tmp/practice/\n\n\n二、find命令基础语法1find [搜索路径] [匹配条件] [执行动作]\n\n常用匹配条件按名称或路径匹配\n按文件类型匹配\n按文件大小匹配\n按时间戳匹配\n按权限匹配\n逻辑操作符\n执行动作\n实验练习准备创建练习目录结构\n12345mkdir -p ~/find-practice/&#123;logs,data,backup&#125;touch ~/find-practice/logs/&#123;app.log,error.log&#125;touch ~/find-practice/data/&#123;file1.txt,file2.csv,image.jpg&#125;mkdir ~/find-practice/backup/oldtouch ~/find-practice/backup/old/archive.tar.gz\n\n实验练习实验 1.1：按名称搜索文件1find ~/find-practice/ -name &quot;*.log&quot;            #输出所有 .log 文件的路径\n\n\n实验 1.2：按类型搜索目录1find ~/find-practice -type d                   #列出所有子目录\n\n\n实验 1.3：组合条件（名称与大小）1find ~/find-practice -name &quot;*.jpg&quot; -size -10k  #查找小于 10KB 的 .jpg 文件\n\n\n实验 2.1：查找最近修改的文件1find ~/find-practice -mtime -1          # 列出 1 天内修改过的文件\n\n\n实验 2.2：排除特定权限文件1find ~/find-practice ! -perm 644     # 查找权限不是 644 的文件\n\n\n\n\n\n需求\n权限\n字母表示\n\n\n\n私有文件\n600\n-rw-------\n\n\n标准共享\n644\n-rw-r--r--\n\n\n组内共享\n664\n-rw-rw-r--\n\n\n可执行文件\n755\n-rwxr-xr-x\n\n\n共享目录\n775\ndrwxrwxr-x\n\n\n实验 3.1：删除空文件1find ~/find-practice -size 0 -delete     # 删除所有空文件\n\n\n实验 3.2：批量修改权限1find ~/find-practice -name &quot;*.sh&quot; -exec &#123;&#125; chmod &#123;&#125; 755 \\;             # 将所有 .sh 文件设为可执行\n\n实验 3.3：搜索并压缩文件12touch ~/find-practice/logs/&#123;app.log,error.log&#125;find ~/find-practice -name &quot;*.log&quot; -exec tar -cvsf logs.tar.gz &#123;&#125; +   # 将 .log 文件打包为 logs.tar.gz\n\n\ntar命令\n\n\n\n选项\n作用\n常见用法\n\n\n\n-c\n创建新归档文件\n必选（创建模式）\n\n\n-v\n显示详细过程（verbose）\n可选（显示打包文件列表）\n\n\n-s\n已废弃 原始排序（obsolete sort）\n现代 tar 已忽略此选项\n\n\n-f\n指定归档文件名\n必选（后接文件名）\n\n\n实验 4.1：忽略特定目录1find ~/find-practice -path &quot;*/backup&quot; -prune -o -name &quot;*.txt&quot; -print  # 查找所有 .txt 文件，但跳过 backup 目录\n\n提前创建了一个111.txt\n\n实验 4.2：结合  xargs 处理文件xargs 是 Linux&#x2F;Unix 系统中一个极其强大的命令行工具，用于构建和执行命令行参数。它弥补了管道(|)只能传递标准输出的不足，将输入数据转换为命令参数。\n1[命令产生输入] | xargs [选项] [目标命令]\n\n\n\n\n选项\n作用\n示例\n\n\n\n-I &#123;&#125;\n自定义占位符\n&#96;ls\n\n\n-n N\n每组N个参数\n&#96;seq 10\n\n\n-P N\n并发进程数\n&#96;find .\n\n\n-t\n打印执行命令\n&#96;echo “f”\n\n\n-p\n交互式确认\n&#96;ls\n\n\n-0\n处理特殊字符\n&#96;find -print0\n\n\n-d\n自定义分隔符\n&#96;echo “a,b,c”\n\n\n1find ~/find-practice -name &quot;*.csv&quot; | xargs -I &#123;&#125; mv &#123;&#125; ~/find-practice/data    #移动所有 .csv 文件到 data 目录\n\n常用场景\n案例学习1、找出系统中名为 passwd的文件1find / -name passwd -type f\n\n\n2、找出&#x2F;tmp目录中文件名带nz的文件，然后删除由于&#x2F;tmp目录下没有带nz的文件，所以先创建几个文件\n\n1find /tmp -name &quot;*nz*&quot; -type f -exec rm -fr &#x27;&#123;&#125;&#x27; \\;\n\n\n","slug":"Linux文件管理与查询","date":"2025-07-30T02:11:06.000Z","categories_index":"","tags_index":"Linux","author_index":"wyf"},{"id":"144f0b4d9b9f80ea377106e9c6a54a45","title":"Linux基础","content":"Linux基础内容一、计算机基础1、信息表示\n比特： 信息的基本单位（0 或 1）。\n二进制系统： 计算机内部所有信息（数字、文本、图像、声音、视频、指令）都用二进制数（0 和 1 的组合）表示。\n编码： 信息转换为二进制的过程（如 ASCII, Unicode 编码字符， JPEG 编码图像， MP3 编码声音）。\n\n2、冯·诺依曼体系结构（现代计算机的基石）\n核心思想： 存储程序概念。\n五大部件：\n输入设备： 接收外部数据&#x2F;指令（键盘、鼠标、麦克风、摄像头、传感器）。\n输出设备： 向外界呈现结果（显示器、打印机、扬声器）。\n运算器： 执行算术运算和逻辑运算。\n控制器： 协调指挥各部件的运作，取指令、解码指令、执行指令。\n存储器：\n内存： 速度快、容量较小、易失性（断电数据丢失）。存放当前运行的程序和数据（RAM：Random Access Memory）。\n外存： 速度慢、容量大、非易失性（断电数据保留）。长期存储程序和数据（硬盘、固态硬盘SSD、U盘、光盘）。\n\n\n\n\n\n3、硬件：计算机的物理组成部分。\n中央处理器： 计算机的“大脑”，包含运算器和控制器。核心指标：主频、核心数、缓存大小。\n内存： 供 CPU 直接访问的高速工作区 (RAM)。\n主板： 连接所有部件的“骨架”，包含各种接口、芯片组、总线等。\n存储设备： 硬盘驱动器、固态硬盘、U 盘等。\n输入设备： 如上述。\n输出设备： 如上述。\n扩展卡： 显卡、声卡、网卡等。\n电源： 提供稳定电力。\n\n4、软件：计算机运行的指令&#x2F;程序集合。硬件是躯体，软件是灵魂。\n系统软件：\n操作系统： 管理硬件资源、提供用户&#x2F;应用程序接口、是软硬件沟通的桥梁（如：Windows, macOS, Linux, Android, iOS）。核心功能：进程管理、内存管理、文件管理、设备管理、用户界面。\n驱动程序： 使操作系统能与特定硬件设备通信的软件。\n实用工具： 辅助管理计算机的工具（如：磁盘清理、杀毒软件）。\n\n\n应用软件： 为用户完成特定任务的程序（如：浏览器、办公软件、游戏、媒体播放器、图像处理软件）。\n\n5、数据与程序\n数据： 计算机处理的原始材料（未经处理的信息）。\n程序： 一系列指令的集合，告诉计算机如何处理数据。\n指令： 计算机执行的最小操作单位（如：加、减、移动数据）。\n\n6、CPU的架构​\t\t前面说过的，CPU其实内部已经含有一些微指令，我们所使用的软件都要经过CPU内部 的微指令集来达成才行。 那这些指令集的设计主要又被分为两种设计理念，这就是目前世界 上常见到的两种主要CPU架 构，分别是：精简指令集（RISC）与复杂指令集（CISC）系统。\n\n\n\n特征\n精简指令集 (RISC)\n复杂指令集 (CISC)\n\n\n\n设计目标\n简化指令以提高单周期执行效率\n减少程序代码量，贴近高级语言操作\n\n\n指令复杂度\n简单：指令长度固定，功能单一（如LOAD/STORE）\n复杂：支持多功能指令（如单条指令实现字符串处理）\n\n\n指令长度\n固定（通常32位）\n可变（1至15字节不等）\n\n\n寄存器数量\n多（数十至数百个），减少内存访问\n较少，依赖内存操作\n\n\n执行方式\n单周期指令为主，流水线深度优化\n复杂指令需多周期执行（微程序控制）\n\n\n代码密度\n较低（相同功能需更多指令）\n较高（单条指令完成复杂任务）\n\n\n典型架构\nARM（手机&#x2F;嵌入式）、RISC-V、MIPS、PowerPC\nx86（Intel&#x2F;AMD桌面&#x2F;服务器）、z&#x2F;Architecture（IBM大型机）\n\n\n编译器作用\n关键：负责指令调度和效率优化\n简化编译（复杂指令直接映射高级操作）\n\n\n\n选择精简指令集（RISC）的场景：追求高能效比（手机&#x2F;物联网）、定制化需求（RISC-V开源生态）。\n选择复杂指令集 (CISC)的场景：兼容历史代码（x86生态）、高代码密度（存储成本敏感型系统）。\n未来方向：两者在设计上持续趋同，效率、功耗、灵活性的平衡成为关键。\n\n7、操作系统定义：操作系统是管理计算机硬件与软件资源的系统软件，扮演中介者角色：直接控制CPU、内存、磁盘、网络等硬件；为应用程序（如浏览器、游戏）提供运行环境和服务。​本质​：​资源的超级管家​（硬件资源 + 软件协调）。\n（1）进程管理（Process Management）\n进程：运行中的程序实例（需CPU、内存等资源）。\n核心任务：\n创建&#x2F;销毁进程\n进程调度：分配CPU时间片（算法如：先来先服务FCFS、轮转调度RR、优先级调度）\n进程同步：解决并发冲突（如信号量、互斥锁）\n进程通信：进程间数据交换（IPC机制）\n\n\n\n（2）内存管理（Memory Management）\n核心任务：\n分配&#x2F;回收内存：为进程动态分配空间（如堆、栈）。\n虚拟内存：将硬盘空间虚拟为内存，解决物理内存不足（通过分页&#x2F;分段技术）。\n内存保护：防止进程越权访问内存（如MMU硬件支持）。\n\n\n\n（3）文件系统管理（File System Management）\n文件：存储在磁盘上的数据逻辑单元（文本、图片等）。\n核心任务：\n组织文件：目录树结构（如Windows的C:\\、Linux的&#x2F;）。\n读写控制：提供open&#x2F;read&#x2F;write等API。\n磁盘空间管理：分配块、碎片整理（如NTFS、EXT4文件系统）。\n\n\n\n（4）设备管理（I&#x2F;O Device Management）**\n核心任务：\n设备驱动：为打印机、键盘等硬件提供统一接口。\n缓冲区管理：优化慢速设备与CPU的速率差异（如磁盘缓存）。\n即插即用：动态识别设备（如USB热插拔）。\n\n\n\n（5）安全与权限管理（Security &amp; Protection）**\n用户认证：登录密码、生物识别。\n访问控制：文件权限（如Linux的rwx权限位）。\n防火墙与加密：防止外部攻击（如Windows Defender）。\n\n\n\n\n模块\n作用\n\n\n\n内核（Kernel）\n核心代码，直接操作硬件（进程调度、中断处理、内存映射）。\n\n\n系统调用接口\n应用程序访问内核服务的接口（如Linux的syscall、Windows的API）。\n\n\n用户界面\n用户与系统交互的入口（GUI图形界面如Windows桌面 &#x2F; CLI命令行如Linux终端）。\n\n\n系统工具\n内置实用程序（任务管理器、磁盘清理、网络配置工具）。\n\n\n驱动程序\n硬件厂商提供的设备控制软件（如NVIDIA显卡驱动）。\n\n\n8、内核Kernel内核（Kernel） 是操作系统的最核心组件，直接运行在硬件之上，负责管理系统最底层的资源和关键功能。它如同计算机的“中枢神经系统”，是所有软硬件交互的必经之路。\n内核的核心职责\n硬件抽象与管理\n直接操作 CPU、内存、磁盘、网络设备 等物理硬件。\n为上层软件提供统一的资源访问接口（如内存分配、磁盘读写），隐藏硬件差异。\n\n\n进程调度\n决定哪个进程使用 CPU、何时使用、使用多久。\n通过调度算法（如 CFS（Linux完全公平调度器））平衡效率与公平性。\n\n\n内存管理\n分配&#x2F;回收物理内存和虚拟内存空间。\n实现 虚拟内存机制（通过分页&#x2F;分段技术将硬盘空间扩展为“虚拟RAM”）。\n\n\n中断与异常处理\n响应硬件中断（如键盘按下、网络数据到达）和软件异常（如除零错误）。\n每秒处理数万次中断（如系统时钟中断频率通常为 100–1000 Hz）。\n\n\n系统调用接口（Syscall）\n提供应用程序访问内核功能的唯一通道（如文件操作 open()、进程创建 fork()）。\n用户程序无法直接操作硬件，必须通过内核“代办”。\n\n\n设备驱动管理\n集成设备驱动程序（如显卡、声卡驱动），协调硬件与软件的通信。\n\n\n\n内核工作流程示例：启动程序\n用户双击应用图标 → Shell调用 exec() 系统调用。\n内核切换到内核态：\n分配内存空间 → 装载程序代码 → 创建新进程 → 调度CPU执行。\n\n\n程序运行时调用 printf() → 触发 write() 系统调用 → 内核将数据发送到终端。\n程序结束 → 内核回收内存，更新进程状态。\n\n例如：想要在电脑上播放音乐：\n1、内核让播放器占用CPU\n2、声卡驱动让数字信号变成电信号\n9、文件系统文件系统（File System） 是操作系统用来组织、存储和管理数据的核心机制。它定义了数据如何被命名、存储、检索及更新，将硬盘的原始存储空间转化为用户和程序可理解的逻辑结构（文件与目录）。\n核心功能\n命名与组织\n文件：存储数据的逻辑单元（文本、图片等），通过文件名（如 report.txt）标识。\n目录（文件夹）：分层结构（如 /home/user/docs/），实现文件分类管理。\n路径：定位文件的唯一标识（如 Linux 的 /etc/config，Windows 的 C:\\Program Files）。\n\n\n数据存储与寻址\n块（Block）：物理存储的最小单位（通常 4KB）。\n文件分割：大文件被拆分为多个块，分散存储在磁盘不同位置。\n元数据（Metadata）：记录文件属性（名称、大小、创建时间、权限、存储位置等）。\n例如：Linux 的 inode 存储元数据，但不包含文件名（文件名在目录中记录）。\n\n\n\n\n空间管理\n分配策略：标记已用&#x2F;空闲块（位图法、链表法）。\n碎片处理：\n外部碎片：空闲块分散 → 碎片整理（Defragmentation）合并连续空间。\n内部碎片：块未充分利用（如 1KB 文件占用 4KB 块）。\n\n\n\n\n数据可靠性与恢复\n日志（Journaling）：记录操作意图（如 ext4 的日志），崩溃后恢复一致性。\n冗余备份：RAID、副本机制（如 ZFS 的 Copy-on-Write）。\n\n\n\n主流文件系统对比\n\n\nFAT32\nU盘、老式设备\n跨平台（Win&#x2F;macOS&#x2F;Linux通用）\n单文件≤4GB，无日志、易碎片化\n\n\n\nNTFS\nWindows 主磁盘\n支持大文件（16EB）、ACL权限控制\nmacOS&#x2F;Linux 写入需额外驱动\n\n\nexFAT\n闪存设备（SD卡）\n轻量级、大文件支持（64ZB）\n无日志、数据恢复能力弱\n\n\next4\nLinux 主系统\n日志可靠、支持64位存储（1EB）\nWindows 不原生支持\n\n\nAPFS\nmacOS&#x2F;iOS\n针对SSD优化（写时复制）、加密强\n不兼容传统机械硬盘\n\n\nZFS\n企业级存储\n自愈校验、实时压缩、快照克隆\n内存占用高、复杂度大\n\n\n例如：在保存一个文件时：\n1、文件系统决定把它存放在哪 \n2、下次打开的时候，能够快速找到\n10、用户界面UI用户界面（User Interface, UI） 是人与计算机系统之间进行信息交换的媒介，是用户感知并操作数字世界的“窗口”。其核心目标是通过直观的交互方式降低技术使用门槛，让用户高效、无痛地达成目标。\nUI的核心作用​\t1、信息展示\n\n将计算机处理的数据转化为人类可理解的视觉&#x2F;听觉&#x2F;触觉反馈（如文字、图标、声音提示）。\n\n​\t2、操作入口\n\n提供用户向系统发送指令的途径（点击按钮、语音命令、手势等）。\n\n​\t3、降低认知负荷\n\n通过符合直觉的设计减少用户学习成本（如回收站图标表示删除文件恢复）。\n\nUI的三大类型1.命令行界面（CLI - Command Line Interface）\n\n形式：用户输入文本指令（如 rm -rf file.txt）。\n场景：服务器运维、开发者调试（Linux终端、Windows CMD）。\n优点：高灵活性、可脚本化批量操作。\n缺点：需记忆命令语法，对新手极不友好。示例：黑客电影中快速滚动的黑色终端窗口即CLI。\n\n2.图形用户界面（GUI - Graphical User Interface）\n\n形式：视觉化元素（窗口、图标、菜单、按钮）。\n交互方式：鼠标点击、键盘快捷键、触控手势。\n场景：桌面操作系统（Windows&#x2F;macOS）、手机APP、网页。\n关键组件：\nWIMP范式：窗口（Window）、图标（Icon）、菜单（Menu）、指针（Pointer）。\n控件库：按钮、输入框、滑块、复选框等。\n\n\n优点：直观易学，适合大众用户。示例：Windows桌面就是GUI的典型，拖动文件&#x3D;用户向系统发出移动数据指令。\n\n3. 自然用户界面（NUI - Natural User Interface）\n\n形式：模仿人类自然行为（语音、手势、眼神）。\n技术依赖：\n语音识别：Siri&#x2F;小爱同学唤醒智能家居\n计算机视觉：手势控制（如微软Kinect）、面部解锁\n触觉反馈：AR&#x2F;VR设备震动模拟触感\n\n\n场景：智能汽车控制、AR游戏（如Pokémon GO）、无障碍交互。\n演进方向：脑机接口（Neuralink）、全息交互（Meta元宇宙）。\n\n11、网络基础\n定义： 多台计算机或设备通过通信链路（有线或无线）连接起来，实现资源共享和信息交换。\n互联网： 全球最大的计算机网络。\n主要概念：\n协议： 设备通信的规则（如：TCP&#x2F;IP - 互联网的基础协议）。\nIP地址： 网络中设备的唯一标识符。\n域名系统： 将便于记忆的域名翻译成 IP 地址。\n万维网： 建立在互联网上的信息服务系统（网页、超链接等）。\n网络类型： 局域网、城域网、广域网。\n关键设备： 路由器、交换机、调制解调器。\n\n\n\n12、工作原理\n用户通过输入设备输入指令或数据。\n数据&#x2F;指令被送入内存。\nCPU 的控制单元从内存中取出指令进行解码。\nCPU 的运算器根据指令要求，从内存中取出数据进行运算。\n运算结果送回内存暂存或送到输出设备。\n结果通过输出设备呈现给用户或存储到外存设备。\n\n场景：在电脑上通过浏览器看视频，操作系统如何工作？\n1、打开浏览器 UI告诉内核，用户要打开浏览器\n2、内核分配内存以及CPU\n3、访问网络 网络驱动控制网卡下载视频\n4、观看视频 内核会同时处理视频解码、声音\n5、关闭浏览器，释放内存\n13、计算机科学与信息技术\n计算机科学： 侧重于计算理论、算法、编程语言、计算机体系结构、操作系统、人工智能等基础研究。\n信息技术： 侧重于应用计算机系统和网络解决实际问题，如系统管理、网络管理、数据库管理、软件开发（偏应用）、技术支持等。\n\n14、计算机的应用领域\n科学研究、工程设计与制造、通信与媒体、教育与学习、医疗保健、金融交易与服务、企业管理（ERP&#x2F;CRM）、人工智能（智能助手、自动驾驶）、娱乐（游戏、影视）、政府公共服务等。\n\n二、Linux是什么？Linux 是一种自由、开源、类 Unix 的操作系统内核，同时也是基于该内核构建的一整套操作系统和软件生态系统的统称。简单来说，Linux 是一个强大、稳定且高度可定制的计算机系统基础。\n1、核心是 Linux 内核：\n由芬兰程序员林纳斯·托瓦兹在 1991 年作为个人项目开始开发。\n它是最核心的部分，负责管理计算机的硬件资源（CPU、内存、磁盘、网络、外设等），并为软件（应用程序）提供运行的基础服务和接口。\n内核是操作系统的心脏，调度任务，管理文件系统，处理输入输出等。\n\n2、完整的操作系统 - Linux 发行版：\n单独的内核本身对普通用户来说无法直接使用。一个完整的、用户友好的操作系统需要包含：\n内核\n系统工具（如命令行 Shell bash）\n软件包管理系统（用于安装、更新和卸载软件）\n基本的库\n用户界面（图形用户界面 GUI 或命令行界面 CLI）\n各种应用程序（浏览器、办公软件、媒体播放器等）\n\n\n这就是 Linux 发行版的概念。不同的组织、公司或社区会将 Linux 内核、各种自由&#x2F;开源软件以及他们自己开发的管理工具打包在一起，形成可直接安装使用的操作系统，称为 发行版。\n常见的著名发行版：\nUbuntu： 用户友好，非常适合桌面用户和个人开发者入门。\nDebian： 非常稳定，Ubuntu 等许多发行版的基础。\nFedora： 由 Red Hat 支持，通常采用较新的技术。\nCentOS Stream &#x2F; Rocky Linux &#x2F; AlmaLinux： 企业级稳定性和长期支持的典范（尤其面向服务器）。\nopenSUSE： 以强大的配置工具和稳定性著称。\nArch Linux： 轻量、高度可定制，适合经验丰富的用户。\nLinux Mint： 基于 Ubuntu，对桌面用户极其友好，尤其是从 Windows 转过来的用户。\nKali Linux： 专注于网络安全测试和渗透测试。\n\n\n\n3、核心特性：\n开源与自由：\n开源： Linux 内核和构成发行版的大部分软件的源代码都是完全公开、可自由查看、修改的。这带来了巨大的透明度、安全性和协作创新的可能。\n自由： 用户拥有自由运行、学习、修改和重新分发软件（包括修改后的版本）的权利。这得益于其采用的许可证，主要是 GNU GPL。\n\n\n类 Unix： Linux 在设计哲学和接口上借鉴了成熟的 Unix 操作系统（如 POSIX 标准），使其具有强大的命令行工具、稳定性、多用户&#x2F;多任务能力以及高度可组合性（小工具组合完成复杂任务）。\n稳定性与可靠性： Linux 以其在服务器和高负载环境下的稳定性著称，通常可以持续运行数月甚至数年而无需重启。\n安全性： 得益于开源特性（漏洞更容易被发现和修复）、强大的权限系统设计以及活跃的社区响应，Linux 通常被认为比某些专有操作系统更安全。\n高可定制性： 用户可以从轻量级的纯命令行系统到功能丰富的桌面环境进行选择。几乎每个组件都可以被替换或调整以满足特定需求。\n免费： 绝大多数 Linux 发行版可以免费下载、安装和使用。商业支持通常面向企业级服务。\n广泛的硬件支持： 内核内置支持大量硬件，尤其是在服务器、嵌入式设备和超级计算机上。主流桌面硬件（尤其是较新的）支持也非常好。\n强大的社区支持： 拥有全球范围内庞大而活跃的用户和开发者社区，提供丰富的文档、教程、论坛和互助渠道。\n\n4、GPLv2Linux 内核采用 GNU General Public License version 2 (GPLv2) 作为其开源许可协议。理解 GPL 对理解 Linux 的核心运作理念至关重要：\nGPL 的核心宗旨（Copyleft 原则）1.保证自由：GPL 的根本目标是确保软件及其衍生作品始终保持自由。它授予用户四项核心自由：\n\n自由 0： 运行程序的自由，无论任何目的。\n自由 1： 学习和修改程序源代码的自由（获取源码是前提）。\n自由 2： 重新分发软件的自由，帮助他人。\n自由 3： 将修改后的版本分发给其他人的自由（这要求同时提供修改后的源代码，让社区受益）。\n\n2.“传感染”特性 (Copyleft)： 这是 GPL 最显著的特点。\n\n如果你分发基于 GPL 许可软件（如 Linux 内核）的修改版本或包含它的程序，整个分发也必须遵循 GPLv2。\n你必须向程序的接收者提供完整的、可修改的源代码。\n不能在分发时添加额外的限制（例如，不能禁止用户对软件进行反向工程、不能再许可、不能要求付费购买许可密钥等）。\n这种特性确保自由不会在后续分发中“流失”，自由软件网络会持续扩大。\n\nLinux 内核与 GPLv2 的具体关系1.版本选择：Linux 内核严格采用 GPLv2，不是较新的 GPLv3。林纳斯·托瓦兹 (Linus Torvalds) 和其他核心开发者对此选择有明确立场，主要涉及对 GPLv3 中某些条款（如对硬件限制如 Tivoization 的约束）的顾虑。\n2.动态加载模块： 这是一个复杂的法律边界问题。\n\n观点一（严格派）： 内核是 GPLv2 代码，任何动态链接到内核的模块（如驱动程序）都被认为与内核形成了一个整体作品，因此必须也是 GPLv2（或兼容）许可的。专有（闭源）内核模块违反了 GPL。\n观点二（宽松派 &#x2F; Linus 观点）： 如果内核模块只使用了内核公开的、稳定的、设计用于模块交互的 API（而不是直接访问内部函数或数据结构），并且是“非衍生的独立作品”，可能可以不是 GPL（虽然 LKML 社区强烈不鼓励闭源模块）。\n现实状况： 许多硬件厂商提供闭源驱动（二进制 blob），但这在法律上存在风险，也被开源社区认为违背了 GPL 的精神。社区和项目（如 FSF）持续努力用开源驱动替代闭源驱动。内核本身也提供了一些机制（如 EXPORT_SYMBOL_GPL）来标记只允许 GPL 模块调用的函数。\n\n3.用户空间程序不受此限：GPLv2 仅约束与 Linux 内核直接链接（形成组合作品）的程序，主要是内核模块。在 Linux 上运行的用户空间应用程序（如 Firefox, LibreOffice）不受内核 GPLv2 的限制。它们可以使用任何许可（GPL、LGPL、MIT、BSD、Apache 甚至是专有许可）。这是 GNU&#x2F;Linux 系统中“GNU”部分存在的原因之一——GNU 项目提供了在自由许可下的完整用户空间工具链。\nGPL 对 Linux 生态系统的意义1.成功的基石： GPL 是 Linux 成功的最关键因素之一。它确保了：\n\n源代码的开放性和可审计性： 任何人都可以检查、学习、改进代码，提高了安全性、可靠性和创新速度。\n广泛的协作开发： 企业（如 Red Hat, IBM, Intel, Google）和个人开发者都可以放心贡献，知道他们的贡献永远不会成为某家公司的私有财产。\n自由的保障： 用户可以确信自己拥有运行、修改和分发自由的权利，不会被供应商锁定。\n\n2.商业支持可行：GPL 允许公司基于 Linux 提供服务（技术支持、定制开发、云服务等）和分发商业发行版（如 RHEL, SUSE），只要它们遵守提供源码的义务（主要针对内核本身的修改）。红帽模式（提供开源代码，销售服务订阅）是成功的典范。\n3.巨大的社区和碎片化：GPL 催生了庞大的开发者社区和数量众多的发行版（Debian, Ubuntu, Fedora, Arch 等）。虽然碎片化可能是个挑战，但也提供了巨大的选择和灵活性。\n与其他开源许可的主要区别\n宽松许可 (MIT, BSD, Apache)： 允许修改版以专有闭源形式再发布（只要求保留版权声明）。用户自由在后续分发中可能丢失。例子：FreeBSD, Android ASOP。\n弱 Copyleft (LGPL)： 主要设计用于库，允许专有代码链接到 LGPL 库而不“感染”整个程序（只要遵守 LGPL 对库本身的条款）。例子：Glibc, GTK。\nGPL (Strong Copyleft)： 要求组合作品或衍生作品整体都必须保持 GPL（提供源码）。如 Linux 内核。例子：Linux kernel, GIMP, GCC。\nAGPL： 针对网络服务，如果修改后通过网络提供软件服务，也必须提供对应的源代码。例子：MongoDB (曾用过)， Nextcloud。\n\n5、Linux与UnixLinux 与 Unix 的关系非常密切，但又有本质区别。可以说 Linux 是 Unix 思想的继承者和发展者，但不是 Unix 代码的直系后代。它们共同构成了“Unix-like”操作系统家族的核心。理解它们的关系需要从历史、技术、许可和生态几个维度来看：\n1. Unix：开创者与标准\n起源 (1969)： 诞生于 AT&amp;T 的贝尔实验室（Ken Thompson, Dennis Ritchie 等人）。用 C 语言重写后（1973 年左右），其可移植性为普及奠定了基础。\n**关键特征：**引入了许多奠基性的概念：\n“一切皆文件”： 统一的文件、设备和进程间通信抽象。\n小型、单一目的工具： grep, sed, awk, ls, cat 等，可通过管道 | 组合 (command1 | command2)，遵循“组合优于继承”原则。\n层次化文件系统： root (/) 下的树状结构。\n多用户、多任务： 同时支持多个用户运行多个程序。\n内置强大 Shell： 作为用户和系统交互的主要界面。\n\n\n许可与分裂：\n早期： AT&amp;T 开始向学术界和商业机构提供源代码许可。\n**衍生分支：**不同机构在 AT&amp;T Unix 源码基础上发展出众多变体：\nBSD (Berkeley Software Distribution): 加州大学伯克利分校开发，产生了 FreeBSD、NetBSD、OpenBSD 等。\n商业 Unix: Sun Solaris (SunOS)、IBM AIX、HP-UX、SCO UnixWare、ATT System V 等。\n\n\n“Unix 战争”： 各个商业版本在标准化上竞争激烈，存在互不兼容问题。\n\n\n标准： 为解决兼容性问题，诞生了 POSIX (Portable Operating System Interface) 标准（由 IEEE 指定）。它定义了操作系统为兼容 Unix 风格所需提供的最小 API 接口标准（如系统调用、shell 行为等）。\n\n2. Linux：开源的新兴力量\n**起源 (1991)：**由芬兰大学生 Linus Torvalds开发，初衷是创建一个 免费、开源的类 Unix 内核。\n关键背景：GNU 计划 (1983年启动，Richard Stallman)：目标是创建一个完全自由的操作系统 GNU，在1991年时几乎完成了所有用户空间工具 (GCC, glibc, bash, coreutils 等)，但唯独缺少一个成熟可用的内核（GNU Hurd 进展缓慢）。\n\n\n核心特点：\n只是内核 (Kernel)： Linux 本身不是完整的操作系统，只是系统的核心（管理硬件、进程、内存等）。用户空间工具主要来自 GNU。\n开源自由： 采用 GPLv2 许可证，保证了其自由传播、修改和使用的权利。\n设计理念： 严格遵循 Unix 哲学，但 不包含任何原始的 AT&amp;T Unix 源代码（是干净的重新实现，避免了法律纠纷）。\n高度模块化： 支持动态加载内核模块。\n可移植性强： 支持极其广泛的硬件架构（从超级计算机到嵌入式设备）。\n\n\nLinux 发行版 (Linux Distribution)： 一个 完整的操作系统通常 &#x3D; Linux 内核 + GNU 工具链&#x2F;库 + 其他软件（桌面环境、包管理器、应用等）  + 集成安装&#x2F;配置工具。常见的发行版包括：\n商业支持： Red Hat Enterprise Linux (RHEL)、SUSE Linux Enterprise Server (SLES)、Ubuntu Pro (Canonical)。\n社区驱动： Debian、Ubuntu (社区版本)、Fedora (RHEL 上游)、openSUSE (SLES 上游)、Arch Linux、Gentoo 等。\n\n\n\n3. Linux 与 Unix 的关键关系与区别\n\n\n特征\nUnix (传统的，如 System V, BSD, AIX, Solaris)\nLinux\n\n\n\n血统\n直接或间接来源于 AT&amp;T 贝尔实验室的原始 Unix 源代码。\n独立开发，不包含任何 AT&amp;T Unix 源码。是一个全新的实现，遵循 Unix 设计理念。\n\n\n内核\n单一内核（Monolithic Kernel）或混合内核设计。不同分支内核名称各异（如 Solaris Kernel）。\nLinux 内核（也是单一内核设计）。\n\n\n许可\n历史上多为专有许可：商业 Unix 要求高昂的许可费。BSD 系统采用宽松的开源协议（如 BSD License，允许闭源再分发）。\n内核采用 GPLv2（强 Copyleft）。用户空间工具多为 GPL 或 LGPL。核心原则是自由和开源。\n\n\n所有权\n历史上由 AT&amp;T 所有，后分裂为多个商业实体所有（IBM, Oracle, HPE 等）。BSD 由社区维护。\n不属于任何单一实体。由社区（个人和公司）共同开发维护。Linux 商标归 Linus Torvalds 所有。\n\n\n标准化\nPOSIX 标准的最初目标对象。各大商业版本曾试图主导自己的标准。\n完全兼容 POSIX 标准（遵循其 API 和 shell 行为规范）。\n\n\n开发模型\n历史上是闭源专有开发。BSD 系列采用开源社区协作模式。\n大规模的开源协作模式。任何人都可以参与贡献代码（通过邮件列表、Git）。版本控制明确（Git）。\n\n\n变体&#x2F;碎片化\n形成了多个不兼容的商业分支（Solaris, AIX, HP-UX）。BSD 分支（FreeBSD, OpenBSD, NetBSD）相对独立但更兼容。\n存在大量发行版（数百个），它们在 软件包管理、默认配置、打包策略、桌面环境、支持周期 上差异很大。但都使用同一个 Linux 内核（不同版本），应用层兼容性较好（POSIX + 发行版差异）。\n\n\n硬件支持\n传统商业 Unix 通常紧密绑定厂商特定的硬件（RISC 架构，如 SPARC, Power）。\n支持极其广泛的硬件架构：x86&#x2F;x86_64, ARM, RISC-V, POWER, MIPS, 等等。硬件驱动生态系统庞大（开源社区驱动 + 厂商贡献）。\n\n\n用户 &amp; 用途\n传统上用于高端服务器、工作站和大企业关键任务系统。成本高昂。\n无处不在：超级计算机、服务器集群、云计算、数据中心、嵌入式系统、路由器、智能手机(Android 基于 Linux 内核)、桌面&#x2F;笔记本电脑。\n\n\n6、主要应用领域：\n服务器： Linux 是互联网的基石。绝大部分的 Web 服务器、云服务器、数据库服务器等都运行 Linux。\n超级计算机： 全球性能最强的超级计算机几乎都运行基于 Linux 的系统。\n嵌入式设备： 智能手机（Android 基于 Linux 内核）、路由器、智能电视、物联网设备、车载娱乐系统等。\n开发者工作站： 命令行工具、软件包管理和开发环境使其成为开发者的首选，尤其在 Web 开发、云计算、数据科学、人工智能等领域。\n桌面电脑： 越来越多的用户将 Ubuntu、Fedora、Mint 等作为日常使用的操作系统，替代 Windows 或 macOS。\n基础设施： 路由器、防火墙、NAS 存储等网络设备大量使用 Linux。\n\n三、Linux目录结构1/            #根目录\n\n起始点，系统上所有的文件都存在这里\n1/root /home  #家目录\n\n1/root        #存放root的配置文件\n\n1/home        #存放用户的普通文件\n\n12345678910111213141516171819202122/etc                                    #系统配置目录/etc/sysconfig/network-scripts          #网卡配置文件/etc/yum.repos.d/CentOS-Base.repo       #操作系统软件包/etc/yum.repos.d/CentOS-AppStream.repo  #应用流软件包/etc/yum.repos.d/CentOS-Extras.repo     #额外软件补充包mirrorlist                              #两种指定仓库位置的配置方式，他的工作方式：直接指定仓库                                        #工作流程：直接访问指定的URL，下载仓库数据                                        #如果地址不可达，会报错baseurl                                 #先访问mirrorlist url的获取镜像地址列表                                               #下载出列表，并开始测试响应速度                                        #选择出最优的镜像进行连接，下载仓库数据                                       SElinux                                 #美国国家安全局提出的概念：强制访问控制安全机制，用于增强linux的安全性                                            #自主访问控制安全机制 rw                                        #三种模式：                                        #enforcing：强制模式（默认）：严格执行安全策略的，违规操作会被阻止                                        #permissive：标准模式/宽容模式：会允许并记录                                        #disable：禁用，完全关闭并记录                                                         #SElinuxTYPE：targeted：仅保护安全进程；mls：多级安全策略，用于军事领域\n\n123/dev               #设备文件目录                   #存放的是所有硬件设备                   #权限：仅仅只有root或disk用户组有操作权限\n\n12/bin               #系统命令目录/sbin              #管理员级系统命令，专供超级管理员（root用户）使用\n\n为什么linux要把所有命令存放在目录？单用户模式（救援模式、维护模式）下依然可以使用，多为系统运行必需的命令。\n123456789101112131415/var                #存储动态变化的数据目录，会随着系统运行不断增长/var/log            #系统和服务日志（如syslog、nginx/access.log）。在能够写入日志的情况下，写入木马，获取shell/var/lib            #应用程序数据（如 MySQL 数据库/var/lib/mysql）。mysql数据库、docker容器/var/spool          #队列数据（如邮件队列 /var/spool/mail）。/var/log/secure     #安全认证日志（如 SSH 登录记录）。/var/log/messages   #核心系统日志（替代通用 syslog）/tmp                #存放临时文件，全局可读写的，重启会清空/usr                #存储的是静态的用户进程、用户命令、库文件、共享数据\n\n数据性质：&#x2F;var 动态变化；&#x2F;tmp 临时数据；&#x2F;usr 静态只读\n是否可以删除？:&#x2F;var 是部分可删；&#x2F;tmp 可删；&#x2F;usr不可删\n是否需要备份？：&#x2F;var部分需要备份（数据库）；&#x2F;tmp不需要备份；&#x2F;user不需要备份\n文件大小？&#x2F;var  10G 以上，日志可能会膨胀；&#x2F;tmp  1G 以内；&#x2F;usr   5G - 20G 左右 Linux 基础系统\n分区情况：&#x2F;var 建议单独分区；&#x2F;tmp 通常会挂载为tmpfs；&#x2F;usr 通常和&#x2F;合并\n123/boot                #是启动linux系统所需的核心文件                     #内核kernel就i是存放在这里面                     #临时根文件系统\n\n1/lib\t             #核心共享库和内核模块\n\n1/proc\t             #内核与进程虚拟文件系统（实时系统状态）\n\n1/sys                 #硬件设备虚拟文件系统（配置内核参数）\n\n1/opt                 #第三方软件（大型独立应用）\n\n1/mnt                 #临时挂载点（手动挂载设备）\n\n1/media               #可移动设备自动挂载点\n\n\n\n四、Linux：一切皆文件123456789101112131415161718192021222324252627282930touch filename                   #创建文件touch file1 file2                #批量创建文件mkdir dir1                       #创建目录mkdir -p dir1/dir2               #创建嵌套目录结构mkdir -m 750 dir1                #创建权限为 drwxr-x--- 的目录cp 1.txt dir1                    #复制文件到目录cp -r dir1 dir2                  #复制目录mv 1.txt 2.txt                   #重命名mv 1.txt dir1                    #移动文件到目录rm -r dir1                       #删除目录rm -f dir1                       #强制删除rm -rf dir1                      #强制删除目录及内容#慎用！多用mv 少用rmvim 1.txt                        #打开 Vim 文本编辑器来创建或编辑名为 1.txt 的文件cat 1.txt                        #查看文件内容less                             #分页查看文件cat filename | less tail                             #查看文件末尾  tail -n 20 filename              #查看文件末尾20行tail -f app.log | grep &quot;ERROR&quot;   #实时跟踪日志文件并过滤出包含&quot;ERROR&quot;的行\n\n","slug":"Linux基础","date":"2025-07-29T02:38:02.000Z","categories_index":"","tags_index":"Linux学习","author_index":"wyf"},{"id":"1991d92d523634790e777614ebed22a2","title":"CentOS 8 环境搭建及配置","content":"CentOS 8 虚拟机搭建及配置一、下载安装Vmware Workstation在网上找教程，这里使用Vmware Workstation Pro 17\n二、下载CentOS 8 虚拟机镜像源在网上找下载地址，这里不做提供\n一、创建CentOS 8 虚拟机1、打开Vmware Workstation创建虚拟机点击右上角文件，新建虚拟机\n\n选择自定义，点击下一步\n\n硬件兼容性，这里选择Workstation 17.x，在新版本创建的虚拟机如果想在老版本使用可能会出错，点击下一步\n\n点击稍后安装操作系统，点击下一步\n\n客户机操作系统选择Linux，版本选择CentOS 8 64位，点击下一步\n\n修改虚拟机名称（建议修改，这样可以知道自己在什么时间创建了这个虚拟机，后续要用是能知道是干什么的），修改位置（建议不要放在C盘），点击下一步\n\n选择处理器数量，用来学习，1个就行，每个处理器的内核数量设置为2，点击下一步\n\n修改虚拟机内存4GB，点击下一步\n\n网络连接设置为NAT，点击下一步\n\n点击下一步\n\n点击下一步\n\n磁盘设置为创建新虚拟磁盘，点击下一步\n\n磁盘大小20GB，点击将虚拟磁盘存储为单个文件，点击下一步\n\n点击下一步\n\n点击自定义硬件，这里需要修改虚拟机硬件\n\n点击下方添加按钮，点击网络适配器，点击完成\n\n可以看到多了一个网络适配器2，点击关闭\n\n最后点击完成\n\n找到刚刚创建好的新虚拟机，点击编辑虚拟机设置，找到CD&#x2F;DVD，点击使用ISO映像文件，找到下载的CentOS 8 的iso文件，点击确定\n\n这样新建虚拟机就完成了。\n2、打开创建好的虚拟机开启此虚拟机，选择Install CentOS Linux 8，回车\n\n选择中文，简体中文，点击继续\n\n点击进入软件选择，找到传统UNIX兼容性、开发工具，勾上，点击完成\n\n点击安装目标位置，选择磁盘，点击完成\n\n点击网络和主机名，修改主机名，点击应用，选择以太网（ens160），打开，点击完成\n\n点击时间和日期，修改地址为上海，点击完成\n\n基本设置完成后点击开始安装\n\n设置root密码，点击完成\n\n创建一个用户，设置密码，点击完成\n\n都完成后等待安装\n\n安装完成后点击重启\n\n授权许可后登录root用户，在未列出里输入root，密码，即可登录\n\n现在这个界面右键选项里没有控制台，需要更改以下设置，点击右上角注销root用户，重新登录root用户时在登录左边的按钮选择经典，然后点击登录\n\n现在右键即可打开控制台\n\n现在在此界面拍摄一次快照，名称改为初始安装，便于日后使用\n\n3、对虚拟机进行配置关闭防火墙首先输入命令查看防火墙\n1systemctl status firewalld.service\n\n\n需要先临时关闭防火墙，再禁用防火墙\n12systemctl stop firewalld.servicesystemctl disable firewalld.service\n\n\n设置SELinux1vim /etc/selinux/config\n\n\n将SELINUX&#x3D;enforcing修改为SELINUX&#x3D;permissive\n\n关闭虚拟网卡查看虚拟网卡状态\n1systemctl status libvirtd.service\n\n\n关闭虚拟网卡\n1systemctl disable libvirtd.service\n\n\n换源1vim /etc/yum.repos.d/CentOS-AppStream.repo\n\n\n注释mirrorlist，取消注释beaseurl，将他的值更换成\n1https://mirrors.aliyun.com/centos-vault/8.5.2111/extras/$basearch/os/\n\n\n同样的方法修改\n12vim /etc/yum.repos.d/CentOS-Base.repovim /etc/yum.repos.d/CentOS-Extras.repo \n\n\n\n清除旧缓存，加载新源数据\n12yum clean all  #删除所有缓存的软件包数据（包括旧的软件包头文件、元数据、下载的软件包等）yum makecache  #从配置的软件仓库（Repository）下载最新的软件包列表、依赖关系等元数据，并存储在本地\n\n\n最后保存快照\n\n","slug":"CentOS-8-环境搭建及配置","date":"2025-07-28T13:51:19.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"},{"id":"d69852fb48fa32246d1e3f9497c9ab8f","title":"Hexo个人博客搭建教程","content":"Hexo个人博客搭建教程一、准备工具1、Typora软件简介Typora 是一款轻便简洁的 Markdown 编辑器，将写作与预览窗口相结合，采用所见即所得的编辑模式，具有实时预览、语法扩展等诸多特色功能。在接下来的个人博客搭建过程中会使用到Markdown文件，建议安装使用Typora。\n安装过程下载地址：https://www.typoraio.cn/\n\n得到下载文件后双击安装，一直Next下一步，选择安装地址，安装完成后打开使用。\n2、Nodejs软件简介Node.js 是一个强大的、基于 JavaScript 和 V8 引擎的运行时环境，利用事件驱动、非阻塞 I&#x2F;O 模型实现了高性能，尤其擅长构建可扩展的网络应用和实时服务，并拥有npm这一巨大的开源生态系统作为后盾。它是现代全栈 JavaScript 开发的基础。\n安装过程下载地址：https://nodejs.org/zh-cn/download\n\n修改安装路径，一直Next下一步即可，建议保留Add to PATH，这样后续就不用在环境变量中配置，可以直接在全局使用Node命令，在控制台命令行输入可以验证安装\n1node -v\n\n1npm -v\n\n\n3、Git软件简介Git 是一个分布式版本控制系统（DVCS），由 Linus Torvalds（Linux 内核创始人）于 2005 年开发。其核心功能是：\n\n追踪文件变更：记录代码、文档的每一次修改\n多人协作：支持多人并行开发同一项目\n灾难恢复：可回溯到任意历史版本\n\n安装过程下载地址：https://git-scm.com/downloads/win\n\n选择合适的版本进行下载，Git官网提供两种类型：\n\nStandalone Installer（独立安装程序）：常规的安装包，会在系统中进行完整安装，写入系统注册表等，将 Git 集成到系统环境，安装后可在命令行等环境直接调用，是最常用的安装方式，比如 “Git for Windows&#x2F;x64 Setup” 这类，适合长期在固定电脑使用 Git 的场景 。\nPortable (“thumbdrive edition”，便携版 &#x2F; 拇指驱动器版)：无需安装，解压或拷贝后即可使用，不写入系统注册表，可放在 U 盘等移动存储设备，在不同电脑即插即用，像 “Git for Windows&#x2F;x64 Portable” ，方便在多台电脑临时使用 Git 且不想在每台电脑都安装的情况 。\n\n下载完成后双击打开文件，选择安装路径，一直Next下一步即可，安装完成会打开一个Git的介绍网页。\n4、Hexo软件简介Hexo 是一个基于 Node.js 的开源静态博客生成器，通过解析 Markdown 文件和模板，生成纯 HTML&#x2F;CSS&#x2F;JS 网站。核心定位：为开发者、写作者提供高效内容发布和极简技术栈维护的解决方案。\n安装过程使用管理员身份打开打开Windows控制台，下载命令：\n1npm install hexo-cli -g     #全局安装\n\n\n安装完成后输入命令去验证：\n1hexo -v\n\n\n二、本地博客部署需要从 GitHub 克隆 Hexo 官方模板仓库，在E盘空白处右键，点击Open Git Bash here（安装完Git就会出现）\n\n弹出如下界面\n\n输入命令\n1hexo init blog\n\n\n会提示 Please run ‘npm install’ in “E:\\blog” folder.\n用管理员身份打开cmd，进入E:\\bolg目录下\n1cd /d E:\\blog\n\n输入命令\n1npm install\n\n安装完成后显示如下界面\n\n\n如果在npm install这一步没有使用管理员打开cmd，而是进入blog文件里面，通过git bash输入npm install，可能会报错\n\n这里错误代码时4048，通过查阅发现可能就是权限不够的问题，因此通过管理员打开控制台再输入npm install就可以。这里只提供笔者遇到的一种错误解决方法，也是在查阅资料后找到的解决方法。\n至此本地博客已经搭建完成。\n1hexo g\n\nhexo g 是 Hexo 静态博客生成器的核心命令，将源代码（Markdown 文章&#x2F;主题&#x2F;配置等）编译成静态网页文件。\n\n1hexo s\n\nhexo s 是 Hexo 静态博客生成器的核心命令，全称为 hexo server。它的主要作用是启动本地服务器用于实时预览博客效果\n\n此时在浏览器输入http://localhost:4000/，可以看到一个简易的个人博客\n\n三、本地博客部署到云服务器在本地博客部署到云服务器之前，需要有一个本地搭建完的博客，一台云服务器，本地安装一个SSH连接工具（或者bash终端）\n1、搭建仓库搭建GitHub存储静态页面的仓库，首先注册&#x2F;登录Github，点击Create repository进入新建仓库页面\n\n仓库名输入：\n1用户名.github.io\n\n勾选 Public ，勾选 Add a README file ，拉到下面点击create创建\n2、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here，输入\n1ssh-keygen -t rsa -C &quot;邮件地址&quot;\n\n\n进入C:\\Users\\用户名，在里面进入.ssh文件，用记事本打开里面的id_rsa.pub,全选复制里面的代码\n\n然后打开 Github ，进入用户设置，找到 SSH keys 新建SSH keys，名称随意，在下面粘贴代码， 然后创建\n\n测试是否成功，在 Git bash 中输入\n1ssh -T git@github.com\n\n笔者在这一步时遇到了错误\n\n这里表示SSH的22端口可能被防火墙或者网络限制了，笔者给出一种方案，输入命令\n1ssh -T -p 443 git@github.com\n\n\n启用通过HTTPS的SSH连接，笔者在这里能够成功连接，在 SSH 配置文件中设置此设置，请在 ~/.ssh/config 编辑该文件（没有可以直接创建一个config文件，无后缀），并添加以下部分\n1234Host github.comHostname ssh.github.comPort 443User git\n\n最后可以通过再次连接到 GitHub.com 测试此项是否有效\n1ssh -T git@github.com\n\n\n笔者在这里就能够成功连接。\n3、上线博客进入之前的blog文件夹，用记事本打开_config.yml 拉到最下面将deploy后面的全删掉，复制粘贴这段\n123type: gitrepository: branch: main\n\n注意冒号后面有一个空格，每行前面有两个空格。\n进入Github之前生成的仓库页面，点击Code，将下方出现的https链接复制下来，粘贴到repositort: 后面，然后保存并退出。\n回到blog文件夹，打开Git bash，安装自动部署发布工具\n1npm install hexo-deployer-git --save\n\n\n\n\n接下来依次输入\n12hexo g（生成静态文件）hexo d（将静态文件上传到github）\n\n\n\n\n\n接下来我们就成功把本地内容上传到Github了，上传成功以后，我们就算搭建好了！上自己的网址看看吧，网址是我们之前设的仓库名：用户名.github.io\n4、发布文章1hexo new “文章名”\n\n 找到文章路径，修改标题、日期、标签（标签前要加一个空格，否则会报错！）\n12hexo ghexo d\n\n四、PicGo的Github配置1、配置Github新建公开仓库\n\n创建私人令牌token\n\n\n\n然后记下token值\n2、下载PicGo下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n图床设置\n\n具体图床参数配置\n\n","slug":"Hexo个人博客搭建教程","date":"2025-07-28T13:41:52.000Z","categories_index":"","tags_index":"教程","author_index":"wyf"}]