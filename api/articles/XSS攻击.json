{"title":"XSS攻击","uid":"1cc67b731b39ffe2f01ec906867d987d","slug":"XSS攻击","date":"2025-08-25T03:00:17.000Z","updated":"2025-08-25T03:23:39.186Z","comments":true,"path":"api/articles/XSS攻击.json","keywords":null,"cover":[],"content":"<h1 id=\"XSS攻击\"><a href=\"#XSS攻击\" class=\"headerlink\" title=\"XSS攻击\"></a>XSS攻击</h1><h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><ul>\n<li><strong>本质：</strong> XSS 攻击允许攻击者将<strong>恶意的客户端脚本代码（通常是 JavaScript）</strong> 注入到其他用户会访问的网页中。</li>\n<li><strong>目标：</strong> 当受害者的浏览器加载并执行了这些恶意脚本时，攻击就成功了。攻击者的目标通常是访问或窃取受害者的敏感信息（如会话 Cookie、身份验证令牌、个人数据）、劫持用户会话、篡改网页内容、将用户重定向到恶意网站，甚至在用户浏览器中执行其他恶意操作。</li>\n<li><strong>关键点：</strong> 恶意脚本是在<strong>受害者用户的浏览器</strong>中执行的，并且是在<strong>受害者信任的网站或应用程序的上下文</strong>中执行的。这使得攻击具有很高的欺骗性。</li>\n</ul>\n<h2 id=\"XSS-漏洞的类型\"><a href=\"#XSS-漏洞的类型\" class=\"headerlink\" title=\"XSS 漏洞的类型\"></a>XSS 漏洞的类型</h2><p>XSS 主要分为三种类型，它们的主要区别在于恶意脚本的存储位置和注入方式：</p>\n<ol>\n<li><p><strong>反射型 XSS：</strong></p>\n<ul>\n<li><p><strong>原理：</strong> 恶意脚本作为 HTTP 请求的一部分（通常在 URL 参数或表单数据中）发送给服务器。服务器在未充分验证或转义的情况下，直接将这部分包含恶意脚本的内容“反射”回给用户的响应页面中。浏览器执行了响应中的恶意脚本。</p>\n</li>\n<li><p><strong>特点：</strong></p>\n<ul>\n<li>恶意脚本<strong>不存储在服务器上</strong>。</li>\n<li>攻击通常需要<strong>诱骗用户点击一个精心构造的链接</strong>（包含恶意脚本）。</li>\n<li>是一次性的，只影响点击该链接的用户。</li>\n</ul>\n</li>\n<li><p><strong>例子：</strong> DVWA靶场反射型XSS漏洞</p>\n<ul>\n<li>LOW</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250825111955459.png\" alt=\"image-20250825111955459\"></p>\n<p>在输入框中输入<code>&lt;script&gt;alert(/123/)&lt;/script&gt;</code>点击Submit提交，页面显示弹窗，内容为123</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250825112013993.png\" alt=\"image-20250825112013993\"></p>\n<p>查看源代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">header</span> (<span class=\"string\">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Is there any input?</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>( <span class=\"title function_ invoke__\">array_key_exists</span>( <span class=\"string\">&quot;name&quot;</span>, <span class=\"variable\">$_GET</span> ) &amp;&amp; <span class=\"variable\">$_GET</span>[ <span class=\"string\">&#x27;name&#x27;</span> ] != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Feedback for end user</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class=\"variable\">$_GET</span>[ <span class=\"string\">&#x27;name&#x27;</span> ] . <span class=\"string\">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span> </span><br></pre></td></tr></table></figure>\n\n<p>就是一个简单的传参，然后拼接到 html 中去，没有进行任何过滤，导致输入简单的 js 代码也能执行</p>\n<ul>\n<li>Medium</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250825112249349.png\" alt=\"image-20250825112249349\"></p>\n<ul>\n<li>High</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250825112320262.png\" alt=\"image-20250825112320262\"></p>\n<ul>\n<li>Impossible</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250825112335816.png\" alt=\"image-20250825112335816\"></p>\n</li>\n</ul>\n</li>\n<li><p><strong>存储型 XSS：</strong></p>\n<ul>\n<li><strong>原理：</strong> 攻击者将恶意脚本提交到目标网站（例如，通过论坛帖子、用户评论、用户资料字段、消息等），这些脚本被<strong>永久存储在服务器上</strong>（如数据库）。当其他用户浏览包含这些存储内容的页面时，恶意脚本就会从服务器加载并在他们的浏览器中执行。</li>\n<li><strong>特点：</strong><ul>\n<li>恶意脚本<strong>持久存储在服务器</strong>上。</li>\n<li>攻击影响<strong>所有访问包含恶意脚本页面的用户</strong>，无需用户点击特定链接。</li>\n<li>危害通常更大，影响范围更广。</li>\n</ul>\n</li>\n<li><strong>例子：</strong> 一个允许用户评论的博客。攻击者在评论框中输入 <code>&lt;script&gt;恶意代码&lt;/script&gt;</code>。如果网站未对评论内容进行过滤或转义，这条评论被保存到数据库。之后，任何访问该博客文章并看到这条评论的用户，其浏览器都会执行这段恶意脚本。</li>\n</ul>\n</li>\n<li><p><strong>基于 DOM 的 XSS：</strong></p>\n<ul>\n<li><strong>原理：</strong> 整个攻击过程发生在<strong>客户端的 DOM 环境中</strong>，<strong>不涉及服务器</strong>。恶意脚本的来源（如 URL 片段 <code>#</code>后面的部分）被客户端 JavaScript 代码（如 <code>document.location</code>, <code>document.URL</code>, <code>document.referrer</code>或 <code>eval()</code>等）读取并<strong>动态地写入或修改了 DOM 结构</strong>，导致恶意脚本被执行。</li>\n<li><strong>特点：</strong><ul>\n<li>漏洞存在于<strong>客户端 JavaScript 代码</strong>中，服务器响应本身可能是“干净”的。</li>\n<li>恶意负载通常位于 URL 片段中（<code>#</code>之后的部分）。</li>\n<li>同样需要诱骗用户点击恶意链接。</li>\n</ul>\n</li>\n<li><strong>例子：</strong> 一个页面使用 JavaScript 从 URL 片段中读取参数并动态更新页面内容：<code>https://example.com/welcome#name=&lt;img src=x onerror=恶意代码&gt;</code>。如果页面上的 JS 代码直接使用 <code>location.hash</code>的值并 <code>innerHTML</code>到一个元素中，<code>onerror</code>事件里的恶意代码就会被执行。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"XSS-攻击的危害\"><a href=\"#XSS-攻击的危害\" class=\"headerlink\" title=\"XSS 攻击的危害\"></a>XSS 攻击的危害</h2><p>成功利用 XSS 漏洞可能导致非常严重的后果：</p>\n<ol>\n<li><strong>窃取 Cookie 和会话令牌：</strong> 恶意脚本可以读取当前域名下的 Cookie（包括会话 Cookie），发送给攻击者，导致攻击者完全劫持用户的会话，以用户身份登录。</li>\n<li><strong>窃取敏感信息：</strong> 可以读取页面内容、表单数据、用户输入，窃取密码、信用卡号、个人信息等。</li>\n<li><strong>钓鱼攻击：</strong> 在受信任的网站上注入伪造的登录表单或内容，诱骗用户输入凭证。</li>\n<li><strong>键盘记录：</strong> 记录用户在受感染页面上的按键操作。</li>\n<li><strong>网站篡改：</strong> 修改页面内容，显示虚假信息、诽谤内容或恶意广告。</li>\n<li><strong>重定向用户：</strong> 将用户浏览器重定向到攻击者控制的钓鱼网站或恶意软件下载站点。</li>\n<li><strong>传播蠕虫：</strong> 在社交网站上，恶意脚本可以自动发送好友请求、发布包含恶意链接的状态等，实现自我传播（如 Samy 蠕虫）。</li>\n<li><strong>安装恶意软件：</strong> 利用浏览器漏洞下载并安装恶意软件。</li>\n<li><strong>发起 DDoS 攻击：</strong> 控制大量受害者浏览器向特定目标发起请求（作为僵尸网络的一部分）。</li>\n</ol>\n<h2 id=\"如何防御-XSS-攻击\"><a href=\"#如何防御-XSS-攻击\" class=\"headerlink\" title=\"如何防御 XSS 攻击\"></a>如何防御 XSS 攻击</h2><p>防御 XSS 需要多层次的方法，关键在于<strong>对不可信数据进行严格的验证、转义和限制</strong>：</p>\n<ol>\n<li><strong>输入验证和过滤：</strong><ul>\n<li><strong>验证：</strong> 对所有用户输入进行严格的格式和类型验证（例如，邮箱地址、电话号码、数字范围）。拒绝不符合预期的输入。</li>\n<li><strong>过滤：</strong> 在特定上下文中，安全地移除或编码不允许的字符（如 <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>&quot;</code>, <code>&#39;</code>）。但<strong>过滤通常不如转义可靠</strong>，且容易出错（黑名单方式容易被绕过）。</li>\n<li><strong>注意：</strong> 在服务器端和客户端（前端）都应进行验证，但<strong>服务器端验证是绝对必要的防线</strong>，因为客户端验证很容易被绕过。</li>\n</ul>\n</li>\n<li><strong>输出转义&#x2F;编码：</strong><ul>\n<li><strong>这是最核心、最有效的防御手段！</strong> 在将<strong>任何</strong>不可信数据（用户输入、数据库内容、第三方 API 数据等）<strong>输出</strong>到不同上下文时，必须进行正确的转义（编码）。</li>\n<li><strong>关键：</strong> 转义必须根据<strong>输出目标上下文</strong>进行：<ul>\n<li><strong>HTML 上下文：</strong> 将数据输出到 HTML 标签内容或属性值时，使用 HTML 实体编码（例如，<code>&lt;</code>转成 <code>&lt;</code>, <code>&gt;</code>转成 <code>&gt;</code>, <code>&amp;</code>转成 <code>&amp;</code>, <code>&quot;</code>转成 <code>&quot;</code>, <code>&#39;</code>转成 <code>&#39;</code>）。现代前端框架（React, Vue, Angular 等）通常默认对绑定数据进行 HTML 转义。</li>\n<li><strong>HTML 属性上下文：</strong> 同上，使用 HTML 实体编码。同时，属性值最好始终用引号（单或双）括起来。</li>\n<li><strong>JavaScript 上下文：</strong> 将数据输出到 <code>&lt;script&gt;</code>标签内或事件处理程序属性（如 <code>onclick</code>）时，使用 JavaScript 编码（例如，对非字母数字字符进行 <code>\\xHH</code>形式的十六进制编码或 <code>\\uXXXX</code>Unicode 编码）。<strong>避免将不可信数据放入 JavaScript 上下文！</strong> 优先考虑将数据放在 HTML 的 <code>data-*</code>属性中，然后用 JS 读取。</li>\n<li><strong>URL 上下文：</strong> 在将数据作为 URL 参数值时（例如 <code>href</code>, <code>src</code>属性），使用 URL 编码（百分比编码）。</li>\n<li><strong>CSS 上下文：</strong> 在将数据放入 CSS（如 <code>style</code>属性或 <code>&lt;style&gt;</code>标签）时，使用 CSS 编码。<strong>避免将不可信数据放入 CSS 上下文！</strong></li>\n</ul>\n</li>\n<li><strong>使用安全的 API：</strong> 优先使用框架提供的安全输出机制（如 React 的 JSX 自动转义、Vue 的 Mustache 语法 <code>&#123;&#123; &#125;&#125;</code>自动转义）或经过严格测试的库函数（如 OWASP ESAPI, DOMPurify）来处理转义。</li>\n</ul>\n</li>\n<li><strong>内容安全策略：</strong><ul>\n<li><strong>CSP 是一个强大的防御层。</strong> 它是一个 HTTP 响应头（<code>Content-Security-Policy</code>），用于定义浏览器只应加载和执行哪些来源的脚本、样式、图片、字体等资源。</li>\n<li><strong>效果：</strong> 即使攻击者成功注入了恶意脚本，如果该脚本的来源不在 CSP 允许的白名单内，浏览器将<strong>阻止其执行</strong>。</li>\n<li><strong>关键指令：</strong> <code>script-src</code>(控制脚本来源)， <code>default-src</code>(其他资源的默认策略)。</li>\n<li><strong>推荐实践：</strong> 使用 <code>nonce</code>或 <code>hash</code>来内联脚本，避免使用不安全的 <code>&#39;unsafe-inline&#39;</code>；尽量禁用 <code>&#39;unsafe-eval&#39;</code>。</li>\n</ul>\n</li>\n<li><strong>HttpOnly Cookie 标志：</strong><ul>\n<li>为敏感的 Cookie（尤其是会话 ID）设置 <code>HttpOnly</code>属性。这可以<strong>阻止 JavaScript 通过 <code>document.cookie</code>API 访问这些 Cookie</strong>，大大增加了攻击者窃取会话令牌的难度。但这并不能防御所有类型的会话劫持（如网络嗅探）。</li>\n</ul>\n</li>\n<li><strong>安全框架和库：</strong><ul>\n<li>使用具有良好安全记录、内置 XSS 防护机制的现代 Web 开发框架（如 React, Vue, Angular）。</li>\n<li>使用专门用于清理 HTML 的库（如 <strong>DOMPurify</strong>），在允许用户输入富文本（HTML）时，对输入进行安全的清理过滤。</li>\n</ul>\n</li>\n<li><strong>避免危险函数和属性：</strong><ul>\n<li>避免在 JavaScript 中使用 <code>innerHTML</code>, <code>outerHTML</code>, <code>document.write()</code>等直接将字符串插入 HTML 的 API。优先使用更安全的 API，如 <code>textContent</code>或创建元素节点的方法（<code>createElement</code>, <code>appendChild</code>）。</li>\n<li>避免使用 <code>eval()</code>, <code>setTimeout(string)</code>, <code>setInterval(string)</code>, <code>new Function(string)</code>等可以执行字符串代码的函数。</li>\n</ul>\n</li>\n<li><strong>安全编码意识和培训：</strong><ul>\n<li>开发者必须了解 XSS 的原理、危害和防御方法，并在编码实践中时刻保持安全意识。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>XSS 漏洞源于应用程序未能正确处理用户输入，导致恶意脚本在受害者浏览器中执行。它危害巨大，可以窃取用户凭证、会话、敏感信息，破坏网站，甚至传播恶意软件。防御 XSS 的核心在于对<strong>所有不可信数据进行严格的输入验证和根据输出上下文进行正确的转义&#x2F;编码</strong>。同时，采用 CSP、HttpOnly Cookie、安全的框架和 API 等多层防御策略，并持续进行安全培训和代码审计，才能有效降低 XSS 风险。安全是一个持续的过程，需要开发者始终保持警惕。</p>\n","text":"XSS攻击核心概念 本质： XSS 攻击允许攻击者将恶意的客户端脚本代码（通常是 JavaScript） 注入到其他用户会访问的网页中。 目标： 当受害者的浏览...","permalink":"/post/XSS攻击","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Web","slug":"Web","count":5,"path":"api/tags/Web.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#XSS%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">XSS攻击</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">核心概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XSS-%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">XSS 漏洞的类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E5%8D%B1%E5%AE%B3\"><span class=\"toc-text\">XSS 攻击的危害</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-XSS-%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">如何防御 XSS 攻击</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"day11-test","uid":"f09eba89e1a54dd5af837a68dbc3d494","slug":"day11-test","date":"2025-08-25T07:41:09.000Z","updated":"2025-09-02T07:47:14.676Z","comments":true,"path":"api/articles/day11-test.json","keywords":null,"cover":[],"text":"1、通关dvwa靶场三个难度的反射型xssLOW 在输入框中输入<script>alert(/123/)</script>点击Submit提交，页面显示弹窗，内...","permalink":"/post/day11-test","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"练习","slug":"练习","count":14,"path":"api/tags/练习.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"week2-test","uid":"863b4b95d25d05f1547152379537778b","slug":"week2-test","date":"2025-08-22T06:15:43.000Z","updated":"2025-09-02T07:47:56.973Z","comments":true,"path":"api/articles/week2-test.json","keywords":null,"cover":[],"text":"1、参考sqli-lab靶场优化第一周编写的cms，将注册功能，登录功能优化，新增修改密码功能注册功能mysqli_prepare(): 这个函数用于准备一个S...","permalink":"/post/week2-test","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"练习","slug":"练习","count":14,"path":"api/tags/练习.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}