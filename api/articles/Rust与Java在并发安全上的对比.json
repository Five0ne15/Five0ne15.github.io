{"title":"Rust与Java在并发安全上的对比","uid":"1e5549aba23c836b488cd4ec215c029b","slug":"Rust与Java在并发安全上的对比","date":"2025-08-26T12:50:50.000Z","updated":"2025-08-26T12:51:28.044Z","comments":true,"path":"api/articles/Rust与Java在并发安全上的对比.json","keywords":null,"cover":null,"content":"<h1 id=\"Rust与Java在并发安全上的对比\"><a href=\"#Rust与Java在并发安全上的对比\" class=\"headerlink\" title=\"Rust与Java在并发安全上的对比\"></a>Rust与Java在并发安全上的对比</h1><h2 id=\"核心安全机制\"><a href=\"#核心安全机制\" class=\"headerlink\" title=\"核心安全机制\"></a>核心安全机制</h2><ol>\n<li><strong>Rust：</strong><ul>\n<li><strong>类型系统强制执行：</strong> 在<strong>编译时</strong>由 Rust 编译器严格检查。违反规则会导致编译错误。</li>\n<li><strong>并发安全 (<code>Send</code>和 <code>Sync</code>Traits)：</strong><ul>\n<li><code>Send</code>和 <code>Sync</code>是两个<strong>标记 trait</strong>（marker traits），它们构成了 Rust 线程安全的核心机制。这些 trait 没有方法，仅用于指示类型在多线程环境下的行为特性。编译器会根据这些标记自动进行并发安全检查。（trait是定义共享行为的核心机制，类似于其他语言中的接口（interface）或抽象基类（abstract base classes），但功能更加强大和灵活。）<ul>\n<li><code>Send</code>: 允许<strong>转移所有权</strong>到另一个线程。这意味着原线程放弃了对该值的所有权和控制权，新线程成为唯一的所有者。</li>\n<li><code>Sync</code>: 允许多个线程<strong>同时、只读地访问</strong>同一数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>核心思想：</strong> <strong>编译时</strong>防止数据竞争。</li>\n</ul>\n</li>\n<li><strong>Java：监视器锁</strong><ul>\n<li><strong>监视器锁 (<code>synchronized</code>关键字)：</strong> Java 最基础的同步机制。每个对象都有一个内置锁（监视器）。<code>synchronized</code>方法或代码块在进入时需要获取对象的锁，退出时释放锁。这确保了同一时间只有一个线程能执行该临界区代码。</li>\n<li><strong><code>java.util.concurrent</code>包：</strong> 提供了更高级、更灵活的并发工具：<ul>\n<li><code>Lock</code>接口 (<code>ReentrantLock</code>等)： 提供比 <code>synchronized</code>更丰富的功能（如可中断锁、公平锁、条件变量）。</li>\n<li>原子类 (<code>AtomicInteger</code>, <code>AtomicReference</code>等)： 提供硬件级别的原子操作（CAS），用于无锁编程。</li>\n<li>并发集合 (<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>等)： 线程安全的集合实现，通常使用细粒度锁或无锁技术优化性能。</li>\n<li>执行器框架 (<code>ExecutorService</code>)： 用于管理线程池和任务执行。</li>\n</ul>\n</li>\n<li><strong>核心思想：</strong> <strong>运行时</strong>管理并发安全。依赖开发者正确使用锁、原子变量、并发工具来避免数据竞争和确保内存可见性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Rust</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>安全保证</strong></td>\n<td><strong>编译时保证内存安全和无数据竞争。</strong> 如果程序编译通过，在并发场景下基本不会出现内存错误或数据竞争（除非使用了 <code>unsafe</code>）。</td>\n<td><strong>运行时保证。</strong> 需要开发者正确使用同步机制（锁、原子类等）和遵循 JMM 规则。编译器无法阻止你写出有数据竞争或可见性问题的代码。</td>\n</tr>\n<tr>\n<td><strong>并发错误检测</strong></td>\n<td><strong>编译时捕获绝大多数并发错误。</strong> 编译器是严格的“守门员”。</td>\n<td><strong>运行时暴露错误。</strong> 数据竞争、死锁、可见性问题通常在运行时（甚至生产环境）才暴露，难以调试复现。</td>\n</tr>\n<tr>\n<td><strong>开发效率</strong></td>\n<td><strong>前期可能较慢。</strong> 需要与编译器“斗争”以满足其安全规则。一旦编译通过，运行时信心很高。</td>\n<td><strong>前期较快。</strong> 上手简单，GC 减轻负担。但调试复杂的并发 Bug 可能极其耗时，抵消前期优势。</td>\n</tr>\n</tbody></table>\n<h2 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*在5秒的运行时间内，4个修改线程并发地对共享列表 data进行添加和删除操作（移除最后一个元素并添加随机数），同时1个读取线程不断读取并打印列表的当前内容。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">控制台会持续打印列表的内容（格式如 Current data: [ ... ]），频率取决于线程调度。</span></span><br><span class=\"line\"><span class=\"comment\">5秒后，程序停止所有线程，并输出 data列表的最终大小（Final size: ...）。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataRace</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 共享状态 - 所有线程共享这个ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;Integer&gt; data = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制线程运行的标志 - volatile确保多线程可见性</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">running</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建4个修改线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 启动新线程执行修改操作</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 只要running为true就持续运行</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (data.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 尝试删除最后一个元素 </span></span><br><span class=\"line\">                        data.remove(data.size() - <span class=\"number\">1</span>); <span class=\"comment\">// 并发删除</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 添加随机数 </span></span><br><span class=\"line\">                    data.add((<span class=\"type\">int</span>) (Math.random() * <span class=\"number\">100</span>)); <span class=\"comment\">// 并发添加</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start(); <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建读取线程</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 持续读取直到running变为false</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1. 尝试遍历列表（可能导致ConcurrentModificationException）</span></span><br><span class=\"line\">                <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;[&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 使用增强for循环遍历 - 需要迭代器</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Integer num : data) &#123;</span><br><span class=\"line\">                    sb.append(num).append(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                sb.append(<span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Current data: &quot;</span> + sb);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 2. 检查内部状态一致性</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (data.size() &gt; <span class=\"number\">0</span> &amp;&amp; data.get(data.size() - <span class=\"number\">1</span>) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 检测到空元素（ArrayList理论上不应有null，但并发可能破坏结构）</span></span><br><span class=\"line\">                    System.err.println(<span class=\"string\">&quot;!!! Detected null element at index &quot;</span> + (data.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        reader.start(); <span class=\"comment\">// 启动读取线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 运行5秒后停止</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>); <span class=\"comment\">// 主线程休眠5秒</span></span><br><span class=\"line\">        running = <span class=\"literal\">false</span>; <span class=\"comment\">// 设置停止标志</span></span><br><span class=\"line\">        reader.join(); <span class=\"comment\">// 等待读取线程结束</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Final size: &quot;</span> + data.size()); <span class=\"comment\">// 打印最终列表大小</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;D:\\Java jdk\\bin\\java.exe&quot;</span> <span class=\"string\">&quot;-javaagent:D:\\IDEA\\IntelliJ IDEA 2022.3.1\\lib\\idea_rt.jar=60337:D:\\IDEA\\IntelliJ IDEA 2022.3.1\\bin&quot;</span> -Dfile.encoding=UTF-<span class=\"number\">8</span> -classpath E:\\JavaOnlineWorkspace\\test\\out\\production\\test DataRace</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;Thread-4&quot;</span> java.util.ConcurrentModificationException</span><br><span class=\"line\"><span class=\"comment\">//线程 Thread-4 抛出了 `ConcurrentModificationException`异常。这是 Java 集合框架在检测到并发修改时的保护机制。</span></span><br><span class=\"line\">\tat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class=\"number\">1013</span>)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList$Itr.next(ArrayList.java:<span class=\"number\">967</span>)</span><br><span class=\"line\">\tat DataRace.lambda$main$<span class=\"number\">1</span>(DataRace.java:<span class=\"number\">28</span>)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:<span class=\"number\">833</span>)</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;Thread-3&quot;</span> Exception in thread <span class=\"string\">&quot;Thread-0&quot;</span> Exception in thread <span class=\"string\">&quot;Thread-2&quot;</span> java.lang.IndexOutOfBoundsException: Index <span class=\"number\">9</span> out of bounds <span class=\"keyword\">for</span> length <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">//三个不同的线程（Thread-3、Thread-0、Thread-2）同时抛出了 `IndexOutOfBoundsException`。第一个错误显示尝试访问索引 9，但列表长度只有 9（有效索引是 0-8）。</span></span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:<span class=\"number\">64</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:<span class=\"number\">70</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:<span class=\"number\">266</span>)</span><br><span class=\"line\">\tat java.base/java.util.Objects.checkIndex(Objects.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.remove(ArrayList.java:<span class=\"number\">504</span>)</span><br><span class=\"line\">\tat DataRace.lambda$main$<span class=\"number\">0</span>(DataRace.java:<span class=\"number\">16</span>)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:<span class=\"number\">833</span>)</span><br><span class=\"line\">java.lang.IndexOutOfBoundsException: Index <span class=\"number\">10</span> out of bounds <span class=\"keyword\">for</span> length <span class=\"number\">10</span></span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:<span class=\"number\">64</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:<span class=\"number\">70</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:<span class=\"number\">266</span>)</span><br><span class=\"line\">\tat java.base/java.util.Objects.checkIndex(Objects.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.remove(ArrayList.java:<span class=\"number\">504</span>)</span><br><span class=\"line\">\tat DataRace.lambda$main$<span class=\"number\">0</span>(DataRace.java:<span class=\"number\">16</span>)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:<span class=\"number\">833</span>)</span><br><span class=\"line\">java.lang.IndexOutOfBoundsException: Index <span class=\"number\">5</span> out of bounds <span class=\"keyword\">for</span> length <span class=\"number\">5</span></span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:<span class=\"number\">64</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:<span class=\"number\">70</span>)</span><br><span class=\"line\">\tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:<span class=\"number\">266</span>)</span><br><span class=\"line\">\tat java.base/java.util.Objects.checkIndex(Objects.java:<span class=\"number\">359</span>)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.remove(ArrayList.java:<span class=\"number\">504</span>)</span><br><span class=\"line\">\tat DataRace.lambda$main$<span class=\"number\">0</span>(DataRace.java:<span class=\"number\">16</span>)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:<span class=\"number\">833</span>)</span><br><span class=\"line\">Final size: <span class=\"number\">11</span></span><br><span class=\"line\">    </span><br><span class=\"line\">进程已结束,退出代码<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>程序最终输出的列表大小是 11。这表明：</p>\n<ol>\n<li>尽管有多个删除操作失败，但添加操作仍在继续</li>\n<li>添加操作比删除操作成功次数更多</li>\n<li>列表最终处于不一致状态（可能有空元素或损坏数据）</li>\n</ol>\n<p>程序以状态码 0 退出，表示 JVM 认为程序”正常结束”，尽管实际上有多个线程崩溃。这是并发问题的典型表现 - 部分线程崩溃但进程继续运行。</p>\n<h3 id=\"根本原因总结\"><a href=\"#根本原因总结\" class=\"headerlink\" title=\"根本原因总结\"></a>根本原因总结</h3><p>​\t1.多个线程同时修改ArrayList（添加和删除）导致的数据竞争和结构破坏。</p>\n<p>​\t2.一个读取线程在遍历列表时可能因为并发修改而抛出ConcurrentModificationException，或者读取到不一致的状态。</p>\n<h3 id=\"Java线程安全修改后代码\"><a href=\"#Java线程安全修改后代码\" class=\"headerlink\" title=\"Java线程安全修改后代码\"></a>Java线程安全修改后代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataRace</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 共享状态 - 所有线程共享这个ArrayList</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> List&lt;Integer&gt; data = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 控制线程运行的标志 - volatile确保多线程可见性</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">running</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建了一个专用的锁对象用于同步访问共享数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        List&lt;Thread&gt; modifierThreads = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建4个修改线程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">modifier</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 同步修改操作</span></span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            data.remove(data.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        data.add((<span class=\"type\">int</span>) (Math.random() * <span class=\"number\">100</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 短暂休眠减少CPU竞争</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">1</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            modifierThreads.add(modifier);</span><br><span class=\"line\">            modifier.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建读取线程</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 同步读取操作</span></span><br><span class=\"line\">                <span class=\"comment\">// 使用 synchronized块包装所有修改操作，确保同一时间只有一个线程能修改列表。</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;[&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (Integer num : data) &#123;</span><br><span class=\"line\">                        sb.append(num).append(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    sb.append(<span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Current data: &quot;</span> + sb);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (data.size() &gt; <span class=\"number\">0</span> &amp;&amp; data.get(data.size() - <span class=\"number\">1</span>) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        System.err.println(<span class=\"string\">&quot;!!! Detected null element at index &quot;</span> + (data.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">10</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        reader.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 运行5秒后停止</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        running = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待所有线程结束</span></span><br><span class=\"line\">        reader.join();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Thread t : modifierThreads) t.join();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 同样使用 synchronized块包装读取操作，确保读取时不会有其他线程修改列表。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Final size: &quot;</span> + data.size());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Rust-如何预防这些问题\"><a href=\"#Rust-如何预防这些问题\" class=\"headerlink\" title=\"Rust 如何预防这些问题\"></a>Rust 如何预防这些问题</h3><p>在 Rust 中，类似的代码根本不会编译通过：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试在多个线程中修改</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 编译错误：闭包可能比当前函数活得久</span></span><br><span class=\"line\">        thread::<span class=\"title function_ invoke__\">spawn</span>(|| &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> data.<span class=\"title function_ invoke__\">len</span>() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                data.<span class=\"title function_ invoke__\">remove</span>(data.<span class=\"title function_ invoke__\">len</span>()-<span class=\"number\">1</span>); <span class=\"comment\">// 错误！</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            data.<span class=\"title function_ invoke__\">push</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 错误！</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试同时读取</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, data); <span class=\"comment\">// 错误！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rust 编译器会强制你使用线程安全的共享方式：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::&#123;Arc, Mutex&#125;;  <span class=\"comment\">// 导入Arc（原子引用计数）和Mutex（互斥锁）</span></span><br><span class=\"line\"><span class=\"keyword\">use</span> std::thread;              <span class=\"comment\">// 导入线程模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建共享数据：使用Arc包装Mutex，Mutex内部包含初始向量[1, 2, 3] Arc实现了Sync，可以安全地跨线程共享引用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">data</span> = Arc::<span class=\"title function_ invoke__\">new</span>(Mutex::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建线程句柄的向量，用于后续等待线程完成</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">handles</span> = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建4个工作线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 克隆Arc指针（增加引用计数），使每个线程拥有自己的引用</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">data</span> = Arc::<span class=\"title function_ invoke__\">clone</span>(&amp;data);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">handle</span> = thread::<span class=\"title function_ invoke__\">spawn</span>(<span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取互斥锁的守卫（guard），阻塞直到获得锁</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">guard</span> = data.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 先获取向量长度并存储在局部变量中</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"variable\">len</span> = guard.<span class=\"title function_ invoke__\">len</span>();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果向量非空，移除最后一个元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> len &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                guard.<span class=\"title function_ invoke__\">remove</span>(len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 向向量末尾添加新元素4</span></span><br><span class=\"line\">            guard.<span class=\"title function_ invoke__\">push</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将线程句柄存入向量</span></span><br><span class=\"line\">        handles.<span class=\"title function_ invoke__\">push</span>(handle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有线程完成：遍历所有线程句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">handle</span> <span class=\"keyword\">in</span> handles &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 等待线程结束，unwrap()用于处理可能的错误</span></span><br><span class=\"line\">        handle.<span class=\"title function_ invoke__\">join</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取最终结果：再次获取锁来访问数据</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, data.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种设计确保：</p>\n<ol>\n<li>共享数据必须通过互斥锁访问</li>\n<li>锁自动管理，不会忘记释放</li>\n<li>编译时保证不会出现数据竞争</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><strong>Rust：</strong> 追求<strong>绝对安全</strong>和<strong>零成本抽象</strong>。通过强大的<strong>编译时检查</strong>从根本上消除内存错误和数据竞争，需要付出学习成本来理解和遵循这些规则，但换来的是极高的运行时信心和性能。目标是“如果编译通过，就不会错”（在并发安全方面）。</li>\n<li><strong>Java：</strong> 追求<strong>开发便利性</strong>和<strong>成熟的生态系统</strong>。通过<strong>运行时机制</strong>管理内存和并发。入门相对容易，但编写<strong>正确且高效</strong>的并发程序需要深入理解运用各种并发工具。调试并发 Bug 是主要挑战。</li>\n</ul>\n","text":"Rust与Java在并发安全上的对比核心安全机制 Rust： 类型系统强制执行： 在编译时由 Rust 编译器严格检查。违反规则会导致编译错误。 并发安全 (S...","permalink":"/post/Rust与Java在并发安全上的对比","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"Rust","slug":"Rust","count":2,"path":"api/tags/Rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Rust%E4%B8%8EJava%E5%9C%A8%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">Rust与Java在并发安全上的对比</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%B8%E5%BF%83%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">核心安全机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">对比</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">代码演示</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">根本原因总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BF%AE%E6%94%B9%E5%90%8E%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">Java线程安全修改后代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Rust-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Rust 如何预防这些问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"day13-test","uid":"0c3e8d5785c978b0561e8f3dd89f9941","slug":"day13-test","date":"2025-08-27T07:58:17.000Z","updated":"2025-09-02T07:47:32.426Z","comments":true,"path":"api/articles/day13-test.json","keywords":null,"cover":[],"text":"1、演示csrf漏洞配合存储型XSS修改其他用户密码DVWA靶场5个默认用户名密码： admin/passwordgordonb/abc1231337/char...","permalink":"/post/day13-test","photos":[],"count_time":{"symbolsCount":992,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"练习","slug":"练习","count":14,"path":"api/tags/练习.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"day12-test","uid":"3573bf1d520c4107730189122a19bec7","slug":"day12-test","date":"2025-08-26T07:52:04.000Z","updated":"2025-09-02T07:47:23.518Z","comments":true,"path":"api/articles/day12-test.json","keywords":null,"cover":[],"text":"1、通关文件上传靶场1，2，3，4，10关卡Pass-01直接上传 .php 文件会发现不让上传 修改文件后缀为 .png ，再次上传，抓包，将后缀改回 .ph...","permalink":"/post/day12-test","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"练习","slug":"练习","count":14,"path":"api/tags/练习.json"}],"author":{"name":"wyf","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/Five0ne15/picgo_pic@main/picgo_picture/18ca1dd2a86b2210b1ab142498bcf0b0.jpg","link":"/","description":"不知道应该写点什么，就这么看着吧","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}